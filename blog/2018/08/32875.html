<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Liuxfe的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="keywords" content="source"><meta name="description" content="版本：v16.5.2
前言当时在各种前端框架或库充斥市场的情况下，出现了大量优秀的框架，比如 Backbone、Angular、Knockout、Ember 这些框架大都采用了 MV* 的理念，..."><title>React 源码全方位剖析 | Liuxfe的博客</title><link rel="icon" href="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css"><link rel="stylesheet" href="/css/style.css?rev=@@hash.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9312750344484857" crossorigin="anonymous"></script></head><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Liuxfe"><img src="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>-------------</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="https://www.liuxfe.com">Liuxfe的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i> 首页</a></li><li role="presentation" class="text-center"><a href="/blog/"><i class="fa"></i> 博客</a></li><li role="presentation" class="text-center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhwiki.netlify.app"><i class="fa"></i> 维基百科</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="React 源码全方位剖析">React 源码全方位剖析</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="/blog/category/react/">react</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-none-link" href="/blog/tagged/source/" rel="tag">source</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2018/08/12</span></span></div><p class="fa fa-exclamation-triangle warning">本文于<strong> 1374</strong> 天之前发表，文中内容可能已经过时。</p></div><div class="post-body post-content"><p><code>版本：v16.5.2</code></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当时在各种前端框架或库充斥市场的情况下，出现了大量优秀的框架，比如 Backbone、Angular、Knockout、Ember 这些框架大都采用了 MV* 的理念，把数据与视图分离。而就在这样纷繁复杂的时期，React 诞生于 Facebook 的内部项目，因为该公司对市场上所有 JavaScript MVC 框架，都不满意，就决定自己写一套，用来架设 Instagram 的网站。做出来以后，发现这套东西很好用，就在2013年5月开源了。所谓知其然还要知其所以然，加上 React 真是一天一改，如果现在不看，以后也真的很难看懂了。目前社区有很多 React 的源码剖析文章，趁着最近工作不忙，我打算分享一下 React 源码，并自形成一个系列，欢迎一起交流。在开始之前我们先做以下几点约定：</p><p><strong>第一：</strong>目前分析的版本是 React 的最新版本 16.5.2；<br><strong>第二：</strong>React web应用是最常见的，也是最易于理解的，所以该源码均围绕 React web应用剖析；<br><strong>第三：</strong>我尽可能站在我自己的角度去剖析，当然我会借鉴社区比较优秀的文章，同时面对大家的拍砖，我无条件接受，也很乐意与大家一起交换意见，努力写好该 React 源码系列；<br><strong>第四：</strong>如果有幸您读到该 React 源码系列，感觉写得还行，还望收藏、分享或打赏。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>我们从这一章开始即将分析 React 的源码，在分析源码之前我们很有必要介绍一些前置知识如flow、Rollup等。除此之外，我们最好已经用过 React 做过实际项目，对 React 的思想有了一定的了解，对绝大部分的 API 都已经有使用，同时，我们应该有一定的HTML、CSS、JavaScript、ES6+、node &amp; npm等功底，并对代码调试有一定的了解。</p><p>如果具备了以上条件，并且对 React 的实现原理很感兴趣，那么就可以开始 React 的底层学习了，对它的实现细节一探究竟。</p><h3 id="Flow-JavaScript静态类型检查工具"><a href="#Flow-JavaScript静态类型检查工具" class="headerlink" title="Flow - JavaScript静态类型检查工具"></a>Flow - JavaScript静态类型检查工具</h3><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://flow.org/">Flow</a> 是 facebook 出品的 JavaScript 静态类型检查工具，它与 Typescript 不同的是，它可以部分引入，不需要完全重构整个项目，所以对于一个已有一定规模的项目来说，迁移成本更小，也更加可行。除此之外，Flow 可以提供实时增量的反馈，通过运行 Flow server 不需要在每次更改项目的时候完全从头运行类型检查，提高运行效率。可以简单总结为：<strong>对于新项目，可以考虑使用 TypeScript 或者 Flow，对于已有一定规模的项目则建议使用 Flow 进行较小成本的逐步迁移来引入类型检查。React 的源码利用了 Flow 做了静态类型检查，所以了解 Flow 有助于我们阅读源码。</strong></p><h4 id="为什么用静态类型检查工具-Flow"><a href="#为什么用静态类型检查工具-Flow" class="headerlink" title="为什么用静态类型检查工具 Flow"></a>为什么用静态类型检查工具 Flow</h4><p>JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用就是很容易就写出非常隐蔽的隐患代码，在编译期甚至运行时看上去都不会报错，但是可能会发生各种各样奇怪的和难以解决的bug。</p><p>类型检查是当前动态类型语言的发展趋势，所谓类型检查，就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。</p><p>项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。React 源码在 ES2015 的基础上，除了用 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。之所以选择 Flow，<strong>最根本原因应该和 Vue 一样，还是在于工程上成本和收益的考量。</strong> 大致体现在以下几点：</p><p><strong>第一点：</strong>使用 Flow 可以一个一个文件地迁移，如果使用 TypeScript，则需要全部替换，成本极高，短期内并不现实；<br><strong>第二点：</strong>Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力；<br><strong>第三点：</strong>更贴近 ES 规范。除了 Flow 的类型声明之外，其他都是标准的 ES。万一哪天不想用 Flow 了，用<code>babel-plugin-transform-flow-strip-types</code>转一下，就得到符合规范的 ES；<br><strong>第四点：</strong>在需要的地方保留 ES 的灵活性，并且对于生成的代码尺寸有更好的控制力 (rollup / 自定义 babel 插件）。</p><h4 id="如何用静态类型检查工具-Flow"><a href="#如何用静态类型检查工具-Flow" class="headerlink" title="如何用静态类型检查工具 Flow"></a>如何用静态类型检查工具 Flow</h4><p>在这里我们就简单说一说 Flow 的用法，其他用法可以参考<a target="_blank" rel="noopener external nofollow noreferrer" href="https://flow.org/">Flow官网</a>（可能需要 VPN，非常不稳定），有时间我会详细写一篇 Flow 使用指南。</p><p>Flow 仅仅是一个用于检查的工具，安装使用都很方便，使用时注意以下3点即可：</p><p>1.将 Flow 安装到我们的项目中。<br>2.确保编译之后的代码移除了 Flow 相关的语法。<br>3.在需要检查的地方增加了 Flow 相关的类型注解。</p><p><strong>第一点：将Flow增加到我们的项目中</strong></p><p>安装最新版本的 Flow：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm install --save-dev flow-bin</code></pre><p>安装完成之后在 package.json 文件中增加执行脚本：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
  &#x2F;&#x2F; ...
  &quot;scripts&quot;: &#123;
    &quot;your-script-name&quot;: &quot;flow&quot;,
    &#x2F;&#x2F; ...
  &#125;,
  &#x2F;&#x2F; ...
&#125;</code></pre><p>然后初始化 Flow：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm run flow init</code></pre><p>执行完成后，Flow 会在终端输出以下内容：</p><pre class="line-numbers language-none"><code class="language-none">&gt; yourProjectName@1.0.0 flow &#x2F;yourProjectPath
&gt; flow &quot;init&quot;</code></pre><p>然后在根目录下生成一个名为 .flowconfig 的文件，打开之后是这样的：</p><pre class="line-numbers language-none"><code class="language-none">[ignore]

[include]

[libs]

[lints]

[options]

[strict]</code></pre><p>基本上，配置文件没有什么特殊需求是不用去配置的，Flow 默认涵盖了当前目录之后的所有文件。[include] 用于引入项目之外的文件。例如：</p><pre class="line-numbers language-none"><code class="language-none">[include]

..&#x2F;otherProject&#x2F;a.js

[libs]</code></pre><p>它会将和当前项目平级的 otherProject/a.js 文件纳入进来。详细配置文件请看<a target="_blank" rel="noopener external nofollow noreferrer" href="https://flow.org/en/docs/config/">官网</a>。</p><p><strong>第二点：编译之后的代码移除 Flow 相关的语法</strong></p><p>Flow 在 JavaScript 语法的基础上使用了一些注解（annotation）进行了扩展。因此浏览器无法正确的解读这些 Flow 相关的语法，我们必须在编译之后的代码中（最终发布的代码）将增加的 Flow 注解移除掉。具体方法需要看我们使用了什么样的编译工具。下面将说明一些 React 开发常用的编译工具：</p><p><strong>方式一：</strong>create-react-app</p><p>如果我们的项目是使用<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/create-react-app">create-react-app</a>直接创建的，那么移除 Flow 语法的事项就不用操心了，create-react-app 已经帮我们搞定了这个事。</p><p><strong>方式二：</strong>Babel</p><p>如果使用 Babel 我们需要安装一个 Babel 对于 Flow 的 preset：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ npm install --save-dev babel-preset-flow</code></pre><p>然后，我们需要在项目根目录<a target="_blank" rel="noopener external nofollow noreferrer" href="http://babeljs.io/docs/en/babelrc/">Babel 的配置文件 .babelrc</a>中添加一个 Flow 相关的 preset：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
  &quot;presets&quot;: [
    &quot;flow&quot;,
    &#x2F;&#x2F;other config
  ]
&#125;</code></pre><p><strong>方式三：</strong>flow-remove-types</p><p>如果我们既没有使用 create-react-app 也没使用 Babel 作为语法糖编译器，那么可以使用 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flowtype/flow-remove-types">flow-remove-types</a> 这个工具在发布之前移除 Flow 代码。</p><p><strong>第三点：在需要检查的地方增加 Flow 相关的类型注解</strong></p><p>如果我们了解 C++/C# 的元编程或者 Java 的 Annotation，那么理解 Flow 的 Annotation 就会非常轻松。大概就是在文件、方法、代码块之前增加一个注解（Annotation）用来告知 Flow 的执行行为。</p><p>首先，Flow 只检查包含<code>// @flow</code>注解的文件，所以如果需要检查，我们需要这样编写我们的文件，首先我们写一个正确的示例：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;* @flow *&#x2F;

function add(x: number, y: number): number &#123;
  return x + y
&#125;

add(22, 11)</code></pre><p>运行 Flow 终端会打印出以下内容：</p><pre class="line-numbers language-none"><code class="language-none">&gt; yourProjectName@1.0.0 flow &#x2F;yourProjectPath
&gt; flow &quot;init&quot;

Found 0 errors</code></pre><p>承接上面代码，我们把代码修改成带有检查错误的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;* @flow *&#x2F;

function add(x: number, y: number): number &#123;
  return x + y
&#125;

add(&quot;Hello&quot;, 11)</code></pre><p>运行 Flow 终端会打印出以下内容：</p><pre class="line-numbers language-none"><code class="language-none">&gt; yourProjectName@1.0.0 flow &#x2F;yourProjectPath
&gt; flow &quot;init&quot;

Error ------------------------------------------------------------------------------------- src&#x2F;platforms&#x2F;web&#x2F;mnr.js:8:5

Cannot call &#96;add&#96; with &#96;&quot;Hello&quot;&#96; bound to &#96;x&#96; because string [1] is incompatible with number [2].

   src&#x2F;platforms&#x2F;web&#x2F;mnr.js:8:5
   8| add(&quot;Hello&quot;, 11)
          ^^^^^^^ [1]

References:
   src&#x2F;platforms&#x2F;web&#x2F;mnr.js:4:17
   4| function add(x: number, y: number): number &#123;
                      ^^^^^^ [2]



Found 1 error</code></pre><p>到这里，Flow 已经算是安装成功了，接下来的事是要增加各种注解以加强类型限定或者参数检测。之后的内容将简要介绍 flow 的类型检查方式。</p><h4 id="Flow-的类型检查方式"><a href="#Flow-的类型检查方式" class="headerlink" title="Flow 的类型检查方式"></a>Flow 的类型检查方式</h4><p>现在我们就说说 Flow 常用的2种类型检查方式：<br><strong>类型推断</strong>：通过变量的执行上下文来推断出变量类型，然后根据这些推断来检查类型。<br><strong>类型注释</strong>：事先注释好我们期望的类型，Flow 会基于这些注释来检查。</p><p><strong>第一种方式：类型推断</strong></p><p>此方式不需要编写任何代码即可进行类型检查，最小化开发者的工作量，它也不会强制我们改变开发习惯，因为它会自动推断出变量的类型，这就是所谓的类型推断，Flow 最重要的特性之一。</p><p>通过一个简单例子说明一下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;*@flow*&#x2F;

function split(str) &#123;
  return str.split(&#39; &#39;)
&#125;

split(11)</code></pre><p>Flow 检查上述代码后会报错，因为函数 split 期待的参数是字符串，而我们输入的是数字。</p><p><strong>第二种方式：类型注释</strong></p><p>如上所述，类型推断是 Flow 最有用的特性之一，不需要编写任何代码就能进行类型检查。但在某些特定的场景下，使用类型注释可以提供更好更明确的检查依据。</p><p>看看以下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;*@flow*&#x2F;

function add(x, y)&#123;
  return x + y
&#125;

add(&#39;Hello&#39;, 11)</code></pre><p>Flow 根据类型推断检查上述代码时检查不出任何错误，因为从语法层面考虑， + 既可以用在字符串上，也可以用在数字上，我们并没有明确指出 add() 的参数必须为数字。在这种情况下，我们可以借助类型注释来指明期望的类型。类型注释是以冒号 : 开头，可以在函数参数，返回值，变量声明中使用。如果我们在上段代码中使用类型注释，就会变成如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;*@flow*&#x2F;

function add(x: number, y: number): number &#123;
  return x + y
&#125;

add(&#39;Hello&#39;, 11)</code></pre><p>现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。上面的例子是针对函数的类型注释。接下来我们来看看 Flow 能支持的一些常见的类型注释:</p><p><strong>第一种：</strong>数组</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;*@flow*&#x2F;

var arr: Array&lt;number&gt; &#x3D; [1, 2, 3]

arr.push(&#39;Hello&#39;)</code></pre><p>数组类型注释的格式是 Array<t>，T 表示数组中每项的数据类型。在上述代码中，arr 是每项均为数字的数组。如果我们给这个数组添加了一个字符串，Flow 能检查出错误。</t></p><p><strong>第二种：</strong>类和对象</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;*@flow*&#x2F;

class Bar &#123;
  x: string;           &#x2F;&#x2F; x 是字符串
  y: string | number;  &#x2F;&#x2F; y 可以是字符串或者数字
  z: boolean;

  constructor(x: string, y: string | number) &#123;
    this.x &#x3D; x
    this.y &#x3D; y
    this.z &#x3D; false
  &#125;
&#125;

var bar: Bar &#x3D; new Bar(&#39;hello&#39;, 4)

var obj: &#123; a: string, b: number, c: Array&lt;string&gt;, d: Bar &#125; &#x3D; &#123;
  a: &#39;hello&#39;,
  b: 11,
  c: [&#39;hello&#39;, &#39;world&#39;],
  d: new Bar(&#39;hello&#39;, 3)
&#125;</code></pre><p>类的类型注释格式如上，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。这里需要注意的是：属性 y 的类型中间用 | 做间隔，表示 y 的类型即可以是字符串也可以是数字。</p><p>对象的注释类型类似于类，需要指定对象属性的类型。</p><p><strong>第三种：</strong>Null/undefined</p><p>Flow 会检查所有的 JavaScript 基础类型—— Boolean、String、Number、null、undefined（在Flow中用void代替）。除此之外还提供了一些操作符号，例如 text : ?string，它表示参数存在“没有值”的情况，除了传递 string 类型之外，还可以是 null 或 undefined。需要特别注意的是，这里的没有值和 JavaScript 的表达式的“非”是两个概念，Flow 的“没有值”只有 null、void（undefined），而 JavaScript 表达式的“非”包含：null、undefined、0、false。</p><p>如果想任意类型 T 可以为 null 或者 undefined，只需写成如下 ?T 的格式即可：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;*@flow*&#x2F;

var foo: ?string &#x3D; null</code></pre><p>此时，foo 可以为字符串，也可以为 null。</p><h4 id="Flow-在-React-源码中的应用"><a href="#Flow-在-React-源码中的应用" class="headerlink" title="Flow 在 React 源码中的应用"></a>Flow 在 React 源码中的应用</h4><p>Flow 是 Facebook 开源的静态代码检查工具，它的作用就是在运行代码之前对 React 组件以及 Jsx 语法进行静态代码的检查以发现一些可能存在的问题。在 React v16 Fiber中的部分 TypeScript 代码只是类型声明文件和测试代码，也就是为了方便利用 TypeScript 写应用的开发者使用 React，给了接口定义和测试样例而已。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>React 重构告诉我们，项目重构要么依赖规范，要么就得自己有绝对控制权，同时还要考量开发成本、项目收益以及整个团队的技术水平，并不是一味的什么火就用什么。这一节主要对 Flow 的认识，有助于我们后续阅读 React 的源码，这种静态类型检查的方式非常有利于大型项目源码的开发和维护。</p><h3 id="Rollup-另一个前端模块化的打包工具"><a href="#Rollup-另一个前端模块化的打包工具" class="headerlink" title="Rollup - 另一个前端模块化的打包工具"></a>Rollup - 另一个前端模块化的打包工具</h3><p>Rollup 是前端模块化的一个打包工具，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序。简单地说，<strong>它可以从一个入口文件开始，将所有使用的模块根据命令或者根据 Rollup 配置文件打包成一个目标文件，并且 Rollup 会自动过滤掉那些没有被使用过的函数或变量，从而使代码最小化，如果想使用直接导入这一个目标文件即可，因此 Rollup 极其适合构建一个工具库。</strong></p><p>这里提到 Rollup 的两个特别重要的特性，<strong>第一个就是它使用了 ES2015 的模板标准，这意味着我们可以直接使用 import 和 export 而不需要引入 babel。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。</strong>举个简单的例子，我们在 foo.js 文件定义了 f1 和 f2 两个方法，然后在入口文件 index.js 只引入了 foo.js 文件中的 f1 方法，那么在最后打包 index.js 文件时，Rollup 就不会将 f2 方法打包到最终文件中（这个特性是基于 ES6 模块的静态分析的，也就是说，只有 export 而没有 import 的变量是不会被打包到最终代码中的）。</p><h4 id="为什么用前端模块化的打包工具-Rollup"><a href="#为什么用前端模块化的打包工具-Rollup" class="headerlink" title="为什么用前端模块化的打包工具 Rollup"></a>为什么用前端模块化的打包工具 Rollup</h4><p>之前的构建系统是基于 Gulp/Grunt+Browserify 手搓的一套工具，后来在扩展方面受限于工具，例如：</p><p>Node 环境下性能不好：频繁的<code>process.env.NODE_ENV</code>访问拖慢了<code>SSR 性能</code>，但又没办法从类库角度解决，因为<code>Uglify</code>依靠这个去除无用代码，所以<code>React SSR</code>性能最佳实践一般都有一条“<code>重新打包 React，在构建时去掉 process.env.NODE_ENV</code>”.</p><p>丢弃了过于复杂（overly-complicated）的自定义构建工具，改用更合适的 Rollup：</p><blockquote><p>It solves one problem well: how to combine multiple modules into a flat file with minimal junk code in between.</p></blockquote><p>无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，应该在“手搓”方面吸取教训，为什么业界规范的东西在我们的场景不适用，非要自己造吗？</p><h4 id="如何用前端模块化的打包工具-Rollup"><a href="#如何用前端模块化的打包工具-Rollup" class="headerlink" title="如何用前端模块化的打包工具 Rollup"></a>如何用前端模块化的打包工具 Rollup</h4><p>关于如何使用前端模块化的打包工具 Rollup，这里就不做过多介绍了，可参考我之前写的一篇文章：<a href="/2018/08/04/rollup-tutorial.html">Rollup使用指南</a>，更详细的使用文档可参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.rollupjs.com/guide/zh">官网</a>。</p><h4 id="Webpack-和-Rollup-有什么不同"><a href="#Webpack-和-Rollup-有什么不同" class="headerlink" title="Webpack 和 Rollup 有什么不同"></a>Webpack 和 Rollup 有什么不同</h4><p>2017年4月初，Facebook 将一个巨大的 pull 请求合并到了 React 主分支(master)中，将其现有的构建流程替换为基于 Rollup，这一举动促使一些人产生很大的疑惑“React 为什么选择 Rollup 而抛弃 webpack”，难道webpack要跌下神坛了？</p><p>Webpack 是目前使用最为火热的打包工具，没有之一，每月有数百万的下载量，为成千上万的网站和应用提供支持。相比之下，Rollup 并不起眼。但 React 并不孤单 – Vue，Ember，Preact，D3，Three.js，Moment 以及其他许多知名的库也使用 Rollup 。世界到底怎么了？为什么我们不能只有一个大众认可的 JavaScript 模块化打包工具？</p><p>Webpack 始于2012年，由 Tobias Koppers 发起，用于解决当时现有工具未解决的的一个难题：<strong>构建复杂的单页应用程序(SPA)。</strong>特别是 webpack 的两个特性改变了一切：</p><p><strong>第一个特性：</strong>代码拆分(Code Splitting)</p><p>代码拆分也就是说我们可以将应用程序分解成可管理的代码块，可以按需加载，这意味着用户可以快速获取网站内容，而不必等到整个应用程序下载和解析完成。</p><p><strong>第二个特性：</strong>各式各样的加载器（loader）</p><p>不管是图像，css，还是 html ，在 Webpack 看来一切都可作为模块，然后通过不同的加载器 loader 来加载它们。</p><p>ES6 发布之后，其中引入的模块机制使得静态分析成为了可能，于是 Rollup 发布了：其中 Rollup 有两个特别重要的特性，第一个就是它利用 ES2015 巧妙的模块设计，尽可能高效的构建出能够直接被其他 Javascript 库的。另一个重要特性叫做 tree-shaking，这个特性可以帮助我们将无用代码（即没有使用的代码）从最终的目标文件中过滤掉。</p><p>紧接着 Webpack2 发布，仿照 Rollup 增加了 tree-shaking。 在之后， Webpack3 发布，仿照 Rollup 又增加了 Scope Hoisting。在在之后， Parcel 发布了一个快速、零配置的打包工具。于是，Webpack4 仿照 Parcel 发布了。</p><p>说了这么多，工作中我们到底该用哪个工具？</p><p>对于应用使用 webpack，对于类库使用 Rollup。如果我们需要代码拆分(Code Splitting)，或者我们有很多静态资源需要处理，再或者我们构建的项目需要引入很多 CommonJS 模块的依赖，那么 webpack 是个很不错的选择。如果您的代码库是基于 ES2015 模块的，而且希望我们写的代码能够被其他人直接使用，我们需要的打包工具可能是 Rollup。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>无论 Haste -&gt; ES Module 还是 Gulp/Grunt+Browserify -&gt; Rollup 的切换都是从非标准的定制化方案切换到标准的开放的方案，可以看出 React 团队也在积极拥抱标准方案并非一味造轮子。其实 Vue.js 1.0.10 就已经使用 Rollup 了，而 React v16.0 改用 Rollup 肯定也有借鉴之意，因此，好技术都是在借鉴的大背景下诞生的（Vue 就是一个典型的例子）。在这里通过对 Rollup 的认识，有助于我们了解 React 的构建以及源码目录结构。</p><h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>上一章我们简单介绍了下flow、Rollup等前置知识，有兴趣的可以有针对性的学习它们。这一章我们真正的开始分析 React 源码，激动不激动？该章主要包括三小节：项目目录、源码构建、源码入口。</p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>我们主要剖析的 React 源码目录在 packages 下，在这里我们看看详细目录结构，混个眼熟：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">├── build --------------------------------------- 构建后的输出目录
├── fixtures ------------------------------------ React 开发的测试用例
├── packages ------------------------------------ 源码目录，我们主要剖析目录
│   ├── create-subscription --------------------- 在组件里订阅额外数据的工具
│   ├── events ---------------------------------- 事件处理 
│   ├── interaction-tracking -------------------- 跟踪交互事件
│   ├── react ----------------------------------- 核心代码
│   ├── react-art ------------------------------- 矢量图形库
│   ├── react-dom ------------------------------- DOM 渲染相关
│   ├── react-is -------------------------------- React 元素类型相关
│   ├── react-native-renderer ------------------- react-native 渲染相关 
│   ├── react-noop-renderer --------------------- Fiber 测试相关 
│   ├── react-reconciler ------------------------ React 调制器
│   ├── react-scheduler ------------------------- 规划 React 初始化，更新等等
│   ├── react-test-renderer --------------------- 实验性的 React 渲染器
│   ├── shared ---------------------------------- 通用代码
│   ├── simple-cache-provider ------------------- 为 React 应用提供缓存
│   ├── server ---------------------------------- 服务端渲染
│   ├── sfc ------------------------------------- .vue 文件解析
│   ├── shared ---------------------------------- 整个项目通用代码
├── scripts ------------------------------------- 公共的lint，build，test和release等相关的文件
│   ├── eslint ---------------------------------- 语法规则和代码风格
│   ├── flow ------------------------------------ Flow 类型声明
│   ├── git ------------------------------------- git钩子的目录
│   ├── jest ------------------------------------ JavaScript 测试目录
│   ├── release --------------------------------- 自动发布新版本脚本
│   ├── rollup ---------------------------------- rollup 构建目录
├── .babelrc ------------------------------------ babel 配置文件
├── .editorconfig ------------------------------- 编辑器语法规范配置
├── .eslintignore ------------------------------- eslint 忽略配置 
├── .eslintrc ----------------------------------- eslint 配置文件
├── .gitattributes ------------------------------ 给 attributes 路径名的简单文本文件
├── .gitignore ---------------------------------- git 忽略配置
├── .mailmap ------------------------------------ 邮件列表档案 
├── .nvmrc -------------------------------------- nvm 配置文件
├── .prettierrc.js ------------------------------ prettierrc 配置文件
├── .watchmanconfig ----------------------------- watchman 配置文件
├── appveyor.yml -------------------------------- GitHub 托管项目的自动化集成
├── AUTHORS ------------------------------------- 开发者列表档案
├── CHANGELOG.md -------------------------------- 更新日志
├── CODE_OF_CONDUCT.md -------------------------- Code of Conduct
├── CONTRIBUTING.md ----------------------------- Contributing to React
├── dangerfile.js ------------------------------- 提高 Code Review 体验
├── netlify.toml -------------------------------- 持续集成静态网站
├── package-lock.json --------------------------- npm 加锁文件
├── package.json -------------------------------- 项目管理文件
├── README.md ----------------------------------- 项目文档
├── yarn.lock ----------------------------------- yarn 加锁文件</code></pre><p>一眼望去，上面的目录结构是不是感觉很是奇怪？<br><strong>根目录下没有 src 之类的源码目录，也没有 test 这类的存放单元测试的目录，只有一个 packages 目录。这个 repository 其实是一个用 Lerna 管理的 monorepo。实际上，我们往npm上发布的几个package都来自于同一个codebase，包括react、react-dom、react-is……</strong></p><h4 id="monorepo"><a href="#monorepo" class="headerlink" title="monorepo"></a>monorepo</h4><p>通常，当我们的项目不断的迭代更新的时候，我们会根据业务或者是功能又或者是方便复用某些代码模块，把一个大的 codebase 拆成一些独立的 package 或 module，再将这些功能独立的 package 分别放入单独的 repository 中进行维护，此方式可以简单地称为<code>multiple repositories</code>。而 monorepo 则是一种相反的做法，它提倡将所有的相关 package 都放入一个 repository 来管理。</p><p><strong>monorepo VS multirepo（集中管理 vs 多元化）</strong><br>首先这两者都是管理组织代码的方式，顾名思义 monorepo 就是把所有的相关项目都放在一个仓库中（比如 React, Angular, Babel, Google…），multirepo 则是按模块分为多个仓库。</p><p><strong>multirepo：</strong>这种管理方式可以让每个子团队拥有自己的 repo，我们可以用自己擅长的工具、workflow 等等。多元化能促使各个团队尽可能的提升自己的效率。但代价也在于会增加很多沟通成本，如果我们项目用到的库中发现了一个 bug，就必须到目标库里修复它、打包、发版本，然后再回到我们的库继续工作。在不同的仓库间，我们不仅需要处理不同的代码、工具，甚至是不同的工作流程。甚至我们只能去问维护这个仓库的人，能不能为我们做出改变，然后等着他们去解决。</p><p><strong>monorepo：</strong>这种管理方式可以让不同的团队走自己的路，并不见得能提高生产力。虽然有些团队可能会找到自己最佳的工作方式，但我们的收益也会被其他团队不那么好的工作方式所抵消。相反，严格统一的管理更能提升效率，团队中的任何人都可以（并且应该也被鼓励）修改任何东西（因为修改造成的结果马上就能展现出来，）。虽然把所有的鸡蛋都放进了一个篮子里，但我们也可以更小心的照顾这个篮子。</p><p>如果我们团队选择 monorepo，那主要的挑战自然是随着项目的发展，其会变得非常庞大（因为没有根据模块或功能拆分成不同 repo）。因此会需要很多的工具来应对这样的挑战。虽然我们可能认为这是一个很糟糕的做法，但是现在这样做的开源项目和公司并不算少。</p><p><strong>谁在使用 monorepo</strong><br>Babel 是一个 Javascript 编译器，它可以将浏览器环境尚未支持的 Javascript 变为向下兼容的版本。因此，我们可以毫无顾虑地使用较新的 Javascript 语法和特性来提升编程的体验和效率。</p><p>其中 Babel 官方维护了众多独立的 plugin、polyfill、preset，但并未按照传统，将这些独立的模块分别放入不同的 repo。而是遵循了 monorepo 的方式，将它们放入一个相同的 repo 中。因为 Babel 认为，有效的组织一个多模块，多 repo 的项目，就像是尝试教一个刚出生的婴儿骑自行车一样。</p><blockquote><p>Juggling a multimodule project over multiple repos is like trying to teach a newborn baby how to ride a bike.</p></blockquote><p>所以，Babel 采用了 lerna 来管理自己的 monorepo。</p><p>无独有偶，Cycle.js（一个函数式和响应式 Javascript 框架）的作者 André Staltz 也摒弃了一个 package 一个 repo 的做法，将 Cycle.js 的众多 package 迁移到了一个 monorepo 中。他也认为，管理多个 repo 并不是件有意思的事情。多个 repo 意味着有多个地方需要处理 issue，保持多个 repo 的 issue 标签统一，管理很多 PR 和 git 钩子等等。</p><blockquote><p>Managing multiple repos isn’t that fun. Multiple repos means multiple places to manage issues, manage issue labels (and making them consistent across repos), manage PRs, git hooks for conventions, etc.</p></blockquote><p>André Staltz 并没有使用 lerna 之类的工具来实现自己的 monorepo，他自己通过 Bash sh 实现了类似于 Lerna 管理的 monorepo。</p><p>除了 Babel 和 Cycle.js 以外，React、Angular、Meteor、Ember，还包括国内饿了么的 mint-ui 等等开源项目，以及一些公司如 Google、Facebook、BBC 等也都采用了 monorepo。它到底有什么优点，这么多公司，这么多库纷纷加入。</p><p><strong>优点</strong><br><strong>一：</strong>单个的 lint，build，test 和 release 流程；<br><strong>二：</strong>统一的地方处理issue；<br><strong>三：</strong>不用到处去找自己项目的repo；<br><strong>四：</strong>方便管理版本和dependencies；<br><strong>五：</strong>跨项目的操作和修改变得容易；<br><strong>六：</strong>方便生成总的changelog。</p><p><strong>缺点</strong><br><strong>一：</strong>repo 的体积变得很大；<br><strong>二：</strong>安全问题，如何管理权限。</p><p>关于 monorepo 我们暂且就说这么多，有时间我会单独写一篇 monorepo 文章。</p><h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>从 React 的目录设计可以看出，React 团队在项目管理比较倾向 monorepo 方式，看来这种严格统一的管理方式真的提升效率。无论 monorepo 方式，还是 multirepo 方式都是为了团队效率，因此建议还是根据团队的情况选定一种方式，尽可能的扬长避短。</p><h3 id="源码构建"><a href="#源码构建" class="headerlink" title="源码构建"></a>源码构建</h3><p>React v16.0 之前源码是基于<code>Gulp/Grunt+Browserify</code>构建的，而 React v16.0 是基于<code>Rollup</code>构建的，它的构建相关配置都在<code>scripts/rollup</code>目录下。</p><h4 id="构建命令"><a href="#构建命令" class="headerlink" title="构建命令"></a>构建命令</h4><p>通常基于 NPM 托管的项目都会有一个 package.json 文件，实际上它是项目的描述文件，它的内容是一个标准的 JSON 对象。我们通常会配置 script 字段作为 NPM 的构建命令，React 源码构建配置如下：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
    &#x2F;&#x2F; ...
    &quot;scripts&quot;: &#123;
        &quot;build&quot;: &quot;npm run version-check &amp;&amp; node .&#x2F;scripts&#x2F;rollup&#x2F;build.js&quot;,
        &#x2F;&#x2F; ...
        &quot;version-check&quot;: &quot;node .&#x2F;scripts&#x2F;tasks&#x2F;version-check.js&quot;
    &#125;
    &#x2F;&#x2F; ...
&#125;</code></pre><p>这里<code>build命令</code>，实际上先执行<code>version-check</code>命令，然后执行<code>node ./scripts/rollup/build.js</code>进行打包，其中<code>version-check</code>命令实际上是执行<code>node ./scripts/tasks/version-check.js</code>，用于检查即将构建的<code>bundle版本</code>是否完全匹配，接下来我们就来看看它实际上是如何构建的。</p><h4 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h4><p>我们首先打开<code>build</code>命令对应的第一个 JS 文件，在<code>scripts/tasks/version-check.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const reactVersion &#x3D; require(&#39;..&#x2F;..&#x2F;package.json&#39;).version;
const versions &#x3D; &#123;
  &#39;packages&#x2F;react&#x2F;package.json&#39;: require(&#39;..&#x2F;..&#x2F;packages&#x2F;react&#x2F;package.json&#39;)
    .version,
  &#39;packages&#x2F;react-dom&#x2F;package.json&#39;: require(&#39;..&#x2F;..&#x2F;packages&#x2F;react-dom&#x2F;package.json&#39;)
    .version,
  &#39;packages&#x2F;react-test-renderer&#x2F;package.json&#39;: require(&#39;..&#x2F;..&#x2F;packages&#x2F;react-test-renderer&#x2F;package.json&#39;)
    .version,
  &#39;packages&#x2F;shared&#x2F;ReactVersion.js&#39;: require(&#39;..&#x2F;..&#x2F;packages&#x2F;shared&#x2F;ReactVersion&#39;),
&#125;;

let allVersionsMatch &#x3D; true;
Object.keys(versions).forEach(function(name) &#123;
  const version &#x3D; versions[name];
  if (version !&#x3D;&#x3D; reactVersion) &#123;
    allVersionsMatch &#x3D; false;
    console.log(
      &#39;%s version does not match package.json. Expected %s, saw %s.&#39;,
      name,
      reactVersion,
      version
    );
  &#125;
&#125;);

if (!allVersionsMatch) &#123;
  process.exit(1);
&#125;
</code></pre><p>这段代码逻辑非常简单，先获取<code>即将发布的以及源码核心bundle</code>的管理文件，再比对<code>即将发布的和源码核心bundle</code>的版本，如果不相同，给出对应的提示并结束构建，这样就保证了构建出来的 bundle 版本统一。</p><p>接下来我们打开<code>build</code>命令对应的第二个 JS 文件，在<code>scripts/rollup/build.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">async function buildEverything() &#123;
  await asyncRimRaf(&#39;build&#39;);

  &#x2F;&#x2F; Run them serially for better console output
  &#x2F;&#x2F; and to avoid any potential race conditions.
  &#x2F;&#x2F; eslint-disable-next-line no-for-of-loops&#x2F;no-for-of-loops
  for (const bundle of Bundles.bundles) &#123;
    await createBundle(bundle, UMD_DEV);
    await createBundle(bundle, UMD_PROD);
    &#x2F;&#x2F; ...
  &#125;
  &#x2F;&#x2F; ...
  &#x2F;&#x2F; ...
&#125;

buildEverything();</code></pre><p>这里通过调用<code>buildEverything</code>函数开启构建过程，<code>asyncRimRaf</code>用于删除上一次打包生成的包文件，然后循环包配置文件的配置构建出不同用途的 React 包，稍后我们再来看构建函数<code>createBundle</code>，我们先来看看包配置文件，在<code>scripts/rollup/bundles.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const bundles &#x3D; [
  &#x2F;******* Isomorphic *******&#x2F;
  &#123;
    label: &#39;core&#39;,
    bundleTypes: [
      UMD_DEV,
      UMD_PROD,
      NODE_DEV,
      NODE_PROD,
      FB_WWW_DEV,
      FB_WWW_PROD,
    ],
    moduleType: ISOMORPHIC,
    entry: &#39;react&#39;,
    global: &#39;React&#39;,
    externals: [],
  &#125;,
    &#x2F;******* React DOM *******&#x2F;
  &#123;
    label: &#39;dom-client&#39;,
    bundleTypes: [
      UMD_DEV,
      UMD_PROD,
      NODE_DEV,
      NODE_PROD,
      NODE_PROFILING,
      FB_WWW_DEV,
      FB_WWW_PROD,
      FB_WWW_PROFILING,
    ],
    moduleType: RENDERER,
    entry: &#39;react-dom&#39;,
    global: &#39;ReactDOM&#39;,
    externals: [&#39;react&#39;],
  &#125;,
  &#x2F;&#x2F; ...
  &#x2F;&#x2F; ...
];

module.exports &#x3D; &#123;
  bundles,
&#125;;</code></pre><p>这里简单列举了一些 React 包构建的配置，其他已省略，可以看出实际上这是一个用于 Rollup 构建配置的对象数组，通过循环该对象数组构建出不同用途的 React 包。接下来我们再看一下构建函数<code>createBundle</code>，在<code>scripts/rollup/build.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">async function createBundle(bundle, bundleType) &#123;
  if (shouldSkipBundle(bundle, bundleType)) &#123;
    return;
  &#125;

  const filename &#x3D; getFilename(bundle.entry, bundle.global, bundleType);
  const logKey &#x3D;
    chalk.white.bold(filename) + chalk.dim(&#96; ($&#123;bundleType.toLowerCase()&#125;)&#96;);
  const format &#x3D; getFormat(bundleType);
  const packageName &#x3D; Packaging.getPackageName(bundle.entry);

  let resolvedEntry &#x3D; require.resolve(bundle.entry);
  if (
    bundleType &#x3D;&#x3D;&#x3D; FB_WWW_DEV ||
    bundleType &#x3D;&#x3D;&#x3D; FB_WWW_PROD ||
    bundleType &#x3D;&#x3D;&#x3D; FB_WWW_PROFILING
  ) &#123;
    const resolvedFBEntry &#x3D; resolvedEntry.replace(&#39;.js&#39;, &#39;.fb.js&#39;);
    if (fs.existsSync(resolvedFBEntry)) &#123;
      resolvedEntry &#x3D; resolvedFBEntry;
    &#125;
  &#125;

  const shouldBundleDependencies &#x3D;
    bundleType &#x3D;&#x3D;&#x3D; UMD_DEV || bundleType &#x3D;&#x3D;&#x3D; UMD_PROD;
  const peerGlobals &#x3D; Modules.getPeerGlobals(bundle.externals, bundleType);
  let externals &#x3D; Object.keys(peerGlobals);
  if (!shouldBundleDependencies) &#123;
    const deps &#x3D; Modules.getDependencies(bundleType, bundle.entry);
    externals &#x3D; externals.concat(deps);
  &#125;

  const importSideEffects &#x3D; Modules.getImportSideEffects();
  const pureExternalModules &#x3D; Object.keys(importSideEffects).filter(
    module &#x3D;&gt; !importSideEffects[module]
  );

  const rollupConfig &#x3D; &#123;
    input: resolvedEntry,
    treeshake: &#123;
      pureExternalModules,
    &#125;,
    external(id) &#123;
      const containsThisModule &#x3D; pkg &#x3D;&gt; id &#x3D;&#x3D;&#x3D; pkg || id.startsWith(pkg + &#39;&#x2F;&#39;);
      const isProvidedByDependency &#x3D; externals.some(containsThisModule);
      if (!shouldBundleDependencies &amp;&amp; isProvidedByDependency) &#123;
        return true;
      &#125;
      return !!peerGlobals[id];
    &#125;,
    onwarn: handleRollupWarning,
    plugins: getPlugins(
      bundle.entry,
      externals,
      bundle.babel,
      filename,
      packageName,
      bundleType,
      bundle.global,
      bundle.moduleType,
      bundle.modulesToStub
    ),
    &#x2F;&#x2F; We can&#39;t use getters in www.
    legacy:
      bundleType &#x3D;&#x3D;&#x3D; FB_WWW_DEV ||
      bundleType &#x3D;&#x3D;&#x3D; FB_WWW_PROD ||
      bundleType &#x3D;&#x3D;&#x3D; FB_WWW_PROFILING,
  &#125;;
  const [mainOutputPath, ...otherOutputPaths] &#x3D; Packaging.getBundleOutputPaths(
    bundleType,
    filename,
    packageName
  );
  const rollupOutputOptions &#x3D; getRollupOutputOptions(
    mainOutputPath,
    format,
    peerGlobals,
    bundle.global,
    bundleType
  );

  console.log(&#96;$&#123;chalk.bgYellow.black(&#39; BUILDING &#39;)&#125; $&#123;logKey&#125;&#96;);
  try &#123;
    const result &#x3D; await rollup(rollupConfig);
    await result.write(rollupOutputOptions);
  &#125; catch (error) &#123;
    console.log(&#96;$&#123;chalk.bgRed.black(&#39; OH NOES! &#39;)&#125; $&#123;logKey&#125;\n&#96;);
    handleRollupError(error);
    throw error;
  &#125;
  for (let i &#x3D; 0; i &lt; otherOutputPaths.length; i++) &#123;
    await asyncCopyTo(mainOutputPath, otherOutputPaths[i]);
  &#125;
  console.log(&#96;$&#123;chalk.bgGreen.black(&#39; COMPLETE &#39;)&#125; $&#123;logKey&#125;\n&#96;);
&#125;</code></pre><p>上述关键的代码是<code>const result = await rollup(rollupConfig);</code>，可以看出这是通过 rollup 打包的，对于单个配置，它是遵循 Rollup 的构建规则的。其中 input 属性表示构建的入口 JS 文件地址，output.file 属性表示构建后的输出的 JS 文件地址，format 属性表示构建的格式，cjs 表示构建出来的文件遵循<a target="_blank" rel="noopener external nofollow noreferrer" href="http://wiki.commonjs.org/wiki/Modules/1.1">CommonJS 规范</a>，es 表示构建出来的文件遵循<a target="_blank" rel="noopener external nofollow noreferrer" href="http://exploringjs.com/es6/ch_modules.html">ES Module 规范</a>，umd 表示构建出来的文件遵循<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/umdjs/umd">UMD 规范</a>。</p><p>下面我们以配置文件的第一个<code>react</code>配置为例：</p><p>构建的入口 JS 文件地址：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">let resolvedEntry &#x3D; require.resolve(bundle.entry);</code></pre><p>沿着<code>bundle.entry</code>我们发现它的值为<code>react</code>（在<code>scripts/rollup/bundles.js</code>中），<code>require.resolve</code>用于查询文件的完整绝对路径，也就说<code>react</code>对应的真实入口路径是<code>/**/**/react/packages/react/index.js</code>，由此不难看出所有源码都在<code>packages</code>中：</p><p>构建后的输出的 JS 文件地址：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const [mainOutputPath, ...otherOutputPaths] &#x3D; Packaging.getBundleOutputPaths(
    bundleType,
    filename,
    packageName
);</code></pre><p>接下来我们看看<code>Packaging.getBundleOutputPaths</code>，在<code>scripts/rollup/packaging.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function getBundleOutputPaths(bundleType, filename, packageName) &#123;
  switch (bundleType) &#123;
    case NODE_DEV:
    case NODE_PROD:
    case NODE_PROFILING:
      return [&#96;build&#x2F;node_modules&#x2F;$&#123;packageName&#125;&#x2F;cjs&#x2F;$&#123;filename&#125;&#96;];
    case UMD_DEV:
    case UMD_PROD:
      return [
        &#96;build&#x2F;node_modules&#x2F;$&#123;packageName&#125;&#x2F;umd&#x2F;$&#123;filename&#125;&#96;,
        &#96;build&#x2F;dist&#x2F;$&#123;filename&#125;&#96;,
      ];
    &#x2F;&#x2F; ...
    default:
      throw new Error(&#39;Unknown bundle type.&#39;);
  &#125;
&#125;</code></pre><p>从上面不难看出所有打包后的输出文件都在<code>build</code>，这就是为什么打包前先删除<code>build</code>文件了。</p><h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>通过这一节的分析，我们可以了解到 React 的打包过程，也知道了不同作用和功能的 React 对应的入口以及最终编译生成的 JS 文件。</p><h3 id="源码入口"><a href="#源码入口" class="headerlink" title="源码入口"></a>源码入口</h3><h4 id="React-对象"><a href="#React-对象" class="headerlink" title="React 对象"></a>React 对象</h4><p>实际项目中，可以看到首先需要使用如下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import React from &#39;react&#39;;</code></pre><p>这句代码做的就是引入了React核心源码模块。而我们在源码构建一节讲到 React 的核心入口文件是<code>packages/react/index.js</code>:</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#39;use strict&#39;;

const React &#x3D; require(&#39;.&#x2F;src&#x2F;React&#39;);

&#x2F;&#x2F; TODO: decide on the top-level export form.
&#x2F;&#x2F; This is hacky but makes it work with both Rollup and Jest.
module.exports &#x3D; React.default || React;</code></pre><p>上述代码中执行<code>import React from &#39;react&#39;</code>时，其实引入的就是这里提供的对象。</p><p>这里需要说明一点：这里为什么会导出 React.default || React？（以下提到的插件都可以在源码中找到）</p><ol><li><strong>React.default 用于 Jest 测试</strong><br>babel解析器将 es6 的 export、import等模块关键字转换成 commonjs 的规范，babel 转换 es6 的模块输出逻辑非常简单，即将所有输出都赋值给 exports。其中<code>packages/react/src/React.js</code>使用<code>export default</code>导出 React 对象，这里 babel 会将其转化<code>exports.default = React</code>，因此导入的结果其实是一个含 default 属性的对象，因此需要使用 React.default 来获取实际的 React 对象。</li><li><strong>React 用于 Rollup</strong><br>rollup-plugin-node-resolve 插件可以解决 ES6 模块的查找导入，如果npm中的包以CommonJS模块的形式出现的，我们可以使用rollup-plugin-commonjs 将CommonJS模块转换为ES6来为Rollup获得兼容（即令(ES6)import === (CommonJS)require），导入的结果其实是不含 default 属性的对象，因此直接使用 React 来获取实际的 React 对象。</li></ol><p>在这个入口 JS 的上方我们可以找到 React 的来源：<code>const React = require(&#39;./src/React&#39;);</code>，我们来看一下这块儿的实现，它定义在<code>packages/react/src/React.js</code> 中，</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import ReactVersion from &#39;shared&#x2F;ReactVersion&#39;;
import &#123;
  REACT_ASYNC_MODE_TYPE,
  REACT_FRAGMENT_TYPE,
  REACT_PROFILER_TYPE,
  REACT_STRICT_MODE_TYPE,
  REACT_PLACEHOLDER_TYPE,
&#125; from &#39;shared&#x2F;ReactSymbols&#39;;
import &#123;enableSuspense&#125; from &#39;shared&#x2F;ReactFeatureFlags&#39;;

import &#123;Component, PureComponent&#125; from &#39;.&#x2F;ReactBaseClasses&#39;;
import &#123;createRef&#125; from &#39;.&#x2F;ReactCreateRef&#39;;
import &#123;forEach, map, count, toArray, only&#125; from &#39;.&#x2F;ReactChildren&#39;;
import &#123;
  createElement,
  createFactory,
  cloneElement,
  isValidElement,
&#125; from &#39;.&#x2F;ReactElement&#39;;
import &#123;createContext&#125; from &#39;.&#x2F;ReactContext&#39;;
import &#123;lazy&#125; from &#39;.&#x2F;ReactLazy&#39;;
import forwardRef from &#39;.&#x2F;forwardRef&#39;;
import &#123;
  createElementWithValidation,
  createFactoryWithValidation,
  cloneElementWithValidation,
&#125; from &#39;.&#x2F;ReactElementValidator&#39;;
import ReactSharedInternals from &#39;.&#x2F;ReactSharedInternals&#39;;

const React &#x3D; &#123;
  Children: &#123;
    map,
    forEach,
    count,
    toArray,
    only,
  &#125;,

  createRef,
  Component,
  PureComponent,

  createContext,
  forwardRef,

  Fragment: REACT_FRAGMENT_TYPE,
  StrictMode: REACT_STRICT_MODE_TYPE,
  unstable_AsyncMode: REACT_ASYNC_MODE_TYPE,
  unstable_Profiler: REACT_PROFILER_TYPE,

  createElement: __DEV__ ? createElementWithValidation : createElement,
  cloneElement: __DEV__ ? cloneElementWithValidation : cloneElement,
  createFactory: __DEV__ ? createFactoryWithValidation : createFactory,
  isValidElement: isValidElement,

  version: ReactVersion,

  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: ReactSharedInternals,
&#125;;

if (enableSuspense) &#123;
  React.Placeholder &#x3D; REACT_PLACEHOLDER_TYPE;
  React.lazy &#x3D; lazy;
&#125;

export default React;</code></pre><p>上述就是我们 React 的庐山真面目，实际上它的内容是一个标准的 JSON 对象，这里 React 对象里面包含什么一目了然，比如我们常用的Component、PureComponent等，由此可以看出React核心内容只包括定义组件相关的内容和API。</p><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>React 的定位是一个构建用户界面的JavaScript类库，它使用JavaScript语言开发UI组件，可以使用多种方式渲染这些组件，输出用户界面，很大程度上达到了跨平台的能力：</p><blockquote><p>We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code.</p></blockquote><p>现在的 React 在以下几个方面都发挥着很不错的效果：</p><ol><li>React Web应用用户界面开发；</li><li>React Native App用户界面开发；</li><li>Node.js 服务端渲染；</li></ol><p>在这些不同场景，渲染的主体很明显是不一样的，有诸如web应用的DOM渲染，React Native的原生View渲染，服务端字符串渲染等，要做到兼容适应多种不同渲染环境，很显然，React不能局限固定渲染UI的方式。</p><p>上一节我们讲到React核心内容只涉及如何定义组件，并不涉及具体的组件渲染（即输出用户界面），这需要引入额外渲染模块，下面以渲染React定义的组件为例：</p><p><strong>React DOM渲染模块：</strong>React DOM渲染模块：将React组件渲染为DOM，然后可以被浏览器处理呈现给用户，这就是通常在web应用中引入的react-dom模块：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;.&#x2F;App&#39;;

ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));</code></pre><p>上述代码中，App是使用React核心模块定义的组件，然后使用react-dom渲染模块提供的render方法将其渲染为DOM输出至页面。</p><p><strong>React Native 渲染：</strong>：将React组件渲染为移动端原生View，在React Native应用中引入react-native模块，它提供相应渲染方法可以渲染React组件：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; AppRegistry &#125; from &#39;react-native&#39;;
import App from &#39;.&#x2F;src&#x2F;app.js&#39;;

AppRegistry.registerComponent(&#39;fuc&#39;, () &#x3D;&gt; App);</code></pre><p>上述代码中，App是React根组件，使用react-native渲染器的AppRegistry.registerComponent方法将其渲染为原生View。</p><p><strong>React测试渲染：</strong>将React组件渲染为JSON树，用来完成Jest的快照测试，内容在react-test-renderer模块：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import ReactTestRenderer from &#39;react-test-renderer&#39;; 
const renderer &#x3D; ReactTestRenderer.create(
  &lt;Link page&#x3D;&quot;https:&#x2F;&#x2F;www.facebook.com&#x2F;&quot;&gt;Facebook&lt;&#x2F;Link&gt;
); 
console.log(renderer.toJSON()); 
&#x2F;&#x2F; &#123; type: &#39;a&#39;,
&#x2F;&#x2F;   props: &#123; href: &#39;https:&#x2F;&#x2F;www.facebook.com&#x2F;&#39; &#125;,
&#x2F;&#x2F;   children: [ &#39;Facebook&#39; ] &#125;
</code></pre><h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>那么至此，我们应该对 React 是什么有一个直观的认识，它本质上是含有诸多属性的JavaScript对象，它核心内容只涉及如何定义组件，具体的组件渲染（即输出用户界面），需要引入额外的渲染模块，渲染组件方式由环境决定，定义组件，组件状态管理，生命周期方法管理，组件更新等应该跨平台一致处理，不受渲染环境影响，这部分内容统一由调和器（Reconciler）处理，不同渲染器都会使用该模块。调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件。至于 React 能做什么，它是怎么做的，我们会在后面的章节一一剖析它们。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在正式进入流程分析之前，我们先来了解一些 React 源码内部的基本概念，读懂这些有助于我们更好地理解整个流程。</p><h3 id="ReactElement"><a href="#ReactElement" class="headerlink" title="ReactElement"></a>ReactElement</h3><p>我们在写 React 组件时，通常会使用JSX来描述组件，经过babel（Facebook早期有提供自己的编译器，后来Babel发展为社区jsx语法的主要编译工具）编译成对应的<code>React.createElement(type, props, children)</code>形式。</p><p>将以下代码放到<a target="_blank" rel="noopener external nofollow noreferrer" href="https://babeljs.io/repl/">Babel</a>官网上编译一下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class App extends Component &#123;
  render() &#123;
    return (
      &lt;div className&#x3D;&quot;App&quot;&gt;
        &lt;header className&#x3D;&quot;App-header&quot;&gt;
          &lt;img src&#x3D;&#123;logo&#125; className&#x3D;&quot;App-logo&quot; alt&#x3D;&quot;logo&quot; &#x2F;&gt;
          &lt;p&gt;
            Edit &lt;code&gt;src&#x2F;App.js&lt;&#x2F;code&gt; and save to reload.
          &lt;&#x2F;p&gt;
          &lt;a
            className&#x3D;&quot;App-link&quot;
            href&#x3D;&quot;https:&#x2F;&#x2F;reactjs.org&quot;
            target&#x3D;&quot;_blank&quot;
            rel&#x3D;&quot;noopener noreferrer&quot;
          &gt;
            Learn React
          &lt;&#x2F;a&gt;
        &lt;&#x2F;header&gt;
        &lt;Hello &#x2F;&gt;
        &lt;Inner text&#x3D;&quot;heiheihei&quot;&gt;
          &lt;div&gt;yoyoyo&lt;&#x2F;div&gt;
        &lt;&#x2F;Inner&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre><p>经过Babel编译后：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">React.createElement(
  &quot;div&quot;,
  &#123; className: &quot;App&quot; &#125;,
  React.createElement(
    &quot;header&quot;,
    &#123; className: &quot;App-header&quot; &#125;,
    React.createElement(&quot;img&quot;, &#123; src: logo, className: &quot;App-logo&quot;, alt: &quot;logo&quot; &#125;),
    React.createElement(
      &quot;p&quot;,
      null,
      &quot;Edit &quot;,
      React.createElement(
        &quot;code&quot;,
        null,
        &quot;src&#x2F;App.js&quot;
      ),
      &quot; and save to reload.&quot;
    ),
    React.createElement(
      &quot;a&quot;,
      &#123;
        className: &quot;App-link&quot;,
        href: &quot;https:&#x2F;&#x2F;reactjs.org&quot;,
        target: &quot;_blank&quot;,
        rel: &quot;noopener noreferrer&quot;
      &#125;,
      &quot;Learn React&quot;
    )
  ),
  React.createElement(Hello, null),
  React.createElement(
    Inner,
    &#123; text: &quot;heiheihei&quot; &#125;,
    React.createElement(
      &quot;div&quot;,
      null,
      &quot;yoyoyo&quot;
    )
  )
);</code></pre><p>可以看出我们使用JSX来编写的组件会被编译成调用React.createElement的形式。如果组件里的DOM标签的首字母为大写的时候，这个标签（类 =&gt; 自定义组件类， 函数 =&gt; 无状态组件）则会被作为参数传递给createElement；如果DOM标签的首字母为小写，则将标签名（div, span, a 等html的 DOM标签）以字符串的形式传给createElement；如果是字符串或者空的话，则直接将字符串或者null当做参数传递给createElement。接下来我们React.createElement的源码。</p><p>React.createElement的源码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export function createElement(type, config, children) &#123;
  let propName;

  &#x2F;&#x2F; Reserved names are extracted
  const props &#x3D; &#123;&#125;;

  let key &#x3D; null;
  let ref &#x3D; null;
  let self &#x3D; null;
  let source &#x3D; null;

  &#x2F;&#x2F; 将参数赋给props对象
  if (config !&#x3D; null) &#123;
    if (hasValidRef(config)) &#123;
      ref &#x3D; config.ref;
    &#125;
    if (hasValidKey(config)) &#123;
      key &#x3D; &#39;&#39; + config.key;
    &#125;

    self &#x3D; config.__self &#x3D;&#x3D;&#x3D; undefined ? null : config.__self;
    source &#x3D; config.__source &#x3D;&#x3D;&#x3D; undefined ? null : config.__source;
    &#x2F;&#x2F; Remaining properties are added to a new props object
    for (propName in config) &#123;
      &#x2F;&#x2F; 跳过React保留的参数
      if (
        hasOwnProperty.call(config, propName) &amp;&amp;
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) &#123;
        props[propName] &#x3D; config[propName];
      &#125;
    &#125;
  &#125;

  &#x2F;&#x2F; 将子元素按照顺序赋给children的数组
  &#x2F;&#x2F; Children can be more than one argument, and those are transferred onto
  &#x2F;&#x2F; the newly allocated props object.
  const childrenLength &#x3D; arguments.length - 2;
  if (childrenLength &#x3D;&#x3D;&#x3D; 1) &#123;
    props.children &#x3D; children;
  &#125; else if (childrenLength &gt; 1) &#123;
    const childArray &#x3D; Array(childrenLength);
    for (let i &#x3D; 0; i &lt; childrenLength; i++) &#123;
      childArray[i] &#x3D; arguments[i + 2];
    &#125;
    if (__DEV__) &#123;
      if (Object.freeze) &#123;
        Object.freeze(childArray);
      &#125;
    &#125;
    props.children &#x3D; childArray;
  &#125;

  &#x2F;&#x2F; 对于默认的参数，判断是否有传入值，有的话直接将参数和对应的值赋给props，否则将参数和参数默认值赋给props
  &#x2F;&#x2F; Resolve default props
  if (type &amp;&amp; type.defaultProps) &#123;
    const defaultProps &#x3D; type.defaultProps;
    for (propName in defaultProps) &#123;
      if (props[propName] &#x3D;&#x3D;&#x3D; undefined) &#123;
        props[propName] &#x3D; defaultProps[propName];
      &#125;
    &#125;
  &#125;
  if (__DEV__) &#123;
    if (key || ref) &#123;
      const displayName &#x3D;
        typeof type &#x3D;&#x3D;&#x3D; &#39;function&#39;
          ? type.displayName || type.name || &#39;Unknown&#39;
          : type;
      if (key) &#123;
        defineKeyPropWarningGetter(props, displayName);
      &#125;
      if (ref) &#123;
        defineRefPropWarningGetter(props, displayName);
      &#125;
    &#125;
  &#125;
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props,
  );
&#125;

const ReactElement &#x3D; function(type, key, ref, self, source, owner, props) &#123;
  const element &#x3D; &#123;
    &#x2F;&#x2F; Symbol类型的tag唯一标示这个对象是一个React Element类型
    &#x2F;&#x2F; This tag allows us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    &#x2F;&#x2F; Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    &#x2F;&#x2F; Record the component responsible for creating this element.
    _owner: owner,
  &#125;;

  return element;
&#125;;</code></pre><p>我们可以看出createElement基本没做什么特别的处理，最终返回了一个ReactElement对象。<br>ReactElement是描述DOM节点或component实例的字面级对象，ReactElement主要包含了对象类型标识（$$typeof）、DOM节点的类型（type）和属性（props）。</p><table><thead><tr><th>key</th><th>type</th><th>desc</th></tr></thead><tbody><tr><td>$$typeof</td><td>Symbol &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Number</td><td>对象类型标识，用于判断当前Object属于哪一种类型的ReactElement</td></tr><tr><td>type</td><td>Function &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; String &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Symbol &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Number &nbsp;&nbsp;&nbsp;&#124;&nbsp;&nbsp;&nbsp; Object</td><td>如果当前ReactElement是一个ReactComponent，那这里将是它对应的Constructor；而普通HTML标签，一般都是String</td></tr><tr><td>props</td><td>Object</td><td>ReactElement上的所有属性，包含children这个特殊属性</td></tr></tbody></table><p>ReactElement只是保存了DOM需要的数据，并没有对应的方法来实现React提供给我们的那些功能和特性。ReactElement主要分为DOM Elements和Component Elements两种，我们称这样的对象为ReactElement。</p><p><strong>DOM Elements</strong><br>当节点的type属性为字符串时，它代表是普通的节点，如div，span：</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;
  type: &#39;button&#39;,
  props: &#123;
    className: &#39;button button-blue&#39;,
    children: &#123;
      type: &#39;b&#39;,
      props: &#123;
        children: &#39;OK!&#39;
      &#125;
    &#125;
  &#125;
&#125;</code></pre><p><strong>Component Elements</strong><br>当节点的type属性为一个函数或一个类时，它代表自定义的节点：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class Button extends React.Component &#123;
  render() &#123;
    const &#123; children, color &#125; &#x3D; this.props;
    return &#123;
      type: &#39;button&#39;,
      props: &#123;
        className: &#39;button button-&#39; + color,
        children: &#123;
          type: &#39;b&#39;,
          props: &#123;
            children: children
          &#125;
        &#125;
      &#125;
    &#125;;
  &#125;
&#125;
&#x2F;&#x2F; Component Elements
&#123;
  type: Button,
  props: &#123;
    color: &#39;blue&#39;,
    children: &#39;OK!&#39;
  &#125;
&#125;</code></pre><h3 id="ReactClass"><a href="#ReactClass" class="headerlink" title="ReactClass"></a>ReactClass</h3><p>ReactClass就是我们平时写的Component组件(类或函数)，例如上面的Button类。ReactClass实例化后调用render方法可返回DOM Element。</p><h3 id="ReactComponent"><a href="#ReactComponent" class="headerlink" title="ReactComponent"></a>ReactComponent</h3><p>ReactComponent是基于ReactElement创建的一个对象，这个对象保存了ReactElement的数据的同时注入了一些方法，这些方法可以用来实现我们熟知的那些React的特性。</p><h3 id="ReactRoot"><a href="#ReactRoot" class="headerlink" title="ReactRoot"></a>ReactRoot</h3><h2 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h2><h3 id="首次渲染"><a href="#首次渲染" class="headerlink" title="首次渲染"></a>首次渲染</h3><h4 id="渲染入口"><a href="#渲染入口" class="headerlink" title="渲染入口"></a>渲染入口</h4><p>在 Web 项目中，如果我们要将应用渲染至页面，通常会用如下代码：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;.&#x2F;App&#39;; &#x2F;&#x2F; 应用根组件

ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;)); &#x2F;&#x2F; 应用挂载容器DOM</code></pre><p>这里<code>react-dom</code>是浏览器端渲染React应用的模块，通过<code>ReactDOM.render(component, mountNode)</code>可以对<code>自定义组件/原生DOM/字符串</code>进行挂载。在React16中，虽然还是通过JSX编译得到一个虚拟DOM对象，但对这些虚拟DOM对象的再加工则是发生了翻天覆地的变化。我们需要追根溯底，看它是怎么一步步转换的。我们首先找到<code>ReactDOM.render</code>，源码在<code>packages/react-dom/src/client/ReactDOM.js</code>中，有三个类似的方法：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const ReactDOM: Object &#x3D; &#123;
  &#x2F;&#x2F; 新API，未来代替render
  hydrate(element: React$Node, container: DOMContainer, callback: ?Function) &#123;
    &#x2F;&#x2F; TODO: throw or warn if we couldn&#39;t hydrate?
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      true,
      callback,
    );
  &#125;,
  &#x2F;&#x2F; React15的重要API，逐渐退出舞台
  render(
    element: React$Element&lt;any&gt;,  &#x2F;&#x2F; react组件对象，通常是项目根组件
    container: DOMContainer, &#x2F;&#x2F; id为root的那个dom
    callback: ?Function, &#x2F;&#x2F; 回调函数
  ) &#123;
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    );
  &#125;,
  &#x2F;&#x2F; 将组件挂载到传入的 DOM 节点上（不稳定api）
  unstable_renderSubtreeIntoContainer(
    parentComponent: React$Component&lt;any, any&gt;,
    element: React$Element&lt;any&gt;,
    containerNode: DOMContainer,
    callback: ?Function,
  ) &#123;
    invariant(
      parentComponent !&#x3D; null &amp;&amp; ReactInstanceMap.has(parentComponent),
      &#39;parentComponent must be a valid React Component&#39;,
    );
    return legacyRenderSubtreeIntoContainer(
      parentComponent,
      element,
      containerNode,
      false,
      callback,
    );
  &#125;,
&#125;;</code></pre><p>这里<code>ReactDOM.render/hydrate/unstable_renderSubtreeIntoContainer/unmountComponentAtNode</code>都是<code>legacyRenderSubtreeIntoContainer</code>方法的加壳方法。因此<code>ReactDOM.render</code>实际调用了<code>legacyRenderSubtreeIntoContainer</code>，这是一个内部API。</p><h4 id="渲染虚拟dom树"><a href="#渲染虚拟dom树" class="headerlink" title="渲染虚拟dom树"></a>渲染虚拟dom树</h4><p><code>legacyRenderSubtreeIntoContainer</code>从字面可以看出它大致意思就是把虚拟的dom树渲染到真实的dom容器中，我们找到<code>legacyRenderSubtreeIntoContainer</code>方法，源码在<code>packages/react-dom/src/client/ReactDOM.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 渲染组件的子组件树至父容器
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component&lt;any, any&gt;, &#x2F;&#x2F; 父组件 这里为 null
  children: ReactNodeList, &#x2F;&#x2F; element 虚拟dom树
  container: DOMContainer, &#x2F;&#x2F; html中的dom根对象
  forceHydrate: boolean, &#x2F;&#x2F; 服务器端渲染标识 这里为false
  callback: ?Function, &#x2F;&#x2F; 回调函数 这里没有
) &#123;
  &#x2F;&#x2F; 对 container 进行校验
  invariant(
    isValidContainer(container),
    &#39;Target container is not a DOM element.&#39;,
  );

  if (__DEV__) &#123;
    &#x2F;&#x2F; 开发模式render时进行检查并提供许多有用的警告和错误提示信息
    topLevelUpdateWarnings(container);
  &#125;

  &#x2F;&#x2F; 获取 root 对象
  let root: Root &#x3D; (container._reactRootContainer: any);
  if (!root) &#123; &#x2F;&#x2F; 初次渲染时初始化
    &#x2F;&#x2F; 创建一个 FiberRoot对象 并将它缓存到DOM容器的_reactRootContainer属性
    root &#x3D; container._reactRootContainer &#x3D; legacyCreateRootFromDOMContainer(
      container, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
      forceHydrate, &#x2F;&#x2F; 服务器端渲染标识 这里为false
    );
    if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
      const originalCallback &#x3D; callback;
      callback &#x3D; function() &#123;
        const instance &#x3D; DOMRenderer.getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      &#125;;
    &#125;
    &#x2F;&#x2F; 初始化容器相关
    &#x2F;&#x2F; Initial mount should not be batched.
    DOMRenderer.unbatchedUpdates(() &#x3D;&gt; &#123;
      if (parentComponent !&#x3D; null) &#123;
        &#x2F;&#x2F; 向真实dom中挂载虚拟dom
        root.legacy_renderSubtreeIntoContainer(
          parentComponent, &#x2F;&#x2F; 父组件
          children, &#x2F;&#x2F; 虚拟dom树
          callback, &#x2F;&#x2F; 回调函数
        );
      &#125; else &#123;
        root.render(
          children, &#x2F;&#x2F; 虚拟dom树
          callback &#x2F;&#x2F; 回调函数
        );
      &#125;
    &#125;);
  &#125; else &#123;
    if (typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
      const originalCallback &#x3D; callback;
      callback &#x3D; function() &#123;
        const instance &#x3D; DOMRenderer.getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      &#125;;
    &#125;
    if (parentComponent !&#x3D; null) &#123;
      root.legacy_renderSubtreeIntoContainer(
        parentComponent, &#x2F;&#x2F; 父组件
        children, &#x2F;&#x2F; 虚拟dom树
        callback, &#x2F;&#x2F; 回调函数
      );
    &#125; else &#123;
      root.render(
        children, &#x2F;&#x2F; 虚拟dom树
        callback &#x2F;&#x2F; 回调函数
      );
    &#125;
  &#125;
  &#x2F;&#x2F; 返回根容器fiber树的根fiber实例
  return DOMRenderer.getPublicRootInstance(root._internalRoot);
&#125;

&#x2F;&#x2F; 源码在 packages&#x2F;react-reconciler&#x2F;src&#x2F;ReactFiberReconciler.js 中
export function getPublicRootInstance(
  container: OpaqueRoot,
): React$Component&lt;any, any&gt; | PublicInstance | null &#123;
  &#x2F;&#x2F; 获取fiber实例
  const containerFiber &#x3D; container.current;
  if (!containerFiber.child) &#123;
    return null;
  &#125;
  switch (containerFiber.child.tag) &#123;
    case HostComponent:
      return getPublicInstance(containerFiber.child.stateNode);
    default:
      return containerFiber.child.stateNode;
  &#125;
&#125;
</code></pre><p>由此可见，<code>legacyRenderSubtreeIntoContainer</code>主要执行了以下几个操作：<br><strong>root：</strong>由<code>legacyCreateRootFromDOMContainer</code>生成，该函数会生成一个<code>FiberRoot</code>对象挂载到真实的dom根节点上，有了这个对象，执行该对象上的一些方法可以将虚拟dom变成dom树挂载到根节点上。<br><strong>DOMRenderer.unbatchedUpdates：</strong><code>DOMRenderer.unbatchedUpdates</code>的回调执行<code>root.legacy_renderSubtreeIntoContainer</code>或<code>root.render</code>。<br><strong>root.legacy_renderSubtreeIntoContainer 和 root.render：</strong>如果有<code>parentComponent</code>，就执行<code>root.render</code>否则执行<code>root.legacy_renderSubtreeIntoContainer</code>。</p><h5 id="root"><a href="#root" class="headerlink" title="root"></a>root</h5><p>我们知道<code>root</code>是由<code>legacyCreateRootFromDOMContainer</code>生成的，我们找到<code>legacyCreateRootFromDOMContainer</code>函数，源码在<code>packages/react-dom/src/client/ReactDOM.js</code>中:</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function legacyCreateRootFromDOMContainer(
  container: DOMContainer, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
  forceHydrate: boolean,  &#x2F;&#x2F; 服务器端渲染标识 这里为false
): Root &#123;
  const shouldHydrate &#x3D;
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  &#x2F;&#x2F; 是否需要服务器端渲染
  if (!shouldHydrate) &#123;
    let warned &#x3D; false;
    let rootSibling;
    while ((rootSibling &#x3D; container.lastChild)) &#123;
      if (__DEV__) &#123;
        &#x2F;&#x2F; ...
      &#125;
      &#x2F;&#x2F; 将dom根节点清空
      container.removeChild(rootSibling);
    &#125;
  &#125;
  if (__DEV__) &#123;
    &#x2F;&#x2F; ...
  &#125;
  &#x2F;&#x2F; Legacy roots are not async by default.
  const isAsync &#x3D; false;
  return new ReactRoot(
    container, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
    isAsync, &#x2F;&#x2F; 是否异步模式，默认false
    shouldHydrate &#x2F;&#x2F; 服务器端渲染标识 这里为false
  );
&#125;</code></pre><p>我们发现该函数实际上返回的是由构造函数<code>ReactRoot</code>创建的对象。其中如果在非ssr的情况下，将dom根节点清空。我们找到构造函数<code>ReactRoot</code>，源码在<code>packages\react-dom\src\client\ReactDOM.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 构造函数
function ReactRoot(
  container: Container, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
  isAsync: boolean, &#x2F;&#x2F; 是否异步模式，默认false
  hydrate: boolean &#x2F;&#x2F; 服务器端渲染标识 这里为false
) &#123;
  &#x2F;&#x2F; FiberRoot 对象
  const root &#x3D; DOMRenderer.createContainer(
    container, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
    isAsync, &#x2F;&#x2F; 是否异步模式，默认false
    hydrate &#x2F;&#x2F; 服务器端渲染标识 这里为false
  );
  this._internalRoot &#x3D; root;
&#125;

&#x2F;&#x2F; 以下几个是原型方法
&#x2F;&#x2F; 渲染
ReactRoot.prototype.render &#x3D; function(
  children: ReactNodeList, &#x2F;&#x2F; 虚拟dom树
  callback: ?() &#x3D;&gt; mixed, &#x2F;&#x2F; 回调函数
): Work &#123;
  const root &#x3D; this._internalRoot;
  const work &#x3D; new ReactWork();
  callback &#x3D; callback &#x3D;&#x3D;&#x3D; undefined ? null : callback;
  if (__DEV__) &#123;
    warnOnInvalidCallback(callback, &#39;render&#39;);
  &#125;
  if (callback !&#x3D;&#x3D; null) &#123;
    work.then(callback);
  &#125;
  DOMRenderer.updateContainer(
    children, &#x2F;&#x2F; 虚拟dom树
    root, &#x2F;&#x2F; FiberRoot 对象
    null, &#x2F;&#x2F; 父组件 这里为 null
    work._onCommit
  );
  return work;
&#125;;

&#x2F;&#x2F; 销毁组件
ReactRoot.prototype.unmount &#x3D; function(callback: ?() &#x3D;&gt; mixed): Work &#123;
  &#x2F;&#x2F; ...
&#125;;
ReactRoot.prototype.legacy_renderSubtreeIntoContainer &#x3D; function(
  parentComponent: ?React$Component&lt;any, any&gt;,
  children: ReactNodeList,
  callback: ?() &#x3D;&gt; mixed,
): Work &#123;
  const root &#x3D; this._internalRoot;
  const work &#x3D; new ReactWork();
  callback &#x3D; callback &#x3D;&#x3D;&#x3D; undefined ? null : callback;
  if (__DEV__) &#123;
    warnOnInvalidCallback(callback, &#39;render&#39;);
  &#125;
  if (callback !&#x3D;&#x3D; null) &#123;
    work.then(callback);
  &#125;
  DOMRenderer.updateContainer(
    children, &#x2F;&#x2F; 虚拟dom树
    root, &#x2F;&#x2F; FiberRoot 对象
    parentComponent, &#x2F;&#x2F; 父组件
    work._onCommit
  );
  return work;
&#125;;
ReactRoot.prototype.createBatch &#x3D; function(): Batch &#123;
  &#x2F;&#x2F; ...
&#125;;</code></pre><p>可以看出构造函数<code>ReactRoot</code>有render、unmount、legacy_renderSubtreeIntoContainer等原型方法外，同时还声明了一个和fiber相关的<code>_internalRoot</code>属性。其中<code>render</code>和<code>legacy_renderSubtreeIntoContainer</code>原型方法都会去执行<code>DOMRenderer.updateContainer</code>方法更新容器内容，唯一差别就是第三个参数一个传<code>null</code>，一个传<code>parentComponent</code>。<code>_internalRoot</code>是由<code>DOMRenderer.createContainer</code>生成的。我们找到<code>DOMRenderer.createContainer</code>，源码在<code>packages\react-reconciler\src\ReactFiberReconciler.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export function createContainer(
  containerInfo: Container, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
  isAsync: boolean, &#x2F;&#x2F; 是否异步模式，默认false
  hydrate: boolean, &#x2F;&#x2F; 服务器端渲染标识 这里为false
): OpaqueRoot &#123;
  return createFiberRoot(
    containerInfo, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
    isAsync, &#x2F;&#x2F; 是否异步模式，默认false
    hydrate &#x2F;&#x2F; 服务器端渲染标识 这里为false
  );
&#125;</code></pre><p>接下来我们看看<code>createFiberRoot</code>是怎么将一个真实DOM变成一个Fiber对象，我们找到<code>createFiberRoot</code>，源码在 packages\react-reconciler\src\ReactFiberReconciler.js 中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function createFiberRoot(
  containerInfo: any, &#x2F;&#x2F; ReactDOM.render(&lt;div&#x2F;&gt;, container)的第二个参数，也就是一个元素节点
  isAsync: boolean, &#x2F;&#x2F; 是否异步模式，默认false
  hydrate: boolean, &#x2F;&#x2F; 服务器端渲染标识 这里为false
): FiberRoot &#123;
  &#x2F;&#x2F; 创建初始根组件对应的fiber实例
  const uninitializedFiber &#x3D; createHostRootFiber(isAsync);

  let root;
  if (enableSchedulerTracing) &#123;
    root &#x3D; (&#123;
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,

      interactionThreadID: unstable_getThreadID(),
      memoizedInteractions: new Set(),
      pendingInteractionMap: new Map(),
    &#125;: FiberRoot);
  &#125; else &#123;
    root &#x3D; (&#123;
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,
    &#125;: BaseFiberRootProperties);
  &#125;
  uninitializedFiber.stateNode &#x3D; root;
  return ((root: any): FiberRoot);
&#125;

&#x2F;&#x2F; 源码在 packages\react-reconciler\src\ReactFiber.js 中
&#x2F;&#x2F; 返回一个初始根组件对应的fiber实例
export function createHostRootFiber(isAsync: boolean): Fiber &#123;
  let mode &#x3D; isAsync ? AsyncMode | StrictMode : NoContext;

  if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;
    &#x2F;&#x2F; Always collect profile timings when DevTools are present.
    &#x2F;&#x2F; This enables DevTools to start capturing timing at any point–
    &#x2F;&#x2F; Without some nodes in the tree having empty base times.
    mode |&#x3D; ProfileMode;
  &#125;

  &#x2F;&#x2F; 创建 Fiber 实例
  return createFiber(
    HostRoot, &#x2F;&#x2F; 组件树根组件，可以嵌套
    null, 
    null, 
    mode
  );
&#125;

&#x2F;&#x2F; 源码在 packages\react-reconciler\src\ReactFiber.js 中
&#x2F;&#x2F; 创建 Fiber 实例
const createFiber &#x3D; function(
  tag: WorkTag, &#x2F;&#x2F; 标记 fiber 类型
  pendingProps: mixed, &#x2F;&#x2F; 当前处理过程中的组件props对象
  key: null | string, &#x2F;&#x2F; 调和阶段，标识fiber，以检测是否可重用该fiber实例
  mode: TypeOfMode,
): Fiber &#123;
  &#x2F;&#x2F; $FlowFixMe: the shapes are exact here but Flow doesn&#39;t like constructors
  return new FiberNode(tag, pendingProps, key, mode);
&#125;;

&#x2F;&#x2F; 源码在 packages\react-reconciler\src\ReactFiber.js 中
function FiberNode(
  tag: WorkTag,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
) &#123;
  &#x2F;&#x2F; Instance
  this.tag &#x3D; tag;
  this.key &#x3D; key;
  this.type &#x3D; null;
  this.stateNode &#x3D; null;

  &#x2F;&#x2F; Fiber
  this.return &#x3D; null;
  this.child &#x3D; null;
  this.sibling &#x3D; null;
  this.index &#x3D; 0;

  this.ref &#x3D; null;

  this.pendingProps &#x3D; pendingProps;
  this.memoizedProps &#x3D; null;
  this.updateQueue &#x3D; null;
  this.memoizedState &#x3D; null;
  this.firstContextDependency &#x3D; null;

  this.mode &#x3D; mode;

  &#x2F;&#x2F; Effects
  this.effectTag &#x3D; NoEffect;
  this.nextEffect &#x3D; null;

  this.firstEffect &#x3D; null;
  this.lastEffect &#x3D; null;

  this.expirationTime &#x3D; NoWork;
  this.childExpirationTime &#x3D; NoWork;

  this.alternate &#x3D; null;

  if (enableProfilerTimer) &#123;
    this.actualDuration &#x3D; 0;
    this.actualStartTime &#x3D; -1;
    this.selfBaseDuration &#x3D; 0;
    this.treeBaseDuration &#x3D; 0;
  &#125;

  if (__DEV__) &#123;
    this._debugID &#x3D; debugCounter++;
    this._debugSource &#x3D; null;
    this._debugOwner &#x3D; null;
    this._debugIsCurrentlyTiming &#x3D; false;
    if (!hasBadMapPolyfill &amp;&amp; typeof Object.preventExtensions &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
      Object.preventExtensions(this);
    &#125;
  &#125;
&#125;</code></pre><p>由此可知，<code>react-dom</code>渲染模块调用<code>createContainer</code>创建容器、根fiber实例、FiberRoot对象等。所有<code>Fiber</code>对象都是<code>FiberNode</code>的实例，它有许多种类型，通过tag来标识，其中内部有很多方法来生成Fiber对象：</p><ul><li>createFiberFromElement：type为类，无状态函数，元素标签名</li><li>createFiberFromFragment：type为React.Fragment</li><li>createFiberFromText：在JSX中表现为字符串，数字</li><li>createFiberFromPortal：用于 createPortal</li><li>createFiberRoot：用于ReactDOM.render的根节点</li></ul><p>这里<code>createFiberRoot</code>就是创建了一个普通对象，里面<code>current</code>属性引用<code>fiber</code>对象，<code>containerInfo</code>属性引用<code>ReactDOM.render(&lt;div/&gt;, container)</code>的第二个参数，也就是一个元素节点，然后<code>fiber</code>对象的<code>stateNode</code>引用普通对象<code>root</code>。在React15中，<code>stateNode</code>应该是一个组件实例或真实DOM，最后返回普通对象<code>stateNode</code>。现在我们回顾下调用<code>reactDOM.render</code>传入的<code>container</code>，在执行过程中附加了哪些有用的东西：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">container &#x3D; &#123; &#x2F;&#x2F; 就是我们传入的那个真实dom
  _reactRootContainer: &#123; &#x2F;&#x2F; legacyCreateRootFromDOMContainer
    _internalRoot: &#123; &#x2F;&#x2F; DOMRenderer.createContainer
      current:&#123;&#125;  &#x2F;&#x2F; new FiberNode
    &#125;
  &#125;
&#125; </code></pre><h5 id="unbatchedUpdates"><a href="#unbatchedUpdates" class="headerlink" title="unbatchedUpdates"></a>unbatchedUpdates</h5><p>我们找到<code>DOMRenderer.unbatchedUpdates</code>，源码在<code>packages\react-reconciler\src\ReactFiberScheduler.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 正在批量更新标识
let isBatchingUpdates: boolean &#x3D; false;
&#x2F;&#x2F; 未批量更新标识
let isUnbatchingUpdates: boolean &#x3D; false;
&#x2F;&#x2F; 非批量更新操作
function unbatchedUpdates&lt;A, R&gt;(fn: (a: A) &#x3D;&gt; R, a: A): R &#123;
  &#x2F;&#x2F; 如果正在批量更新
  if (isBatchingUpdates &amp;&amp; !isUnbatchingUpdates) &#123;
    &#x2F;&#x2F; 未批量更新设为true
    isUnbatchingUpdates &#x3D; true;
    try &#123;
      &#x2F;&#x2F; 运行入参函数且返回执行结果
      return fn(a);
    &#125; finally &#123;
      &#x2F;&#x2F; 仍旧将未批量更新设为false
      isUnbatchingUpdates &#x3D; false;
    &#125;
  &#125;
  &#x2F;&#x2F; 不管是否在批量更新流程中，都执行入参函数
  return fn(a);
&#125;</code></pre><p>由此可知<code>unbatchedUpdates</code>无论如何都会执行入参函数，其中<code>isBatchingUpdates</code>和<code>isUnbatchingUpdates</code>初始值都是false。<code>DOMRenderer.unbatchedUpdates</code>的回调执行<code>root.legacy_renderSubtreeIntoContainer</code>或<code>root.render</code>。</p><h4 id="更新容器内容"><a href="#更新容器内容" class="headerlink" title="更新容器内容"></a>更新容器内容</h4><p>从<code>legacyRenderSubtreeIntoContainer</code>函数里可以看出，无论怎样判断，最终都会到<code>root.legacy_renderSubtreeIntoContainer</code>和<code>root.render</code>两个方法，而这两个方法的核心就是<code>DOMRenderer.updateContainer</code>，无非就是传不传父组件这点区别。我们找到<code>DOMRenderer.updateContainer</code>，源码在<code>packages\react-reconciler\src\ReactFiberReconciler.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function updateContainer(
  element: ReactNodeList, &#x2F;&#x2F; ReactDOM.render函数的第一个参数，泛指各种虚拟DOM
  container: OpaqueRoot, &#x2F;&#x2F; ReactDOM.render函数的第二个参数，也就是一个元素节点
  parentComponent: ?React$Component&lt;any, any&gt;, &#x2F;&#x2F; parentComponent为之前的根组件，现在它为null
  callback: ?Function, &#x2F;&#x2F; 回调函数
): ExpirationTime &#123;
  &#x2F;&#x2F; createFiberRoot中创建的fiber对象
  const current &#x3D; container.current;
  const currentTime &#x3D; requestCurrentTime();
  &#x2F;&#x2F; 获取任务到期时间
  const expirationTime &#x3D; computeExpirationForFiber(currentTime, current);
  return updateContainerAtExpirationTime(
    element, &#x2F;&#x2F; ReactDOM.render函数的第一个参数，泛指各种虚拟DOM
    container, &#x2F;&#x2F; ReactDOM.render函数的第二个参数，也就是一个元素节点
    parentComponent, &#x2F;&#x2F; 父组件
    expirationTime, &#x2F;&#x2F; 任务到期时间
    callback, &#x2F;&#x2F; 回调函数
  );
&#125;

&#x2F;&#x2F; 源码在 packages\react-reconciler\src\ReactFiberScheduler.js 中
&#x2F;&#x2F; 计算fiber的到期时间
function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123;
  let expirationTime;
  if (expirationContext !&#x3D;&#x3D; NoWork) &#123;
    &#x2F;&#x2F; 显示设置过期上下文
    expirationTime &#x3D; expirationContext;
  &#125; else if (isWorking) &#123;
    if (isCommitting) &#123;
      &#x2F;&#x2F; 在提交阶段的更新任务
      &#x2F;&#x2F; 需要明确设置同步优先级（Sync Priority）
      expirationTime &#x3D; Sync;
    &#125; else &#123;
      &#x2F;&#x2F; 在渲染阶段发生的更新任务
      &#x2F;&#x2F; 需要设置为下一次渲染时间的到期时间优先级
      expirationTime &#x3D; nextRenderExpirationTime;
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; 不在任务执行阶段，需要计算新的过期时间
    if (fiber.mode &amp; AsyncMode) &#123;
      if (isBatchingInteractiveUpdates) &#123;
        &#x2F;&#x2F; This is an interactive update
        expirationTime &#x3D; computeInteractiveExpiration(currentTime);
      &#125; else &#123;
        &#x2F;&#x2F; 异步更新
        expirationTime &#x3D; computeAsyncExpiration(currentTime);
      &#125;
      &#x2F;&#x2F; 如果我们正处于渲染树的中间, 请不要在已经呈现的相同过期时间内更新。
      if (nextRoot !&#x3D;&#x3D; null &amp;&amp; expirationTime &#x3D;&#x3D;&#x3D; nextRenderExpirationTime) &#123;
        expirationTime +&#x3D; 1;
      &#125;
    &#125; else &#123;
      &#x2F;&#x2F; 同步更新
      expirationTime &#x3D; Sync;
    &#125;
  &#125;
  if (isBatchingInteractiveUpdates) &#123;
    &#x2F;&#x2F; This is an interactive update. Keep track of the lowest pending
    &#x2F;&#x2F; interactive expiration time. This allows us to synchronously flush
    &#x2F;&#x2F; all interactive updates when needed.
    if (expirationTime &gt; lowestPriorityPendingInteractiveExpirationTime) &#123;
      lowestPriorityPendingInteractiveExpirationTime &#x3D; expirationTime;
    &#125;
  &#125;
  return expirationTime;
&#125;

&#x2F;&#x2F; 根据渲染优先级更新dom
export function updateContainerAtExpirationTime(
  element: ReactNodeList, &#x2F;&#x2F; ReactDOM.render函数的第一个参数，泛指各种虚拟DOM
  container: OpaqueRoot, &#x2F;&#x2F; ReactDOM.render函数的第二个参数，也就是一个元素节点
  parentComponent: ?React$Component&lt;any, any&gt;,   &#x2F;&#x2F; parentComponent为之前的根组件，现在它为null
  expirationTime: ExpirationTime, &#x2F;&#x2F; 期望的任务到期时间
  callback: ?Function, &#x2F;&#x2F; 回调函数
) &#123;
  &#x2F;&#x2F; TODO: If this is a nested container, this won&#39;t be the root.
  &#x2F;&#x2F; 引用fiber对象
  const current &#x3D; container.current;

  if (__DEV__) &#123;
    &#x2F;&#x2F; ...
  &#125;

  &#x2F;&#x2F; 获得上下文对象
  const context &#x3D; getContextForSubtree(parentComponent);
  if (container.context &#x3D;&#x3D;&#x3D; null) &#123;
    container.context &#x3D; context;
  &#125; else &#123;
    container.pendingContext &#x3D; context;
  &#125;
  &#x2F;&#x2F; 下一步：schedule:安排, Root: 根, Update:更新
  return scheduleRootUpdate(
    current, &#x2F;&#x2F; fiber对象
    element, &#x2F;&#x2F; ReactDOM.render函数的第一个参数，泛指各种虚拟DOM
    expirationTime, &#x2F;&#x2F; 期望的任务到期时间
    callback &#x2F;&#x2F; 回调函数
  );
&#125;

&#x2F;&#x2F; 源码在 packages\react-reconciler\src\ReactFiberReconciler.js 中
&#x2F;&#x2F; 获得上下文对象
function getContextForSubtree(
  parentComponent: ?React$Component&lt;any, any&gt;,
): Object &#123;
  if (!parentComponent) &#123;
    return emptyContextObject;
  &#125;

  const fiber &#x3D; ReactInstanceMap.get(parentComponent);
  const parentContext &#x3D; findCurrentUnmaskedContext(fiber);

  if (fiber.tag &#x3D;&#x3D;&#x3D; ClassComponent) &#123;
    const Component &#x3D; fiber.type;
    if (isLegacyContextProvider(Component)) &#123;
      return processChildContext(fiber, Component, parentContext);
    &#125;
  &#125; else if (fiber.tag &#x3D;&#x3D;&#x3D; ClassComponentLazy) &#123;
    const Component &#x3D; getResultFromResolvedThenable(fiber.type);
    if (isLegacyContextProvider(Component)) &#123;
      return processChildContext(fiber, Component, parentContext);
    &#125;
  &#125;

  return parentContext;
&#125;</code></pre><p><code>updateContainer</code>的源码很简单，通过<code>computeExpirationForFiber</code>获得计算优先级，然后丢给<code>updateContainerAtExpirationTime</code>，这里<code>updateContainerAtExpirationTime</code>其实相当于什么都没做，通过<code>getContextForSubtree</code>（这里<code>getContextForSubtree</code>因为一开始<code>parentComponent</code>是不存在的，于是返回一个空对象。注意，这个空对象可以重复使用，不用每次返回一个新的空对象，这是一个很好的优化）获得上下文对象，然后分配给<code>container.context</code>或<code>container.pendingContext</code>，最后一起丢给<code>scheduleRootUpdate</code>。</p><h4 id="开始更新"><a href="#开始更新" class="headerlink" title="开始更新"></a>开始更新</h4><p>我们找到<code>scheduleRootUpdate</code>，源码在<code>packages/react-reconciler/src/ReactFiberReconciler.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; 进行根节点更新
function scheduleRootUpdate(
  current: Fiber, &#x2F;&#x2F; 引用fiber对象
  element: ReactNodeList, &#x2F;&#x2F; 虚拟dom树
  expirationTime: ExpirationTime, &#x2F;&#x2F; 任务到期时间
  callback: ?Function, &#x2F;&#x2F; 回调函数
) &#123;
  if (__DEV__) &#123;
    &#x2F;&#x2F; ...
  &#125;
  
  &#x2F;&#x2F; 返回一个包含以上属性的update对象
  const update &#x3D; createUpdate(expirationTime);
  &#x2F;&#x2F; Caution: React DevTools currently depends on this property
  &#x2F;&#x2F; being called &quot;element&quot;.
  &#x2F;&#x2F; 将虚拟dom树放入payload 
  update.payload &#x3D; &#123;element&#125;;

  callback &#x3D; callback &#x3D;&#x3D;&#x3D; undefined ? null : callback;
  if (callback !&#x3D;&#x3D; null) &#123;
    warningWithoutStack(
      typeof callback &#x3D;&#x3D;&#x3D; &#39;function&#39;,
      &#39;render(...): Expected the last optional &#96;callback&#96; argument to be a &#39; +
        &#39;function. Instead received: %s.&#39;,
      callback,
    );
    update.callback &#x3D; callback;
  &#125;
  &#x2F;&#x2F; 开始队列更新
  enqueueUpdate(current, update); 
  &#x2F;&#x2F; 调用调度器API：scheduleWork(...)来调度fiber任务
  scheduleWork(
    current, &#x2F;&#x2F; fiber实例
    expirationTime &#x2F;&#x2F; 任务到期时间
  );
  return expirationTime;
&#125;

&#x2F;&#x2F; 创建一个包含以上属性的update对象
export function createUpdate(expirationTime: ExpirationTime): Update&lt;*&gt; &#123;
  return &#123;
    expirationTime: expirationTime,

    tag: UpdateState,
    payload: null,
    callback: null,

    next: null,
    nextEffect: null,
  &#125;;
&#125;</code></pre><p><code>scheduleRootUpdate</code>是将用户的传参封装成一个<code>update</code>对象, 其中<code>update</code>对象有<code>payload</code>对象，它就是相当于React15中 的setState的第一个state传参，但现在<code>payload</code>中把<code>children</code>也放进去了。然后添加更新任务至fiber：<code>enqueueUpdate(...)</code>，现在我们找到<code>enqueueUpdate</code>，源码在<code>packages/react-reconciler/src/ReactUpdateQueue.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function enqueueUpdate&lt;State&gt;(fiber: Fiber, update: Update&lt;State&gt;) &#123;
  &#x2F;&#x2F; alternate 主要用来保存更新过程中各版本更新队列，方便崩溃或冲突时回退
  const alternate &#x3D; fiber.alternate;
  &#x2F;&#x2F; 创建两个独立的更新队列
  let queue1;
  let queue2;
  if (alternate &#x3D;&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; 只存在一个 fiber
    queue1 &#x3D; fiber.updateQueue;
    queue2 &#x3D; null;
    if (queue1 &#x3D;&#x3D;&#x3D; null) &#123;
      &#x2F;&#x2F; 如果不存在，则创建一个更新队列
      queue1 &#x3D; fiber.updateQueue &#x3D; createUpdateQueue(fiber.memoizedState);
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; 两个所有者
    queue1 &#x3D; fiber.updateQueue;
    queue2 &#x3D; alternate.updateQueue;
    if (queue1 &#x3D;&#x3D;&#x3D; null) &#123;
      if (queue2 &#x3D;&#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; 如果两个都不存在，则创建两个新的
        queue1 &#x3D; fiber.updateQueue &#x3D; createUpdateQueue(fiber.memoizedState);
        queue2 &#x3D; alternate.updateQueue &#x3D; createUpdateQueue(
          alternate.memoizedState,
        );
      &#125; else &#123;
        &#x2F;&#x2F; queue1 不存在，queue2 存在，queue1 根据 queue2 创建
        queue1 &#x3D; fiber.updateQueue &#x3D; cloneUpdateQueue(queue2);
      &#125;
    &#125; else &#123;
      if (queue2 &#x3D;&#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; queue2 不存在，queue1 存在，queue2 根据 queue1 创建
        queue2 &#x3D; alternate.updateQueue &#x3D; cloneUpdateQueue(queue1);
      &#125; else &#123;
        &#x2F;&#x2F; 全都有
      &#125;
    &#125;
  &#125;
  if (queue2 &#x3D;&#x3D;&#x3D; null || queue1 &#x3D;&#x3D;&#x3D; queue2) &#123;
    &#x2F;&#x2F; 只存在一个更新队列
    appendUpdateToQueue(queue1, update);
  &#125; else &#123;
    &#x2F;&#x2F; 如果任意更新队列为空，则需要将更新添加至两个更新队列
    if (queue1.lastUpdate &#x3D;&#x3D;&#x3D; null || queue2.lastUpdate &#x3D;&#x3D;&#x3D; null) &#123;
      appendUpdateToQueue(queue1, update);
      appendUpdateToQueue(queue2, update);
    &#125; else &#123;
      &#x2F;&#x2F; 如果2个更新队列均非空，则添加更新至第一个队列，并更新另一个队列的尾部更新项
      appendUpdateToQueue(queue1, update);
      queue2.lastUpdate &#x3D; update;
    &#125;
  &#125;

  if (__DEV__) &#123;
    if (
      (fiber.tag &#x3D;&#x3D;&#x3D; ClassComponent || fiber.tag &#x3D;&#x3D;&#x3D; ClassComponentLazy) &amp;&amp;
      (currentlyProcessingQueue &#x3D;&#x3D;&#x3D; queue1 ||
        (queue2 !&#x3D;&#x3D; null &amp;&amp; currentlyProcessingQueue &#x3D;&#x3D;&#x3D; queue2)) &amp;&amp;
      !didWarnUpdateInsideUpdate
    ) &#123;
      warningWithoutStack(
        false,
        &#39;An update (setState, replaceState, or forceUpdate) was scheduled &#39; +
          &#39;from inside an update function. Update functions should be pure, &#39; +
          &#39;with zero side-effects. Consider using componentDidUpdate or a &#39; +
          &#39;callback.&#39;,
      );
      didWarnUpdateInsideUpdate &#x3D; true;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 创建一个更新队列
export function createUpdateQueue&lt;State&gt;(baseState: State): UpdateQueue&lt;State&gt; &#123;
  const queue: UpdateQueue&lt;State&gt; &#x3D; &#123;
    baseState,
    firstUpdate: null,
    lastUpdate: null,
    firstCapturedUpdate: null,
    lastCapturedUpdate: null,
    firstEffect: null,
    lastEffect: null,
    firstCapturedEffect: null,
    lastCapturedEffect: null,
  &#125;;
  return queue;
&#125;

&#x2F;&#x2F; clone 一个更新队列
function cloneUpdateQueue&lt;State&gt;(
  currentQueue: UpdateQueue&lt;State&gt;,
): UpdateQueue&lt;State&gt; &#123;
  const queue: UpdateQueue&lt;State&gt; &#x3D; &#123;
    baseState: currentQueue.baseState,
    firstUpdate: currentQueue.firstUpdate,
    lastUpdate: currentQueue.lastUpdate,

    &#x2F;&#x2F; TODO: With resuming, if we bail out and resuse the child tree, we should
    &#x2F;&#x2F; keep these effects.
    firstCapturedUpdate: null,
    lastCapturedUpdate: null,

    firstEffect: null,
    lastEffect: null,

    firstCapturedEffect: null,
    lastCapturedEffect: null,
  &#125;;
  return queue;
&#125;

&#x2F;&#x2F; 更新队列
function appendUpdateToQueue&lt;State&gt;(
  queue: UpdateQueue&lt;State&gt;,
  update: Update&lt;State&gt;,
) &#123;
  &#x2F;&#x2F; Append the update to the end of the list.
  if (queue.lastUpdate &#x3D;&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; Queue is empty
    queue.firstUpdate &#x3D; queue.lastUpdate &#x3D; update;
  &#125; else &#123;
    queue.lastUpdate.next &#x3D; update;
    queue.lastUpdate &#x3D; update;
  &#125;
&#125;</code></pre><p>这里<code>enqueueUpdate</code>是一个链表，然后根据<code>fiber</code>的状态创建一个或两个列队对象，再接下来调用调度器API：<code>scheduleWork(...)</code>来调度fiber任务，现在我们看一下如何处理更新的。</p><h4 id="处理更新"><a href="#处理更新" class="headerlink" title="处理更新"></a>处理更新</h4><p>我们找到<code>scheduleWork</code>，源码在<code>packages/react-reconciler/src/ReactFiberScheduler.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function scheduleWork(fiber: Fiber, expirationTime: ExpirationTime) &#123;
  &#x2F;&#x2F; 记录调度器的执行状态
  recordScheduleUpdate();

  if (__DEV__) &#123;
    if (fiber.tag &#x3D;&#x3D;&#x3D; ClassComponent || fiber.tag &#x3D;&#x3D;&#x3D; ClassComponentLazy) &#123;
      const instance &#x3D; fiber.stateNode;
      warnAboutInvalidUpdates(instance);
    &#125;
  &#125;

  const root &#x3D; scheduleWorkToRoot(fiber, expirationTime);
  if (root &#x3D;&#x3D;&#x3D; null) &#123;
    if (
      __DEV__ &amp;&amp;
      (fiber.tag &#x3D;&#x3D;&#x3D; ClassComponent || fiber.tag &#x3D;&#x3D;&#x3D; ClassComponentLazy)
    ) &#123;
      warnAboutUpdateOnUnmounted(fiber);
    &#125;
    return;
  &#125;

  if (enableSchedulerTracing) &#123;
    const interactions &#x3D; __interactionsRef.current;
    if (interactions.size &gt; 0) &#123;
      const pendingInteractionMap &#x3D; root.pendingInteractionMap;
      const pendingInteractions &#x3D; pendingInteractionMap.get(expirationTime);
      if (pendingInteractions !&#x3D; null) &#123;
        interactions.forEach(interaction &#x3D;&gt; &#123;
          if (!pendingInteractions.has(interaction)) &#123;
            &#x2F;&#x2F; Update the pending async work count for previously unscheduled interaction.
            interaction.__count++;
          &#125;

          pendingInteractions.add(interaction);
        &#125;);
      &#125; else &#123;
        pendingInteractionMap.set(expirationTime, new Set(interactions));

        &#x2F;&#x2F; Update the pending async work count for the current interactions.
        interactions.forEach(interaction &#x3D;&gt; &#123;
          interaction.__count++;
        &#125;);
      &#125;

      const subscriber &#x3D; __subscriberRef.current;
      if (subscriber !&#x3D;&#x3D; null) &#123;
        const threadID &#x3D; computeThreadID(
          expirationTime,
          root.interactionThreadID,
        );
        subscriber.onWorkScheduled(interactions, threadID);
      &#125;
    &#125;
  &#125;

  if (
    !isWorking &amp;&amp;
    nextRenderExpirationTime !&#x3D;&#x3D; NoWork &amp;&amp;
    expirationTime &lt; nextRenderExpirationTime
  ) &#123;
    &#x2F;&#x2F; This is an interruption. (Used for performance tracking.)
    interruptedBy &#x3D; fiber;
    resetStack();
  &#125;
  markPendingPriorityLevel(root, expirationTime);
  if (
    &#x2F;&#x2F; If we&#39;re in the render phase, we don&#39;t need to schedule this root
    &#x2F;&#x2F; for an update, because we&#39;ll do it before we exit...
    !isWorking ||
    isCommitting ||
    &#x2F;&#x2F; ...unless this is a different root than the one we&#39;re rendering.
    nextRoot !&#x3D;&#x3D; root
  ) &#123;
    const rootExpirationTime &#x3D; root.expirationTime;
    requestWork(root, rootExpirationTime);
  &#125;
  if (nestedUpdateCount &gt; NESTED_UPDATE_LIMIT) &#123;
    &#x2F;&#x2F; Reset this back to zero so subsequent updates don&#39;t throw.
    nestedUpdateCount &#x3D; 0;
    invariant(
      false,
      &#39;Maximum update depth exceeded. This can happen when a &#39; +
        &#39;component repeatedly calls setState inside &#39; +
        &#39;componentWillUpdate or componentDidUpdate. React limits &#39; +
        &#39;the number of nested updates to prevent infinite loops.&#39;,
    );
  &#125;
&#125;

function scheduleWorkToRoot(fiber: Fiber, expirationTime): FiberRoot | null &#123;
  &#x2F;&#x2F; 更新 fiber实例的过期时间
  if (
    fiber.expirationTime &#x3D;&#x3D;&#x3D; NoWork ||
    fiber.expirationTime &gt; expirationTime
  ) &#123;
    &#x2F;&#x2F; 若fiber实例到期时间大于期望的任务到期时间，则更新fiber到期时间
    fiber.expirationTime &#x3D; expirationTime;
  &#125;
  let alternate &#x3D; fiber.alternate;
  &#x2F;&#x2F; 同时更新alternate fiber的到期时间
  if (
    alternate !&#x3D;&#x3D; null &amp;&amp;
    (alternate.expirationTime &#x3D;&#x3D;&#x3D; NoWork ||
      alternate.expirationTime &gt; expirationTime)
  ) &#123;
    &#x2F;&#x2F; 若alternate fiber到期时间大于期望的任务到期时间，则更新fiber到期时间
    alternate.expirationTime &#x3D; expirationTime;
  &#125;
  let node &#x3D; fiber.return;
  &#x2F;&#x2F; fiber.return 为空，说明到达组件树顶部
  if (node &#x3D;&#x3D;&#x3D; null &amp;&amp; fiber.tag &#x3D;&#x3D;&#x3D; HostRoot) &#123;
    &#x2F;&#x2F; 确保是组件树根组件并获取FiberRoot实例
    return fiber.stateNode;
  &#125;
  while (node !&#x3D;&#x3D; null) &#123;
    alternate &#x3D; node.alternate;
    if (
      node.childExpirationTime &#x3D;&#x3D;&#x3D; NoWork ||
      node.childExpirationTime &gt; expirationTime
    ) &#123;
      node.childExpirationTime &#x3D; expirationTime;
      if (
        alternate !&#x3D;&#x3D; null &amp;&amp;
        (alternate.childExpirationTime &#x3D;&#x3D;&#x3D; NoWork ||
          alternate.childExpirationTime &gt; expirationTime)
      ) &#123;
        alternate.childExpirationTime &#x3D; expirationTime;
      &#125;
    &#125; else if (
      alternate !&#x3D;&#x3D; null &amp;&amp;
      (alternate.childExpirationTime &#x3D;&#x3D;&#x3D; NoWork ||
        alternate.childExpirationTime &gt; expirationTime)
    ) &#123;
      alternate.childExpirationTime &#x3D; expirationTime;
    &#125;
    if (node.return &#x3D;&#x3D;&#x3D; null &amp;&amp; node.tag &#x3D;&#x3D;&#x3D; HostRoot) &#123;
      return node.stateNode;
    &#125;
    node &#x3D; node.return;
  &#125;
  return null;
&#125;</code></pre><p>这里<code>scheduleWork</code>主要进行虚拟DOM（fiber树）的更新。<code>scheduleWork</code>的最开头有一个<code>recordScheduleUpdate</code>方法，我们找到<code>recordScheduleUpdate</code>，源码在<code>packages\react-reconciler\src\ReactDebugFiberPerf.js</code>中：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export function recordScheduleUpdate(): void &#123;
  if (enableUserTimingAPI) &#123; &#x2F;&#x2F; 全局变量，默认为true
    if (isCommitting) &#123; &#x2F;&#x2F; 全局变量，默认为false, 没有进入分支
      hasScheduledUpdateInCurrentCommit &#x3D; true;
    &#125;
    &#x2F;&#x2F; 全局变量，默认为null，没有没有进入分支
    if (
      currentPhase !&#x3D;&#x3D; null &amp;&amp;
      currentPhase !&#x3D;&#x3D; &#39;componentWillMount&#39; &amp;&amp;
      currentPhase !&#x3D;&#x3D; &#39;componentWillReceiveProps&#39;
    ) &#123;
      hasScheduledUpdateInCurrentPhase &#x3D; true;
    &#125;
  &#125;
&#125;</code></pre><p><code>recordScheduleUpdate</code>主要用来记录调度器的执行状态，如注释所示，它现在相当于什么都没有做。</p><h5 id="requestWork"><a href="#requestWork" class="headerlink" title="requestWork"></a>requestWork</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function requestWork(root: FiberRoot, expirationTime: ExpirationTime) &#123;
  addRootToSchedule(root, expirationTime);
  if (isRendering) &#123;
    &#x2F;&#x2F; Prevent reentrancy. Remaining work will be scheduled at the end of
    &#x2F;&#x2F; the currently rendering batch.
    return;
  &#125;

  if (isBatchingUpdates) &#123;
    &#x2F;&#x2F; Flush work at the end of the batch.
    if (isUnbatchingUpdates) &#123;
      &#x2F;&#x2F; ...unless we&#39;re inside unbatchedUpdates, in which case we should
      &#x2F;&#x2F; flush it now.
      nextFlushedRoot &#x3D; root;
      nextFlushedExpirationTime &#x3D; Sync;
      performWorkOnRoot(root, Sync, true);
    &#125;
    return;
  &#125;

  &#x2F;&#x2F; TODO: Get rid of Sync and use current time?
  if (expirationTime &#x3D;&#x3D;&#x3D; Sync) &#123;
    performSyncWork();
  &#125; else &#123;
    scheduleCallbackWithExpirationTime(root, expirationTime);
  &#125;
&#125;</code></pre><h5 id="performWork"><a href="#performWork" class="headerlink" title="performWork"></a>performWork</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function performWork(minExpirationTime: ExpirationTime, dl: Deadline | null) &#123;
  deadline &#x3D; dl;

  &#x2F;&#x2F; Keep working on roots until there&#39;s no more work, or until we reach
  &#x2F;&#x2F; the deadline.
  findHighestPriorityRoot();

  if (deadline !&#x3D;&#x3D; null) &#123;
    recomputeCurrentRendererTime();
    currentSchedulerTime &#x3D; currentRendererTime;

    if (enableUserTimingAPI) &#123;
      const didExpire &#x3D; nextFlushedExpirationTime &lt; currentRendererTime;
      const timeout &#x3D; expirationTimeToMs(nextFlushedExpirationTime);
      stopRequestCallbackTimer(didExpire, timeout);
    &#125;

    while (
      nextFlushedRoot !&#x3D;&#x3D; null &amp;&amp;
      nextFlushedExpirationTime !&#x3D;&#x3D; NoWork &amp;&amp;
      (minExpirationTime &#x3D;&#x3D;&#x3D; NoWork ||
        minExpirationTime &gt;&#x3D; nextFlushedExpirationTime) &amp;&amp;
      (!deadlineDidExpire || currentRendererTime &gt;&#x3D; nextFlushedExpirationTime)
    ) &#123;
      performWorkOnRoot(
        nextFlushedRoot,
        nextFlushedExpirationTime,
        currentRendererTime &gt;&#x3D; nextFlushedExpirationTime,
      );
      findHighestPriorityRoot();
      recomputeCurrentRendererTime();
      currentSchedulerTime &#x3D; currentRendererTime;
    &#125;
  &#125; else &#123;
    while (
      nextFlushedRoot !&#x3D;&#x3D; null &amp;&amp;
      nextFlushedExpirationTime !&#x3D;&#x3D; NoWork &amp;&amp;
      (minExpirationTime &#x3D;&#x3D;&#x3D; NoWork ||
        minExpirationTime &gt;&#x3D; nextFlushedExpirationTime)
    ) &#123;
      performWorkOnRoot(nextFlushedRoot, nextFlushedExpirationTime, true);
      findHighestPriorityRoot();
    &#125;
  &#125;

  &#x2F;&#x2F; We&#39;re done flushing work. Either we ran out of time in this callback,
  &#x2F;&#x2F; or there&#39;s no more work left with sufficient priority.

  &#x2F;&#x2F; If we&#39;re inside a callback, set this to false since we just completed it.
  if (deadline !&#x3D;&#x3D; null) &#123;
    callbackExpirationTime &#x3D; NoWork;
    callbackID &#x3D; null;
  &#125;
  &#x2F;&#x2F; If there&#39;s work left over, schedule a new callback.
  if (nextFlushedExpirationTime !&#x3D;&#x3D; NoWork) &#123;
    scheduleCallbackWithExpirationTime(
      ((nextFlushedRoot: any): FiberRoot),
      nextFlushedExpirationTime,
    );
  &#125;

  &#x2F;&#x2F; Clean-up.
  deadline &#x3D; null;
  deadlineDidExpire &#x3D; false;

  finishRendering();
&#125;</code></pre><h5 id="performWorkOnRoot"><a href="#performWorkOnRoot" class="headerlink" title="performWorkOnRoot"></a>performWorkOnRoot</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function performWorkOnRoot(
  root: FiberRoot,
  expirationTime: ExpirationTime,
  isExpired: boolean,
) &#123;
  invariant(
    !isRendering,
    &#39;performWorkOnRoot was called recursively. This error is likely caused &#39; +
      &#39;by a bug in React. Please file an issue.&#39;,
  );

  isRendering &#x3D; true;

  &#x2F;&#x2F; Check if this is async work or sync&#x2F;expired work.
  if (deadline &#x3D;&#x3D;&#x3D; null || isExpired) &#123;
    &#x2F;&#x2F; Flush work without yielding.
    &#x2F;&#x2F; TODO: Non-yieldy work does not necessarily imply expired work. A renderer
    &#x2F;&#x2F; may want to perform some work without yielding, but also without
    &#x2F;&#x2F; requiring the root to complete (by triggering placeholders).

    let finishedWork &#x3D; root.finishedWork;
    if (finishedWork !&#x3D;&#x3D; null) &#123;
      &#x2F;&#x2F; This root is already complete. We can commit it.
      completeRoot(root, finishedWork, expirationTime);
    &#125; else &#123;
      root.finishedWork &#x3D; null;
      &#x2F;&#x2F; If this root previously suspended, clear its existing timeout, since
      &#x2F;&#x2F; we&#39;re about to try rendering again.
      const timeoutHandle &#x3D; root.timeoutHandle;
      if (enableSuspense &amp;&amp; timeoutHandle !&#x3D;&#x3D; noTimeout) &#123;
        root.timeoutHandle &#x3D; noTimeout;
        &#x2F;&#x2F; $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        cancelTimeout(timeoutHandle);
      &#125;
      const isYieldy &#x3D; false;
      renderRoot(root, isYieldy, isExpired);
      finishedWork &#x3D; root.finishedWork;
      if (finishedWork !&#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; We&#39;ve completed the root. Commit it.
        completeRoot(root, finishedWork, expirationTime);
      &#125;
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; Flush async work.
    let finishedWork &#x3D; root.finishedWork;
    if (finishedWork !&#x3D;&#x3D; null) &#123;
      &#x2F;&#x2F; This root is already complete. We can commit it.
      completeRoot(root, finishedWork, expirationTime);
    &#125; else &#123;
      root.finishedWork &#x3D; null;
      &#x2F;&#x2F; If this root previously suspended, clear its existing timeout, since
      &#x2F;&#x2F; we&#39;re about to try rendering again.
      const timeoutHandle &#x3D; root.timeoutHandle;
      if (enableSuspense &amp;&amp; timeoutHandle !&#x3D;&#x3D; noTimeout) &#123;
        root.timeoutHandle &#x3D; noTimeout;
        &#x2F;&#x2F; $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above
        cancelTimeout(timeoutHandle);
      &#125;
      const isYieldy &#x3D; true;
      renderRoot(root, isYieldy, isExpired);
      finishedWork &#x3D; root.finishedWork;
      if (finishedWork !&#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; We&#39;ve completed the root. Check the deadline one more time
        &#x2F;&#x2F; before committing.
        if (!shouldYield()) &#123;
          &#x2F;&#x2F; Still time left. Commit the root.
          completeRoot(root, finishedWork, expirationTime);
        &#125; else &#123;
          &#x2F;&#x2F; There&#39;s no time left. Mark this root as complete. We&#39;ll come
          &#x2F;&#x2F; back and commit it later.
          root.finishedWork &#x3D; finishedWork;
        &#125;
      &#125;
    &#125;
  &#125;

  isRendering &#x3D; false;
&#125;</code></pre><h5 id="renderRoot"><a href="#renderRoot" class="headerlink" title="renderRoot"></a>renderRoot</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function renderRoot(
  root: FiberRoot,
  isYieldy: boolean,
  isExpired: boolean,
): void &#123;
  invariant(
    !isWorking,
    &#39;renderRoot was called recursively. This error is likely caused &#39; +
      &#39;by a bug in React. Please file an issue.&#39;,
  );
  isWorking &#x3D; true;
  ReactCurrentOwner.currentDispatcher &#x3D; Dispatcher;

  const expirationTime &#x3D; root.nextExpirationTimeToWorkOn;

  &#x2F;&#x2F; Check if we&#39;re starting from a fresh stack, or if we&#39;re resuming from
  &#x2F;&#x2F; previously yielded work.
  if (
    expirationTime !&#x3D;&#x3D; nextRenderExpirationTime ||
    root !&#x3D;&#x3D; nextRoot ||
    nextUnitOfWork &#x3D;&#x3D;&#x3D; null
  ) &#123;
    &#x2F;&#x2F; Reset the stack and start working from the root.
    resetStack();
    nextRoot &#x3D; root;
    nextRenderExpirationTime &#x3D; expirationTime;
    nextUnitOfWork &#x3D; createWorkInProgress(
      nextRoot.current,
      null,
      nextRenderExpirationTime,
    );
    root.pendingCommitExpirationTime &#x3D; NoWork;

    if (enableSchedulerTracing) &#123;
      &#x2F;&#x2F; Reset this flag once we start rendering a new root or at a new priority.
      &#x2F;&#x2F; This might indicate that suspended work has completed.
      &#x2F;&#x2F; If not, the flag will be reset.
      nextRenderIncludesTimedOutPlaceholder &#x3D; false;

      &#x2F;&#x2F; Determine which interactions this batch of work currently includes,
      &#x2F;&#x2F; So that we can accurately attribute time spent working on it,
      &#x2F;&#x2F; And so that cascading work triggered during the render phase will be associated with it.
      const interactions: Set&lt;Interaction&gt; &#x3D; new Set();
      root.pendingInteractionMap.forEach(
        (scheduledInteractions, scheduledExpirationTime) &#x3D;&gt; &#123;
          if (scheduledExpirationTime &lt;&#x3D; expirationTime) &#123;
            scheduledInteractions.forEach(interaction &#x3D;&gt;
              interactions.add(interaction),
            );
          &#125;
        &#125;,
      );

      &#x2F;&#x2F; Store the current set of interactions on the FiberRoot for a few reasons:
      &#x2F;&#x2F; We can re-use it in hot functions like renderRoot() without having to recalculate it.
      &#x2F;&#x2F; We will also use it in commitWork() to pass to any Profiler onRender() hooks.
      &#x2F;&#x2F; This also provides DevTools with a way to access it when the onCommitRoot() hook is called.
      root.memoizedInteractions &#x3D; interactions;

      if (interactions.size &gt; 0) &#123;
        const subscriber &#x3D; __subscriberRef.current;
        if (subscriber !&#x3D;&#x3D; null) &#123;
          const threadID &#x3D; computeThreadID(
            expirationTime,
            root.interactionThreadID,
          );
          try &#123;
            subscriber.onWorkStarted(interactions, threadID);
          &#125; catch (error) &#123;
            &#x2F;&#x2F; Work thrown by an interaction tracing subscriber should be rethrown,
            &#x2F;&#x2F; But only once it&#39;s safe (to avoid leaveing the scheduler in an invalid state).
            &#x2F;&#x2F; Store the error for now and we&#39;ll re-throw in finishRendering().
            if (!hasUnhandledError) &#123;
              hasUnhandledError &#x3D; true;
              unhandledError &#x3D; error;
            &#125;
          &#125;
        &#125;
      &#125;
    &#125;
  &#125;

  let prevInteractions: Set&lt;Interaction&gt; &#x3D; (null: any);
  if (enableSchedulerTracing) &#123;
    &#x2F;&#x2F; We&#39;re about to start new traced work.
    &#x2F;&#x2F; Restore pending interactions so cascading work triggered during the render phase will be accounted for.
    prevInteractions &#x3D; __interactionsRef.current;
    __interactionsRef.current &#x3D; root.memoizedInteractions;
  &#125;

  let didFatal &#x3D; false;

  startWorkLoopTimer(nextUnitOfWork);

  do &#123;
    try &#123;
      workLoop(isYieldy);
    &#125; catch (thrownValue) &#123;
      if (nextUnitOfWork &#x3D;&#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; This is a fatal error.
        didFatal &#x3D; true;
        onUncaughtError(thrownValue);
      &#125; else &#123;
        if (__DEV__) &#123;
          &#x2F;&#x2F; Reset global debug state
          &#x2F;&#x2F; We assume this is defined in DEV
          (resetCurrentlyProcessingQueue: any)();
        &#125;

        const failedUnitOfWork: Fiber &#x3D; nextUnitOfWork;
        if (__DEV__ &amp;&amp; replayFailedUnitOfWorkWithInvokeGuardedCallback) &#123;
          replayUnitOfWork(failedUnitOfWork, thrownValue, isYieldy);
        &#125;

        &#x2F;&#x2F; TODO: we already know this isn&#39;t true in some cases.
        &#x2F;&#x2F; At least this shows a nicer error message until we figure out the cause.
        &#x2F;&#x2F; https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;issues&#x2F;12449#issuecomment-386727431
        invariant(
          nextUnitOfWork !&#x3D;&#x3D; null,
          &#39;Failed to replay rendering after an error. This &#39; +
            &#39;is likely caused by a bug in React. Please file an issue &#39; +
            &#39;with a reproducing case to help us find it.&#39;,
        );

        const sourceFiber: Fiber &#x3D; nextUnitOfWork;
        let returnFiber &#x3D; sourceFiber.return;
        if (returnFiber &#x3D;&#x3D;&#x3D; null) &#123;
          &#x2F;&#x2F; This is the root. The root could capture its own errors. However,
          &#x2F;&#x2F; we don&#39;t know if it errors before or after we pushed the host
          &#x2F;&#x2F; context. This information is needed to avoid a stack mismatch.
          &#x2F;&#x2F; Because we&#39;re not sure, treat this as a fatal error. We could track
          &#x2F;&#x2F; which phase it fails in, but doesn&#39;t seem worth it. At least
          &#x2F;&#x2F; for now.
          didFatal &#x3D; true;
          onUncaughtError(thrownValue);
        &#125; else &#123;
          throwException(
            root,
            returnFiber,
            sourceFiber,
            thrownValue,
            nextRenderExpirationTime,
          );
          nextUnitOfWork &#x3D; completeUnitOfWork(sourceFiber);
          continue;
        &#125;
      &#125;
    &#125;
    break;
  &#125; while (true);

  if (enableSchedulerTracing) &#123;
    &#x2F;&#x2F; Traced work is done for now; restore the previous interactions.
    __interactionsRef.current &#x3D; prevInteractions;
  &#125;

  &#x2F;&#x2F; We&#39;re done performing work. Time to clean up.
  isWorking &#x3D; false;
  ReactCurrentOwner.currentDispatcher &#x3D; null;
  resetContextDependences();

  &#x2F;&#x2F; Yield back to main thread.
  if (didFatal) &#123;
    const didCompleteRoot &#x3D; false;
    stopWorkLoopTimer(interruptedBy, didCompleteRoot);
    interruptedBy &#x3D; null;
    &#x2F;&#x2F; There was a fatal error.
    if (__DEV__) &#123;
      resetStackAfterFatalErrorInDev();
    &#125;
    &#x2F;&#x2F; &#96;nextRoot&#96; points to the in-progress root. A non-null value indicates
    &#x2F;&#x2F; that we&#39;re in the middle of an async render. Set it to null to indicate
    &#x2F;&#x2F; there&#39;s no more work to be done in the current batch.
    nextRoot &#x3D; null;
    onFatal(root);
    return;
  &#125;

  if (nextUnitOfWork !&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; There&#39;s still remaining async work in this tree, but we ran out of time
    &#x2F;&#x2F; in the current frame. Yield back to the renderer. Unless we&#39;re
    &#x2F;&#x2F; interrupted by a higher priority update, we&#39;ll continue later from where
    &#x2F;&#x2F; we left off.
    const didCompleteRoot &#x3D; false;
    stopWorkLoopTimer(interruptedBy, didCompleteRoot);
    interruptedBy &#x3D; null;
    onYield(root);
    return;
  &#125;

  &#x2F;&#x2F; We completed the whole tree.
  const didCompleteRoot &#x3D; true;
  stopWorkLoopTimer(interruptedBy, didCompleteRoot);
  const rootWorkInProgress &#x3D; root.current.alternate;
  invariant(
    rootWorkInProgress !&#x3D;&#x3D; null,
    &#39;Finished root should have a work-in-progress. This error is likely &#39; +
      &#39;caused by a bug in React. Please file an issue.&#39;,
  );

  &#x2F;&#x2F; &#96;nextRoot&#96; points to the in-progress root. A non-null value indicates
  &#x2F;&#x2F; that we&#39;re in the middle of an async render. Set it to null to indicate
  &#x2F;&#x2F; there&#39;s no more work to be done in the current batch.
  nextRoot &#x3D; null;
  interruptedBy &#x3D; null;

  if (nextRenderDidError) &#123;
    &#x2F;&#x2F; There was an error
    if (hasLowerPriorityWork(root, expirationTime)) &#123;
      &#x2F;&#x2F; There&#39;s lower priority work. If so, it may have the effect of fixing
      &#x2F;&#x2F; the exception that was just thrown. Exit without committing. This is
      &#x2F;&#x2F; similar to a suspend, but without a timeout because we&#39;re not waiting
      &#x2F;&#x2F; for a promise to resolve. React will restart at the lower
      &#x2F;&#x2F; priority level.
      markSuspendedPriorityLevel(root, expirationTime);
      const suspendedExpirationTime &#x3D; expirationTime;
      const rootExpirationTime &#x3D; root.expirationTime;
      onSuspend(
        root,
        rootWorkInProgress,
        suspendedExpirationTime,
        rootExpirationTime,
        -1, &#x2F;&#x2F; Indicates no timeout
      );
      return;
    &#125; else if (
      &#x2F;&#x2F; There&#39;s no lower priority work, but we&#39;re rendering asynchronously.
      &#x2F;&#x2F; Synchronsouly attempt to render the same level one more time. This is
      &#x2F;&#x2F; similar to a suspend, but without a timeout because we&#39;re not waiting
      &#x2F;&#x2F; for a promise to resolve.
      !root.didError &amp;&amp;
      !isExpired
    ) &#123;
      root.didError &#x3D; true;
      const suspendedExpirationTime &#x3D; (root.nextExpirationTimeToWorkOn &#x3D; expirationTime);
      const rootExpirationTime &#x3D; (root.expirationTime &#x3D; Sync);
      onSuspend(
        root,
        rootWorkInProgress,
        suspendedExpirationTime,
        rootExpirationTime,
        -1, &#x2F;&#x2F; Indicates no timeout
      );
      return;
    &#125;
  &#125;

  if (enableSuspense &amp;&amp; !isExpired &amp;&amp; nextLatestAbsoluteTimeoutMs !&#x3D;&#x3D; -1) &#123;
    &#x2F;&#x2F; The tree was suspended.
    if (enableSchedulerTracing) &#123;
      nextRenderIncludesTimedOutPlaceholder &#x3D; true;
    &#125;
    const suspendedExpirationTime &#x3D; expirationTime;
    markSuspendedPriorityLevel(root, suspendedExpirationTime);

    &#x2F;&#x2F; Find the earliest uncommitted expiration time in the tree, including
    &#x2F;&#x2F; work that is suspended. The timeout threshold cannot be longer than
    &#x2F;&#x2F; the overall expiration.
    const earliestExpirationTime &#x3D; findEarliestOutstandingPriorityLevel(
      root,
      expirationTime,
    );
    const earliestExpirationTimeMs &#x3D; expirationTimeToMs(earliestExpirationTime);
    if (earliestExpirationTimeMs &lt; nextLatestAbsoluteTimeoutMs) &#123;
      nextLatestAbsoluteTimeoutMs &#x3D; earliestExpirationTimeMs;
    &#125;

    &#x2F;&#x2F; Subtract the current time from the absolute timeout to get the number
    &#x2F;&#x2F; of milliseconds until the timeout. In other words, convert an absolute
    &#x2F;&#x2F; timestamp to a relative time. This is the value that is passed
    &#x2F;&#x2F; to &#96;setTimeout&#96;.
    const currentTimeMs &#x3D; expirationTimeToMs(requestCurrentTime());
    let msUntilTimeout &#x3D; nextLatestAbsoluteTimeoutMs - currentTimeMs;
    msUntilTimeout &#x3D; msUntilTimeout &lt; 0 ? 0 : msUntilTimeout;

    &#x2F;&#x2F; TODO: Account for the Just Noticeable Difference

    const rootExpirationTime &#x3D; root.expirationTime;
    onSuspend(
      root,
      rootWorkInProgress,
      suspendedExpirationTime,
      rootExpirationTime,
      msUntilTimeout,
    );
    return;
  &#125;

  &#x2F;&#x2F; Ready to commit.
  onComplete(root, rootWorkInProgress, expirationTime);
&#125;</code></pre><h5 id="completeRoot"><a href="#completeRoot" class="headerlink" title="completeRoot"></a>completeRoot</h5><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function completeRoot(
  root: FiberRoot,
  finishedWork: Fiber,
  expirationTime: ExpirationTime,
): void &#123;
  &#x2F;&#x2F; Check if there&#39;s a batch that matches this expiration time.
  const firstBatch &#x3D; root.firstBatch;
  if (firstBatch !&#x3D;&#x3D; null &amp;&amp; firstBatch._expirationTime &lt;&#x3D; expirationTime) &#123;
    if (completedBatches &#x3D;&#x3D;&#x3D; null) &#123;
      completedBatches &#x3D; [firstBatch];
    &#125; else &#123;
      completedBatches.push(firstBatch);
    &#125;
    if (firstBatch._defer) &#123;
      &#x2F;&#x2F; This root is blocked from committing by a batch. Unschedule it until
      &#x2F;&#x2F; we receive another update.
      root.finishedWork &#x3D; finishedWork;
      root.expirationTime &#x3D; NoWork;
      return;
    &#125;
  &#125;

  &#x2F;&#x2F; Commit the root.
  root.finishedWork &#x3D; null;

  &#x2F;&#x2F; Check if this is a nested update (a sync update scheduled during the
  &#x2F;&#x2F; commit phase).
  if (root &#x3D;&#x3D;&#x3D; lastCommittedRootDuringThisBatch) &#123;
    &#x2F;&#x2F; If the next root is the same as the previous root, this is a nested
    &#x2F;&#x2F; update. To prevent an infinite loop, increment the nested update count.
    nestedUpdateCount++;
  &#125; else &#123;
    &#x2F;&#x2F; Reset whenever we switch roots.
    lastCommittedRootDuringThisBatch &#x3D; root;
    nestedUpdateCount &#x3D; 0;
  &#125;
  commitRoot(root, finishedWork);
&#125;</code></pre><h4 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h4><p>处理完更新后需要确认提交更新至渲染模块，然后渲染模块才能将更新渲染至DOM。</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function commitRoot(root: FiberRoot, finishedWork: Fiber): void &#123;
  isWorking &#x3D; true;
  isCommitting &#x3D; true;
  startCommitTimer();

  invariant(
    root.current !&#x3D;&#x3D; finishedWork,
    &#39;Cannot commit the same tree as before. This is probably a bug &#39; +
      &#39;related to the return field. This error is likely caused by a bug &#39; +
      &#39;in React. Please file an issue.&#39;,
  );
  const committedExpirationTime &#x3D; root.pendingCommitExpirationTime;
  invariant(
    committedExpirationTime !&#x3D;&#x3D; NoWork,
    &#39;Cannot commit an incomplete root. This error is likely caused by a &#39; +
      &#39;bug in React. Please file an issue.&#39;,
  );
  root.pendingCommitExpirationTime &#x3D; NoWork;

  &#x2F;&#x2F; Update the pending priority levels to account for the work that we are
  &#x2F;&#x2F; about to commit. This needs to happen before calling the lifecycles, since
  &#x2F;&#x2F; they may schedule additional updates.
  const updateExpirationTimeBeforeCommit &#x3D; finishedWork.expirationTime;
  const childExpirationTimeBeforeCommit &#x3D; finishedWork.childExpirationTime;
  const earliestRemainingTimeBeforeCommit &#x3D;
    updateExpirationTimeBeforeCommit &#x3D;&#x3D;&#x3D; NoWork ||
    (childExpirationTimeBeforeCommit !&#x3D;&#x3D; NoWork &amp;&amp;
      childExpirationTimeBeforeCommit &lt; updateExpirationTimeBeforeCommit)
      ? childExpirationTimeBeforeCommit
      : updateExpirationTimeBeforeCommit;
  markCommittedPriorityLevels(root, earliestRemainingTimeBeforeCommit);

  let prevInteractions: Set&lt;Interaction&gt; &#x3D; (null: any);
  if (enableSchedulerTracing) &#123;
    &#x2F;&#x2F; Restore any pending interactions at this point,
    &#x2F;&#x2F; So that cascading work triggered during the render phase will be accounted for.
    prevInteractions &#x3D; __interactionsRef.current;
    __interactionsRef.current &#x3D; root.memoizedInteractions;
  &#125;

  &#x2F;&#x2F; Reset this to null before calling lifecycles
  ReactCurrentOwner.current &#x3D; null;

  let firstEffect;
  if (finishedWork.effectTag &gt; PerformedWork) &#123;
    &#x2F;&#x2F; A fiber&#39;s effect list consists only of its children, not itself. So if
    &#x2F;&#x2F; the root has an effect, we need to add it to the end of the list. The
    &#x2F;&#x2F; resulting list is the set that would belong to the root&#39;s parent, if
    &#x2F;&#x2F; it had one; that is, all the effects in the tree including the root.
    if (finishedWork.lastEffect !&#x3D;&#x3D; null) &#123;
      finishedWork.lastEffect.nextEffect &#x3D; finishedWork;
      firstEffect &#x3D; finishedWork.firstEffect;
    &#125; else &#123;
      firstEffect &#x3D; finishedWork;
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; There is no effect on the root.
    firstEffect &#x3D; finishedWork.firstEffect;
  &#125;

  prepareForCommit(root.containerInfo);

  &#x2F;&#x2F; Invoke instances of getSnapshotBeforeUpdate before mutation.
  nextEffect &#x3D; firstEffect;
  startCommitSnapshotEffectsTimer();
  while (nextEffect !&#x3D;&#x3D; null) &#123;
    let didError &#x3D; false;
    let error;
    if (__DEV__) &#123;
      invokeGuardedCallback(null, commitBeforeMutationLifecycles, null);
      if (hasCaughtError()) &#123;
        didError &#x3D; true;
        error &#x3D; clearCaughtError();
      &#125;
    &#125; else &#123;
      try &#123;
        commitBeforeMutationLifecycles();
      &#125; catch (e) &#123;
        didError &#x3D; true;
        error &#x3D; e;
      &#125;
    &#125;
    if (didError) &#123;
      invariant(
        nextEffect !&#x3D;&#x3D; null,
        &#39;Should have next effect. This error is likely caused by a bug &#39; +
          &#39;in React. Please file an issue.&#39;,
      );
      captureCommitPhaseError(nextEffect, error);
      &#x2F;&#x2F; Clean-up
      if (nextEffect !&#x3D;&#x3D; null) &#123;
        nextEffect &#x3D; nextEffect.nextEffect;
      &#125;
    &#125;
  &#125;
  stopCommitSnapshotEffectsTimer();

  if (enableProfilerTimer) &#123;
    &#x2F;&#x2F; Mark the current commit time to be shared by all Profilers in this batch.
    &#x2F;&#x2F; This enables them to be grouped later.
    recordCommitTime();
  &#125;

  &#x2F;&#x2F; Commit all the side-effects within a tree. We&#39;ll do this in two passes.
  &#x2F;&#x2F; The first pass performs all the host insertions, updates, deletions and
  &#x2F;&#x2F; ref unmounts.
  nextEffect &#x3D; firstEffect;
  startCommitHostEffectsTimer();
  while (nextEffect !&#x3D;&#x3D; null) &#123;
    let didError &#x3D; false;
    let error;
    if (__DEV__) &#123;
      invokeGuardedCallback(null, commitAllHostEffects, null);
      if (hasCaughtError()) &#123;
        didError &#x3D; true;
        error &#x3D; clearCaughtError();
      &#125;
    &#125; else &#123;
      try &#123;
        commitAllHostEffects();
      &#125; catch (e) &#123;
        didError &#x3D; true;
        error &#x3D; e;
      &#125;
    &#125;
    if (didError) &#123;
      invariant(
        nextEffect !&#x3D;&#x3D; null,
        &#39;Should have next effect. This error is likely caused by a bug &#39; +
          &#39;in React. Please file an issue.&#39;,
      );
      captureCommitPhaseError(nextEffect, error);
      &#x2F;&#x2F; Clean-up
      if (nextEffect !&#x3D;&#x3D; null) &#123;
        nextEffect &#x3D; nextEffect.nextEffect;
      &#125;
    &#125;
  &#125;
  stopCommitHostEffectsTimer();

  resetAfterCommit(root.containerInfo);

  &#x2F;&#x2F; The work-in-progress tree is now the current tree. This must come after
  &#x2F;&#x2F; the first pass of the commit phase, so that the previous tree is still
  &#x2F;&#x2F; current during componentWillUnmount, but before the second pass, so that
  &#x2F;&#x2F; the finished work is current during componentDidMount&#x2F;Update.
  root.current &#x3D; finishedWork;

  &#x2F;&#x2F; In the second pass we&#39;ll perform all life-cycles and ref callbacks.
  &#x2F;&#x2F; Life-cycles happen as a separate pass so that all placements, updates,
  &#x2F;&#x2F; and deletions in the entire tree have already been invoked.
  &#x2F;&#x2F; This pass also triggers any renderer-specific initial effects.
  nextEffect &#x3D; firstEffect;
  startCommitLifeCyclesTimer();
  while (nextEffect !&#x3D;&#x3D; null) &#123;
    let didError &#x3D; false;
    let error;
    if (__DEV__) &#123;
      invokeGuardedCallback(
        null,
        commitAllLifeCycles,
        null,
        root,
        committedExpirationTime,
      );
      if (hasCaughtError()) &#123;
        didError &#x3D; true;
        error &#x3D; clearCaughtError();
      &#125;
    &#125; else &#123;
      try &#123;
        commitAllLifeCycles(root, committedExpirationTime);
      &#125; catch (e) &#123;
        didError &#x3D; true;
        error &#x3D; e;
      &#125;
    &#125;
    if (didError) &#123;
      invariant(
        nextEffect !&#x3D;&#x3D; null,
        &#39;Should have next effect. This error is likely caused by a bug &#39; +
          &#39;in React. Please file an issue.&#39;,
      );
      captureCommitPhaseError(nextEffect, error);
      if (nextEffect !&#x3D;&#x3D; null) &#123;
        nextEffect &#x3D; nextEffect.nextEffect;
      &#125;
    &#125;
  &#125;

  isCommitting &#x3D; false;
  isWorking &#x3D; false;
  stopCommitLifeCyclesTimer();
  stopCommitTimer();
  onCommitRoot(finishedWork.stateNode);
  if (__DEV__ &amp;&amp; ReactFiberInstrumentation.debugTool) &#123;
    ReactFiberInstrumentation.debugTool.onCommitWork(finishedWork);
  &#125;

  const updateExpirationTimeAfterCommit &#x3D; finishedWork.expirationTime;
  const childExpirationTimeAfterCommit &#x3D; finishedWork.childExpirationTime;
  const earliestRemainingTimeAfterCommit &#x3D;
    updateExpirationTimeAfterCommit &#x3D;&#x3D;&#x3D; NoWork ||
    (childExpirationTimeAfterCommit !&#x3D;&#x3D; NoWork &amp;&amp;
      childExpirationTimeAfterCommit &lt; updateExpirationTimeAfterCommit)
      ? childExpirationTimeAfterCommit
      : updateExpirationTimeAfterCommit;
  if (earliestRemainingTimeAfterCommit &#x3D;&#x3D;&#x3D; NoWork) &#123;
    &#x2F;&#x2F; If there&#39;s no remaining work, we can clear the set of already failed
    &#x2F;&#x2F; error boundaries.
    legacyErrorBoundariesThatAlreadyFailed &#x3D; null;
  &#125;
  onCommit(root, earliestRemainingTimeAfterCommit);

  if (enableSchedulerTracing) &#123;
    __interactionsRef.current &#x3D; prevInteractions;

    let subscriber;

    try &#123;
      subscriber &#x3D; __subscriberRef.current;
      if (subscriber !&#x3D;&#x3D; null &amp;&amp; root.memoizedInteractions.size &gt; 0) &#123;
        const threadID &#x3D; computeThreadID(
          committedExpirationTime,
          root.interactionThreadID,
        );
        subscriber.onWorkStopped(root.memoizedInteractions, threadID);
      &#125;
    &#125; catch (error) &#123;
      &#x2F;&#x2F; It&#39;s not safe for commitRoot() to throw.
      &#x2F;&#x2F; Store the error for now and we&#39;ll re-throw in finishRendering().
      if (!hasUnhandledError) &#123;
        hasUnhandledError &#x3D; true;
        unhandledError &#x3D; error;
      &#125;
    &#125; finally &#123;
      if (!nextRenderIncludesTimedOutPlaceholder) &#123;
        &#x2F;&#x2F; Clear completed interactions from the pending Map.
        &#x2F;&#x2F; Unless the render was suspended or cascading work was scheduled,
        &#x2F;&#x2F; In which case– leave pending interactions until the subsequent render.
        const pendingInteractionMap &#x3D; root.pendingInteractionMap;
        pendingInteractionMap.forEach(
          (scheduledInteractions, scheduledExpirationTime) &#x3D;&gt; &#123;
            &#x2F;&#x2F; Only decrement the pending interaction count if we&#39;re done.
            &#x2F;&#x2F; If there&#39;s still work at the current priority,
            &#x2F;&#x2F; That indicates that we are waiting for suspense data.
            if (
              earliestRemainingTimeAfterCommit &#x3D;&#x3D;&#x3D; NoWork ||
              scheduledExpirationTime &lt; earliestRemainingTimeAfterCommit
            ) &#123;
              pendingInteractionMap.delete(scheduledExpirationTime);

              scheduledInteractions.forEach(interaction &#x3D;&gt; &#123;
                interaction.__count--;

                if (subscriber !&#x3D;&#x3D; null &amp;&amp; interaction.__count &#x3D;&#x3D;&#x3D; 0) &#123;
                  try &#123;
                    subscriber.onInteractionScheduledWorkCompleted(interaction);
                  &#125; catch (error) &#123;
                    &#x2F;&#x2F; It&#39;s not safe for commitRoot() to throw.
                    &#x2F;&#x2F; Store the error for now and we&#39;ll re-throw in finishRendering().
                    if (!hasUnhandledError) &#123;
                      hasUnhandledError &#x3D; true;
                      unhandledError &#x3D; error;
                    &#125;
                  &#125;
                &#125;
              &#125;);
            &#125;
          &#125;,
        );
      &#125;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 循环执行提交更新
function commitAllHostEffects() &#123;
  while (nextEffect !&#x3D;&#x3D; null) &#123;
    if (__DEV__) &#123;
      ReactCurrentFiber.setCurrentFiber(nextEffect);
    &#125;
    recordEffect();

    const effectTag &#x3D; nextEffect.effectTag;

    if (effectTag &amp; ContentReset) &#123;
      commitResetTextContent(nextEffect);
    &#125;

    if (effectTag &amp; Ref) &#123;
      const current &#x3D; nextEffect.alternate;
      if (current !&#x3D;&#x3D; null) &#123;
        commitDetachRef(current);
      &#125;
    &#125;

    &#x2F;&#x2F; The following switch statement is only concerned about placement,
    &#x2F;&#x2F; updates, and deletions. To avoid needing to add a case for every
    &#x2F;&#x2F; possible bitmap value, we remove the secondary effects from the
    &#x2F;&#x2F; effect tag and switch on that value.
    let primaryEffectTag &#x3D; effectTag &amp; (Placement | Update | Deletion);
    switch (primaryEffectTag) &#123;
      case Placement: &#123;
        commitPlacement(nextEffect);
        &#x2F;&#x2F; Clear the &quot;placement&quot; from effect tag so that we know that this is inserted, before
        &#x2F;&#x2F; any life-cycles like componentDidMount gets called.
        &#x2F;&#x2F; TODO: findDOMNode doesn&#39;t rely on this any more but isMounted
        &#x2F;&#x2F; does and isMounted is deprecated anyway so we should be able
        &#x2F;&#x2F; to kill this.
        nextEffect.effectTag &amp;&#x3D; ~Placement;
        break;
      &#125;
      case PlacementAndUpdate: &#123;
        &#x2F;&#x2F; Placement
        commitPlacement(nextEffect);
        &#x2F;&#x2F; Clear the &quot;placement&quot; from effect tag so that we know that this is inserted, before
        &#x2F;&#x2F; any life-cycles like componentDidMount gets called.
        nextEffect.effectTag &amp;&#x3D; ~Placement;

        &#x2F;&#x2F; Update
        const current &#x3D; nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      &#125;
      case Update: &#123;
        const current &#x3D; nextEffect.alternate;
        commitWork(current, nextEffect);
        break;
      &#125;
      case Deletion: &#123;
        commitDeletion(nextEffect);
        break;
      &#125;
    &#125;
    nextEffect &#x3D; nextEffect.nextEffect;
  &#125;

  if (__DEV__) &#123;
    ReactCurrentFiber.resetCurrentFiber();
  &#125;
&#125;</code></pre><p>提交更新是最后确认更新组件的阶段，现在我们看一下提交更新的主要逻辑：</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">function commitWork(current: Fiber | null, finishedWork: Fiber): void &#123;
  if (!supportsMutation) &#123;
    commitContainer(finishedWork);
    return;
  &#125;

  switch (finishedWork.tag) &#123;
    case ClassComponent:
    case ClassComponentLazy: &#123;
      return;
    &#125;
    case HostComponent: &#123;
      const instance: Instance &#x3D; finishedWork.stateNode;
      if (instance !&#x3D; null) &#123;
        &#x2F;&#x2F; Commit the work prepared earlier.
        const newProps &#x3D; finishedWork.memoizedProps;
        &#x2F;&#x2F; For hydration we reuse the update path but we treat the oldProps
        &#x2F;&#x2F; as the newProps. The updatePayload will contain the real change in
        &#x2F;&#x2F; this case.
        const oldProps &#x3D; current !&#x3D;&#x3D; null ? current.memoizedProps : newProps;
        const type &#x3D; finishedWork.type;
        &#x2F;&#x2F; TODO: Type the updateQueue to be specific to host components.
        const updatePayload: null | UpdatePayload &#x3D; (finishedWork.updateQueue: any);
        finishedWork.updateQueue &#x3D; null;
        if (updatePayload !&#x3D;&#x3D; null) &#123;
          commitUpdate(
            instance,
            updatePayload,
            type,
            oldProps,
            newProps,
            finishedWork,
          );
        &#125;
      &#125;
      return;
    &#125;
    case HostText: &#123;
      invariant(
        finishedWork.stateNode !&#x3D;&#x3D; null,
        &#39;This should have a text node initialized. This error is likely &#39; +
          &#39;caused by a bug in React. Please file an issue.&#39;,
      );
      const textInstance: TextInstance &#x3D; finishedWork.stateNode;
      const newText: string &#x3D; finishedWork.memoizedProps;
      &#x2F;&#x2F; For hydration we reuse the update path but we treat the oldProps
      &#x2F;&#x2F; as the newProps. The updatePayload will contain the real change in
      &#x2F;&#x2F; this case.
      const oldText: string &#x3D;
        current !&#x3D;&#x3D; null ? current.memoizedProps : newText;
      commitTextUpdate(textInstance, oldText, newText);
      return;
    &#125;
    case HostRoot: &#123;
      return;
    &#125;
    case Profiler: &#123;
      return;
    &#125;
    case PlaceholderComponent: &#123;
      return;
    &#125;
    default: &#123;
      invariant(
        false,
        &#39;This unit of work tag should not have side-effects. This error is &#39; +
          &#39;likely caused by a bug in React. Please file an issue.&#39;,
      );
    &#125;
  &#125;
&#125;</code></pre><h4 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h4><p>至此首次渲染的执行流程为：<br><code>ReactDOM.render</code>（渲染入口） =&gt; <code>legacyRenderSubtreeIntoContainer</code>（把虚拟的dom树渲染到真实的dom容器中） =&gt; <code>DOMRenderer.updateContainer</code>（更新容器内容） =&gt; <code>scheduleRootUpdate</code>（开始更新） =&gt; <code>scheduleWork</code>（处理更新） =&gt; <code>commitWork</code>（提交更新）</p><h2 id="高级指南"><a href="#高级指南" class="headerlink" title="高级指南"></a>高级指南</h2><h3 id="插槽-Portals"><a href="#插槽-Portals" class="headerlink" title="插槽(Portals)"></a>插槽(Portals)</h3><p>Portals 提供了一种很好的方法，将子节点渲染到父组件 DOM 层次结构之外的 DOM 节点。</p><h2 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h2><blockquote><p>React Fiber 并不是所谓的纤程（微线程、协程），而是一种基于浏览器的单线程调度算法。</p></blockquote><p>我们都知道浏览器渲染引擎是单线程的，在 React15.x 及之前版本，从 setState 开始到渲染完成整个过程是不受控制且连续不中断完成的，由于该过程将会占用整个线程，则其他任务都会被阻塞，如样式计算、界面布局以及许多情况下的绘制等。如果需要渲染的是一个很大、层级很深的组件，这可能就会使用户感觉明显卡顿，比如更新一个组件需要1毫秒，如果有200个组件要更新，那就需要200毫秒，在这200毫秒的更新过程中，浏览器唯一的主线程在专心运行更新操作，无暇去做其他任何事情。想象一下，在这200毫秒内，用户往一个input元素中输入点什么，敲击键盘也不会立即获得响应，虽然渲染输入按键结果是浏览器主线程的工作，但是浏览器主线程被React占用，抽不出空，最后的结果就是用户敲了按键看不到反应，等React更新过程结束之后，咔咔咔那些按键一下子出现在input元素里了，这个版本的调和器可以称为<strong>栈调和器（Stack Reconciler）</strong>。Stack Reconcilier 的主要缺陷就是<strong>不能暂停渲染任务，也不能切分任务，更无法有效平衡组件更新渲染与动画相关任务间的执行顺序（即不能划分任务优先级），这样就很有可能导致重要任务卡顿，动画掉帧等问题。</strong></p><p>为了解决这个问题，React 团队经过两年多的努力，提出了一个更先进的调和器，它允许渲染过程分段完成，而不必一次性完成，在渲染期间可返回到主线程控制执行其他任务。这是通过计算部分组件树的变更，并暂停渲染更新，询问主线程是否有更高需求的绘制或者更新任务需要执行，这些高需求的任务完成后再重新渲染。这一切的实现是在代码层引入了一个新的数据结构：<strong>Fiber对象</strong>，每一个组件实例对应有一个fiber实例，此fiber实例负责管理组件实例的更新，渲染任务及与其他fiber实例的通信，这个先进的调和器叫做<strong>纤维调和器（Fiber Reconciler）</strong>，它提供的新功能主要有：<br><strong>一：</strong>把可中断的任务拆分成小任务；<br><strong>二：</strong>可重用各分阶段任务，对正在做的工作调整优先次序；<br><strong>三：</strong>可以在父子组件任务间前进后退切换任务，以支持React执行过程中的布局刷新；<br><strong>四：</strong>支持 render 方法返回多个元素；<br><strong>五：</strong>对异常边界处理提供了更好的支持；</p><h3 id="调度任务（scheduleWork）"><a href="#调度任务（scheduleWork）" class="headerlink" title="调度任务（scheduleWork）"></a>调度任务（scheduleWork）</h3><p>前面提到 Fiber 可以异步实现不同优先级任务的协调执行，目前在 JavaScript 中也提供了这种方式，在新版主流浏览器有两个可用API：requestIdleCallback 和 requestAnimationFrame：<br><strong>requestIdleCallback：</strong>在线程空闲时调度执行低优先级函数。<br><strong>requestAnimationFrame：</strong>在下一个动画帧调度执行高优先级函数。</p><p>一般网页线程执行任务时会以帧的形式划分，大部分网页控制在30-60帧是不会影响用户体验的；在两个执行帧之间，主线程通常会有一小段空闲时间，requestIdleCallback可以在这个空闲期（Idle Period）调用空闲期回调（Idle Callback），执行一些任务。<br><img src="/images/react-source-analysis/img2.png" alt="img2.png"></p><p>而 Fiber 所做的就是需要分解渲染任务，根据优先级使用API调度，异步执行指定任务。低优先级任务由 requestIdleCallback 处理；高优先级任务，如动画相关的由 requestAnimationFrame 处理；requestIdleCallback 可以在多个空闲期调用空闲期回调，执行任务；requestIdleCallback 方法提供 deadline，即任务执行限制时间，以切分任务，避免长时间执行，阻塞UI渲染而导致掉帧；</p><p>现在我们来看一下 React 调度任务实现的源码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; TODO: 目前，只有一个优先级别，Deferred。未来将增加额外的优先级
var DEFERRED_TIMEOUT &#x3D; 5000;

&#x2F;&#x2F; 回调被储存为一个双向循环链表
var firstCallbackNode &#x3D; null;

&#x2F;&#x2F; 是否在执行工作
var isPerformingWork &#x3D; false;

var isHostCallbackScheduled &#x3D; false;

var hasNativePerformanceNow &#x3D;
  typeof performance &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; typeof performance.now &#x3D;&#x3D;&#x3D; &#39;function&#39;;

var timeRemaining;
if (hasNativePerformanceNow) &#123;
  timeRemaining &#x3D; function() &#123;
    &#x2F;&#x2F; We assume that if we have a performance timer that the rAF callback
    &#x2F;&#x2F; gets a performance timer value. Not sure if this is always true.
    var remaining &#x3D; getFrameDeadline() - performance.now();
    &#x2F;&#x2F; 计算得到当前帧运行剩余时间
    return remaining &gt; 0 ? remaining : 0;
  &#125;;
&#125; else &#123;
  timeRemaining &#x3D; function() &#123;
    &#x2F;&#x2F; Fallback to Date.now()
    var remaining &#x3D; getFrameDeadline() - Date.now();
    &#x2F;&#x2F; 计算得到当前帧运行剩余时间
    return remaining &gt; 0 ? remaining : 0;
  &#125;;
&#125;

var deadlineObject &#x3D; &#123;
  timeRemaining,
  didTimeout: false,
&#125;;

function ensureHostCallbackIsScheduled() &#123;
  &#x2F;&#x2F; 正在执行工作
  if (isPerformingWork) &#123;
    return;
  &#125;
  &#x2F;&#x2F; 使用列表中最先超时的回调
  var timesOutAt &#x3D; firstCallbackNode.timesOutAt;
  if (!isHostCallbackScheduled) &#123;
    isHostCallbackScheduled &#x3D; true;
  &#125; else &#123;
    &#x2F;&#x2F; 取消回调
    cancelCallback();
  &#125;
  requestCallback(flushWork, timesOutAt);
&#125;

&#x2F;&#x2F; 刷新第一次回调
function flushFirstCallback(node) &#123;
  var flushedNode &#x3D; firstCallbackNode;

  &#x2F;&#x2F; 在调用回调之前从列表中移除该节点。这样，即使回调抛出, 列表也处于一致状态。
  var next &#x3D; firstCallbackNode.next;
  if (firstCallbackNode &#x3D;&#x3D;&#x3D; next) &#123;
    &#x2F;&#x2F; 这是列表中的最后一个回调。
    firstCallbackNode &#x3D; null;
    next &#x3D; null;
  &#125; else &#123;
    var previous &#x3D; firstCallbackNode.previous;
    firstCallbackNode &#x3D; previous.next &#x3D; next;
    next.previous &#x3D; previous;
  &#125;

  flushedNode.next &#x3D; flushedNode.previous &#x3D; null;

  &#x2F;&#x2F; 现在调用回调是安全的。
  var callback &#x3D; flushedNode.callback;
  callback(deadlineObject);
&#125;

function flushWork(didTimeout) &#123;
  isPerformingWork &#x3D; true;
  deadlineObject.didTimeout &#x3D; didTimeout;
  try &#123;
    if (didTimeout) &#123;
      &#x2F;&#x2F; Flush all the timed out callbacks without yielding.
      while (firstCallbackNode !&#x3D;&#x3D; null) &#123;
        &#x2F;&#x2F; Read the current time. Flush all the callbacks that expire at or
        &#x2F;&#x2F; earlier than that time. Then read the current time again and repeat.
        &#x2F;&#x2F; This optimizes for as few performance.now calls as possible.
        var currentTime &#x3D; getCurrentTime();
        if (firstCallbackNode.timesOutAt &lt;&#x3D; currentTime) &#123;
          do &#123;
            flushFirstCallback();
          &#125; while (
            firstCallbackNode !&#x3D;&#x3D; null &amp;&amp;
            firstCallbackNode.timesOutAt &lt;&#x3D; currentTime
          );
          continue;
        &#125;
        break;
      &#125;
    &#125; else &#123;
      &#x2F;&#x2F; Keep flushing callbacks until we run out of time in the frame.
      if (firstCallbackNode !&#x3D;&#x3D; null) &#123;
        do &#123;
          flushFirstCallback();
        &#125; while (
          firstCallbackNode !&#x3D;&#x3D; null &amp;&amp;
          getFrameDeadline() - getCurrentTime() &gt; 0
        );
      &#125;
    &#125;
  &#125; finally &#123;
    isPerformingWork &#x3D; false;
    if (firstCallbackNode !&#x3D;&#x3D; null) &#123;
      &#x2F;&#x2F; There&#39;s still work remaining. Request another callback.
      ensureHostCallbackIsScheduled(firstCallbackNode);
    &#125; else &#123;
      isHostCallbackScheduled &#x3D; false;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 调度任务，这是一个不稳定 api
function unstable_scheduleWork(callback, options) &#123;
  var currentTime &#x3D; getCurrentTime();

  var timesOutAt;
  if (
    options !&#x3D;&#x3D; undefined &amp;&amp;
    options !&#x3D;&#x3D; null &amp;&amp;
    options.timeout !&#x3D;&#x3D; null &amp;&amp;
    options.timeout !&#x3D;&#x3D; undefined
  ) &#123;
    &#x2F;&#x2F; 根据传入的 timeout 计算超时
    timesOutAt &#x3D; currentTime + options.timeout;
  &#125; else &#123;
    &#x2F;&#x2F; 使用默认常量计算超时
    timesOutAt &#x3D; currentTime + DEFERRED_TIMEOUT;
  &#125;

  var newNode &#x3D; &#123;
    callback,
    timesOutAt,
    next: null,
    previous: null,
  &#125;;

  &#x2F;&#x2F; 将新回调插入列表中, 并按其超时顺序排序
  if (firstCallbackNode &#x3D;&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; 这是列表中的第一个回调
    firstCallbackNode &#x3D; newNode.next &#x3D; newNode.previous &#x3D; newNode;
    ensureHostCallbackIsScheduled(firstCallbackNode);
  &#125; else &#123;
    var next &#x3D; null;
    var node &#x3D; firstCallbackNode;
    do &#123;
      if (node.timesOutAt &gt; timesOutAt) &#123;
        &#x2F;&#x2F; 在此之前, 新的回调超时
        next &#x3D; node;
        break;
      &#125;
      node &#x3D; node.next;
    &#125; while (node !&#x3D;&#x3D; firstCallbackNode);

    if (next &#x3D;&#x3D;&#x3D; null) &#123;
      &#x2F;&#x2F; 找不到稍后超时的回调, 这意味着新的回调在列表中具有最新的超时。
      next &#x3D; firstCallbackNode;
    &#125; else if (next &#x3D;&#x3D;&#x3D; firstCallbackNode) &#123;
      &#x2F;&#x2F; 新回调在整个列表中具有最早的超时。
      firstCallbackNode &#x3D; newNode;
      ensureHostCallbackIsScheduled(firstCallbackNode);
    &#125;

    var previous &#x3D; next.previous;
    previous.next &#x3D; next.previous &#x3D; newNode;
    newNode.next &#x3D; next;
    newNode.previous &#x3D; previous;
  &#125;

  return newNode;
&#125;

function unstable_cancelScheduledWork(callbackNode) &#123;
  var next &#x3D; callbackNode.next;
  if (next &#x3D;&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; Already cancelled.
    return;
  &#125;

  if (next &#x3D;&#x3D;&#x3D; callbackNode) &#123;
    &#x2F;&#x2F; This is the only scheduled callback. Clear the list.
    firstCallbackNode &#x3D; null;
  &#125; else &#123;
    &#x2F;&#x2F; Remove the callback from its position in the list.
    if (callbackNode &#x3D;&#x3D;&#x3D; firstCallbackNode) &#123;
      firstCallbackNode &#x3D; next;
    &#125;
    var previous &#x3D; callbackNode.previous;
    previous.next &#x3D; next;
    next.previous &#x3D; previous;
  &#125;

  callbackNode.next &#x3D; callbackNode.previous &#x3D; null;
&#125;

&#x2F;&#x2F; The remaining code is essentially a polyfill for requestIdleCallback. It
&#x2F;&#x2F; works by scheduling a requestAnimationFrame, storing the time for the start
&#x2F;&#x2F; of the frame, then scheduling a postMessage which gets scheduled after paint.
&#x2F;&#x2F; Within the postMessage handler do as much work as possible until time + frame
&#x2F;&#x2F; rate. By separating the idle call into a separate event tick we ensure that
&#x2F;&#x2F; layout, paint and other browser work is counted against the available time.
&#x2F;&#x2F; The frame rate is dynamically adjusted.

&#x2F;&#x2F; We capture a local reference to any global, in case it gets polyfilled after
&#x2F;&#x2F; this module is initially evaluated. We want to be using a
&#x2F;&#x2F; consistent implementation.
var localDate &#x3D; Date;

&#x2F;&#x2F; This initialization code may run even on server environments if a component
&#x2F;&#x2F; just imports ReactDOM (e.g. for findDOMNode). Some environments might not
&#x2F;&#x2F; have setTimeout or clearTimeout. However, we always expect them to be defined
&#x2F;&#x2F; on the client. https:&#x2F;&#x2F;github.com&#x2F;facebook&#x2F;react&#x2F;pull&#x2F;13088
var localSetTimeout &#x3D; typeof setTimeout &#x3D;&#x3D;&#x3D; &#39;function&#39; ? setTimeout : undefined;
var localClearTimeout &#x3D;
  typeof clearTimeout &#x3D;&#x3D;&#x3D; &#39;function&#39; ? clearTimeout : undefined;

&#x2F;&#x2F; We don&#39;t expect either of these to necessarily be defined, but we will error
&#x2F;&#x2F; later if they are missing on the client.
var localRequestAnimationFrame &#x3D;
  typeof requestAnimationFrame &#x3D;&#x3D;&#x3D; &#39;function&#39;
    ? requestAnimationFrame
    : undefined;
var localCancelAnimationFrame &#x3D;
  typeof cancelAnimationFrame &#x3D;&#x3D;&#x3D; &#39;function&#39; ? cancelAnimationFrame : undefined;

var getCurrentTime;

&#x2F;&#x2F; requestAnimationFrame does not run when the tab is in the background. If
&#x2F;&#x2F; we&#39;re backgrounded we prefer for that work to happen so that the page
&#x2F;&#x2F; continues to load in the background. So we also schedule a &#39;setTimeout&#39; as
&#x2F;&#x2F; a fallback.
&#x2F;&#x2F; TODO: Need a better heuristic for backgrounded work.
var ANIMATION_FRAME_TIMEOUT &#x3D; 100;
var rAFID;
var rAFTimeoutID;
var requestAnimationFrameWithTimeout &#x3D; function(callback) &#123;
  &#x2F;&#x2F; schedule rAF and also a setTimeout
  rAFID &#x3D; localRequestAnimationFrame(function(timestamp) &#123;
    &#x2F;&#x2F; cancel the setTimeout
    localClearTimeout(rAFTimeoutID);
    callback(timestamp);
  &#125;);
  rAFTimeoutID &#x3D; localSetTimeout(function() &#123;
    &#x2F;&#x2F; cancel the requestAnimationFrame
    localCancelAnimationFrame(rAFID);
    callback(getCurrentTime());
  &#125;, ANIMATION_FRAME_TIMEOUT);
&#125;;

if (hasNativePerformanceNow) &#123;
  var Performance &#x3D; performance;
  getCurrentTime &#x3D; function() &#123;
    return Performance.now();
  &#125;;
&#125; else &#123;
  getCurrentTime &#x3D; function() &#123;
    return localDate.now();
  &#125;;
&#125;

var requestCallback;
var cancelCallback;
var getFrameDeadline;

if (typeof window &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123; &#x2F;&#x2F; 非浏览器环境
  var timeoutID &#x3D; -1;
  requestCallback &#x3D; function(callback, absoluteTimeout) &#123;
    timeoutID &#x3D; setTimeout(callback, 0, true);
  &#125;;
  cancelCallback &#x3D; function() &#123;
    clearTimeout(timeoutID);
  &#125;;
  getFrameDeadline &#x3D; function() &#123;
    return 0;
  &#125;;
&#125; else if (window._schedMock) &#123; &#x2F;&#x2F; 动态注入, 仅用于测试目的。
  var impl &#x3D; window._schedMock;
  requestCallback &#x3D; impl[0];
  cancelCallback &#x3D; impl[1];
  getFrameDeadline &#x3D; impl[2];
&#125; else &#123;
  if (typeof console !&#x3D;&#x3D; &#39;undefined&#39;) &#123;
    if (typeof localRequestAnimationFrame !&#x3D;&#x3D; &#39;function&#39;) &#123;
      console.error(
        &quot;This browser doesn&#39;t support requestAnimationFrame. &quot; +
          &#39;Make sure that you load a &#39; +
          &#39;polyfill in older browsers. https:&#x2F;&#x2F;fb.me&#x2F;react-polyfills&#39;,
      );
    &#125;
    if (typeof localCancelAnimationFrame !&#x3D;&#x3D; &#39;function&#39;) &#123;
      console.error(
        &quot;This browser doesn&#39;t support cancelAnimationFrame. &quot; +
          &#39;Make sure that you load a &#39; +
          &#39;polyfill in older browsers. https:&#x2F;&#x2F;fb.me&#x2F;react-polyfills&#39;,
      );
    &#125;
  &#125;

  var scheduledCallback &#x3D; null;
  &#x2F;&#x2F; 是否在执行空闲期回调
  var isIdleScheduled &#x3D; false;
  var timeoutTime &#x3D; -1;

  var isAnimationFrameScheduled &#x3D; false;

  var isPerformingIdleWork &#x3D; false;

  var frameDeadline &#x3D; 0;

  &#x2F;&#x2F; 用启发式跟踪法，从30fps（即30帧）开始调整得到的更适于当前环境的一帧限制时间；
  var previousFrameTime &#x3D; 33;
  var activeFrameTime &#x3D; 33;

  getFrameDeadline &#x3D; function() &#123;
    return frameDeadline;
  &#125;;

  &#x2F;&#x2F; We use the postMessage trick to defer idle work until after the repaint.
  var messageKey &#x3D;
    &#39;__reactIdleCallback$&#39; +
    Math.random()
      .toString(36)
      .slice(2);
  &#x2F;&#x2F; 空闲期回调
  var idleTick &#x3D; function(event) &#123;
    if (event.source !&#x3D;&#x3D; window || event.data !&#x3D;&#x3D; messageKey) &#123;
      return;
    &#125;
    &#x2F;&#x2F; 重置为false，表明可以调用空闲期回调
    isIdleScheduled &#x3D; false;

    var currentTime &#x3D; getCurrentTime();

    var didTimeout &#x3D; false;
    if (frameDeadline - currentTime &lt;&#x3D; 0) &#123;
      &#x2F;&#x2F; 帧到期时间小于当前时间，说明已过期
      if (timeoutTime !&#x3D;&#x3D; -1 &amp;&amp; timeoutTime &lt;&#x3D; currentTime) &#123;
        &#x2F;&#x2F; 此帧已过期，且发生任务处理函数（执行具体任务，传入的回调）的超时
        &#x2F;&#x2F; 需要执行任务处理，下文将调用；
        didTimeout &#x3D; true;
      &#125; else &#123;
        &#x2F;&#x2F; 帧已过期，但没有发生任务处理函数的超时，暂时不调用任务处理函数
        if (!isAnimationFrameScheduled) &#123;
          &#x2F;&#x2F; 当前没有调度别的帧回调函数
          &#x2F;&#x2F; 调度下一帧
          isAnimationFrameScheduled &#x3D; true;
          requestAnimationFrameWithTimeout(animationTick);
        &#125;
        &#x2F;&#x2F; Exit without invoking the callback.
        return;
      &#125;
    &#125;

    &#x2F;&#x2F; 缓存的任务处理函数
    timeoutTime &#x3D; -1;
    var callback &#x3D; scheduledCallback;
    scheduledCallback &#x3D; null;
    if (callback !&#x3D;&#x3D; null) &#123;
      isPerformingIdleWork &#x3D; true;
      try &#123;
        &#x2F;&#x2F; 执行回调
        callback(didTimeout);
      &#125; finally &#123;
        isPerformingIdleWork &#x3D; false;
      &#125;
    &#125;
  &#125;;
  &#x2F;&#x2F; Assumes that we have addEventListener in this environment. Might need
  &#x2F;&#x2F; something better for old IE.
  window.addEventListener(&#39;message&#39;, idleTick, false);

  &#x2F;&#x2F; 帧回调
  var animationTick &#x3D; function(rafTime) &#123;
    isAnimationFrameScheduled &#x3D; false;
    var nextFrameTime &#x3D; rafTime - frameDeadline + activeFrameTime;
    if (
      nextFrameTime &lt; activeFrameTime &amp;&amp;
      previousFrameTime &lt; activeFrameTime
    ) &#123;
      if (nextFrameTime &lt; 8) &#123;
        &#x2F;&#x2F; Defensive coding. We don&#39;t support higher frame rates than 120hz.
        &#x2F;&#x2F; If we get lower than that, it is probably a bug.
        nextFrameTime &#x3D; 8;
      &#125;
      &#x2F;&#x2F; If one frame goes long, then the next one can be short to catch up.
      &#x2F;&#x2F; If two frames are short in a row, then that&#39;s an indication that we
      &#x2F;&#x2F; actually have a higher frame rate than what we&#39;re currently optimizing.
      &#x2F;&#x2F; We adjust our heuristic dynamically accordingly. For example, if we&#39;re
      &#x2F;&#x2F; running on 120hz display or 90hz VR display.
      &#x2F;&#x2F; Take the max of the two in case one of them was an anomaly due to
      &#x2F;&#x2F; missed frame deadlines.
      activeFrameTime &#x3D;
        nextFrameTime &lt; previousFrameTime ? previousFrameTime : nextFrameTime;
    &#125; else &#123;
      previousFrameTime &#x3D; nextFrameTime;
    &#125;
    frameDeadline &#x3D; rafTime + activeFrameTime;
    if (!isIdleScheduled) &#123;
      &#x2F;&#x2F; 不在执行空闲期回调，表明可以调用空闲期回调
      isIdleScheduled &#x3D; true;
      window.postMessage(messageKey, &#39;*&#39;);
    &#125;
  &#125;;

  &#x2F;&#x2F; 自定义 模拟requestIdleCallback
  requestCallback &#x3D; function(callback, absoluteTimeout) &#123;
    &#x2F;&#x2F; 回调函数
    scheduledCallback &#x3D; callback;
    timeoutTime &#x3D; absoluteTimeout;
    if (isPerformingIdleWork) &#123;
      &#x2F;&#x2F; 如果我们已经在执行空闲工作, 则必须抛出错误。
      &#x2F;&#x2F; 不要等待下一帧。在新事件中继续尽快工作 ASAP。
      window.postMessage(messageKey, &#39;*&#39;);
    &#125; else if (!isAnimationFrameScheduled) &#123;
      &#x2F;&#x2F; 如果当前没有调度帧回调函数，我们需要进行一个调度帧回调函数
      &#x2F;&#x2F; TODO: rAF 仍是 setTimeout
      isAnimationFrameScheduled &#x3D; true;
      &#x2F;&#x2F; 初始开始执行帧回调 
      requestAnimationFrameWithTimeout(animationTick);
    &#125;
  &#125;;

  cancelCallback &#x3D; function() &#123;
    scheduledCallback &#x3D; null;
    isIdleScheduled &#x3D; false;
    timeoutTime &#x3D; -1;
  &#125;;
&#125;

export &#123;
  unstable_scheduleWork,
  unstable_cancelScheduledWork,
  getCurrentTime as unstable_now,
&#125;;
</code></pre><h3 id="Fiber与组件"><a href="#Fiber与组件" class="headerlink" title="Fiber与组件"></a>Fiber与组件</h3><p>我们已经知道了Fiber的功能及其主要特点，那么其如何和组件联系，并且如何实现效果的呢，以下几点可以概括：</p><ol><li>React应用中的基础单元是组件，应用以组件树形式组织，渲染组件；</li><li>Fiber调和器基础单元则是fiber（调和单元），应用以fiber树形式组织，应用Fiber算法；</li><li>组件树和fiber树结构对应，一个组件实例有一个对应的fiber实例；</li><li>Fiber负责整个应用层面的调和，fiber实例负责对应组件的调和；</li></ol><p><strong>注意Fiber与fiber的区别，Fiber是指调和器算法，fiber则是调和器算法组成单元，和组件与应用关系类似，每一个组件实例会有对应的fiber实例负责该组件的调和。</strong></p><h3 id="Fiber数据结构"><a href="#Fiber数据结构" class="headerlink" title="Fiber数据结构"></a>Fiber数据结构</h3><p>截止目前，我们对Fiber应该有了初步的了解，在具体介绍Fiber的实现与架构之前，准备先简单介绍一下Fiber的数据结构，数据结构能一定程度反映其整体工作架构。<br>其实，一个fiber就是一个JavaScript对象，以键值对形式存储了一个关联组件的信息，包括组件接收的props，维护的state，最后需要渲染出的内容等。接下来我们将介Fiber对象的主要属性。</p><h4 id="FiberRoot-对象"><a href="#FiberRoot-对象" class="headerlink" title="FiberRoot 对象"></a>FiberRoot 对象</h4><p>FiberRoot 对象主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export type FiberRoot &#x3D; &#123;
  &#x2F;&#x2F; fiber节点的容器元素相关信息，通常会直接传入容器元素
  containerInfo: any,
  &#x2F;&#x2F; 仅用于持久更新
  pendingChildren: any,
  &#x2F;&#x2F; 当前fiber树中激活状态（正在处理）的fiber节点
  current: Fiber,
  &#x2F;&#x2F; 从提交中暂停的最早和最新的优先级级别
  earliestSuspendedTime: ExpirationTime,
  latestSuspendedTime: ExpirationTime,
  &#x2F;&#x2F; 不知道要暂停的最早和最新的优先级级别。
  earliestPendingTime: ExpirationTime,
  latestPendingTime: ExpirationTime,
  &#x2F;&#x2F; 由已解决的承诺 pinged 的最新优先级级别, 并可以重试
  latestPingedTime: ExpirationTime,

  &#x2F;&#x2F; 如果引发错误, 并且队列中没有其他更新, 我们尝试在处理前再一次从根中渲染错误。
  didError: boolean,

  pendingCommitExpirationTime: ExpirationTime,
  &#x2F;&#x2F; 已完成的工作正在进行的 HostRoot 已准备好提交
  finishedWork: Fiber | null,
  &#x2F;&#x2F; setTimeout 返回的超时句柄。如果它被一个新的取代了。用于取消挂起的超时, 
  timeoutHandle: TimeoutHandle | NoTimeout,
  &#x2F;&#x2F; 顶部上下文对象, 由 renderSubtreeIntoContainer 使用
  context: Object | null,
  pendingContext: Object | null,
  &#x2F;&#x2F; 确定我们是否应该尝试在初始加载使用 hydrate
  +hydrate: boolean,
  &#x2F;&#x2F; 此节点剩余的任务到期时间
  &#x2F;&#x2F; TODO: Lift this into the renderer
  nextExpirationTimeToWorkOn: ExpirationTime,
  expirationTime: ExpirationTime,
  &#x2F;&#x2F; 顶级批次的列表。此列表指示是否应推迟提交，也包含完成回调。
  &#x2F;&#x2F; TODO: Lift this into the renderer
  firstBatch: Batch | null,
  &#x2F;&#x2F; 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot
  nextScheduledRoot: FiberRoot | null,
&#125;;</code></pre><p><strong>创建FiberRoot实例</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export function createFiberRoot(
  containerInfo: any,
  isAsync: boolean,
  hydrate: boolean,
): FiberRoot &#123;
  &#x2F;&#x2F; 创建初始根组件对应的fiber实例
  const uninitializedFiber &#x3D; createHostRootFiber(isAsync);

  let root;
  if (enableSchedulerTracing) &#123;
    root &#x3D; (&#123;
      &#x2F;&#x2F; 根组件对应的fiber实例，一直用它
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,

      interactionThreadID: unstable_getThreadID(),
      memoizedInteractions: new Set(),
      pendingInteractionMap: new Map(),
    &#125;: FiberRoot);
  &#125; else &#123;
    root &#x3D; (&#123;
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,
    &#125;: BaseFiberRootProperties);
  &#125;
  &#x2F;&#x2F; 组件树根组件fiber实例的stateNode指向FiberRoot对象
  uninitializedFiber.stateNode &#x3D; root;

  return ((root: any): FiberRoot);
&#125;

&#x2F;&#x2F; 创建返回一个初始根组件对应的fiber实例
export function createHostRootFiber(isAsync: boolean): Fiber &#123;
  let mode &#x3D; isAsync ? AsyncMode | StrictMode : NoContext;

  if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;
    &#x2F;&#x2F; Always collect profile timings when DevTools are present.
    &#x2F;&#x2F; This enables DevTools to start capturing timing at any point–
    &#x2F;&#x2F; Without some nodes in the tree having empty base times.
    mode |&#x3D; ProfileMode;
  &#125;

  &#x2F;&#x2F; 创建fiber
  return createFiber(HostRoot, null, null, mode);
&#125;</code></pre><h4 id="Fiber对象"><a href="#Fiber对象" class="headerlink" title="Fiber对象"></a>Fiber对象</h4><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiber.js">Fiber对象</a>的定义在<code>packages/react-reconciler/src/ReactFiber.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 一个Fiber对象作用于一个组件
export type Fiber &#x3D; &#123;|
  &#x2F;&#x2F; 标记fiber类型tag
  tag: TypeOfWork,

  &#x2F;&#x2F; 唯一标识
  key: null | string,

  &#x2F;&#x2F; fiber对应的function&#x2F;class&#x2F;module类型组件名.
  type: any,

  &#x2F;&#x2F; fiber所在组件树的根组件FiberRoot对象
  stateNode: any,

  &#x2F;&#x2F; 处理完当前fiber后返回的fiber，
  &#x2F;&#x2F; 返回当前fiber所在fiber树的父级fiber实例
  return: Fiber | null,

  &#x2F;&#x2F; fiber树结构相关链接
  child: Fiber | null,
  sibling: Fiber | null,
  index: number,

  &#x2F;&#x2F; The ref last used to attach this node.
  &#x2F;&#x2F; I&#39;ll avoid adding an owner field for prod and model that as functions.
  ref: null | (((handle: mixed) &#x3D;&gt; void) &amp; &#123;_stringRef: ?string&#125;) | RefObject,

  &#x2F;&#x2F; 当前处理过程中的组件props对象
  pendingProps: any, &#x2F;&#x2F; This type will be more specific once we overload the tag.
  &#x2F;&#x2F; 缓存的之前组件props对象
  memoizedProps: any, &#x2F;&#x2F; The props used to create the output.

  &#x2F;&#x2F; 组件状态更新及对应回调函数的存储队列
  updateQueue: UpdateQueue&lt;any&gt; | null,

  &#x2F;&#x2F; The state used to create the output
  memoizedState: any,

  &#x2F;&#x2F; A linked-list of contexts that this fiber depends on
  firstContextDependency: ContextDependency&lt;mixed&gt; | null,

  &#x2F;&#x2F; Bitfield that describes properties about the fiber and its subtree. E.g.
  &#x2F;&#x2F; the AsyncMode flag indicates whether the subtree should be async-by-
  &#x2F;&#x2F; default. When a fiber is created, it inherits the mode of its
  &#x2F;&#x2F; parent. Additional flags can be set at creation time, but after that the
  &#x2F;&#x2F; value should remain unchanged throughout the fiber&#39;s lifetime, particularly
  &#x2F;&#x2F; before its child fibers are created.
  mode: TypeOfMode,

  &#x2F;&#x2F; Effect
  effectTag: TypeOfSideEffect,

  &#x2F;&#x2F; Singly linked list fast path to the next fiber with side-effects.
  nextEffect: Fiber | null,

  &#x2F;&#x2F; The first and last fiber with side-effect within this subtree. This allows
  &#x2F;&#x2F; us to reuse a slice of the linked list when we reuse the work done within
  &#x2F;&#x2F; this fiber.
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,

  &#x2F;&#x2F; 更新任务的最晚执行时间
  expirationTime: ExpirationTime,

  &#x2F;&#x2F; This is used to quickly determine if a subtree has no pending changes.
  childExpirationTime: ExpirationTime,

  &#x2F;&#x2F; fiber的版本池，即记录fiber更新过程，便于恢复
  alternate: Fiber | null,

  &#x2F;&#x2F; Conceptual aliases  
  &#x2F;&#x2F; workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens  
  &#x2F;&#x2F; to be the same as work in progress.

  &#x2F;&#x2F; Time spent rendering this Fiber and its descendants for the current update.
  &#x2F;&#x2F; This tells us how well the tree makes use of sCU for memoization.
  &#x2F;&#x2F; It is reset to 0 each time we render and only updated when we don&#39;t bailout.
  &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.
  actualDuration?: number,

  &#x2F;&#x2F; If the Fiber is currently active in the &quot;render&quot; phase,
  &#x2F;&#x2F; This marks the time at which the work began.
  &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.
  actualStartTime?: number,

  &#x2F;&#x2F; Duration of the most recent render time for this Fiber.
  &#x2F;&#x2F; This value is not updated when we bailout for memoization purposes.
  &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.
  selfBaseDuration?: number,

  &#x2F;&#x2F; Sum of base times for all descedents of this Fiber.
  &#x2F;&#x2F; This value bubbles up during the &quot;complete&quot; phase.
  &#x2F;&#x2F; This field is only set when the enableProfilerTimer flag is enabled.
  treeBaseDuration?: number,

  &#x2F;&#x2F; Conceptual aliases
  &#x2F;&#x2F; workInProgress : Fiber -&gt;  alternate The alternate used for reuse happens
  &#x2F;&#x2F; to be the same as work in progress.
  &#x2F;&#x2F; __DEV__ only
  _debugID?: number,
  _debugSource?: Source | null,
  _debugOwner?: Fiber | null,
  _debugIsCurrentlyTiming?: boolean,
|&#125;;</code></pre><ol><li>type &amp; key：同React元素的值；</li><li>type：描述fiber对应的React组件；</li><li>对于组合组件：值为function或class组件本身；</li><li>对于原生组件（div等）：值为该元素类型字符串；</li><li>key：调和阶段，标识fiber，以检测是否可重用该fiber实例；</li><li>child &amp; sibling：组件树，对应生成fiber树，类比的关系；</li><li>pendingProps &amp; memoizedProps：分别表示组件当前传入的及之前的props；</li><li>return：返回当前fiber所在fiber树的父级fiber实例，即当前组件的父组件对应的fiber；</li><li>alternate：fiber的版本池，即记录fiber更新过程，便于恢复重用；</li><li>workInProgress：正在处理的fiber，概念上叫法，实际上没有此属性；</li></ol><h5 id="alternate-fiber"><a href="#alternate-fiber" class="headerlink" title="alternate fiber"></a>alternate fiber</h5><p>可以理解为一个fiber版本池，用于交替记录组件更新（切分任务后变成多阶段更新）过程中fiber的更新，因为在组件更新的各阶段，更新前及更新过程中fiber状态并不一致，在需要恢复时（如，发生冲突），即可使用另一者直接回退至上一版本fiber。</p><blockquote><ol><li>使用alternate属性双向连接一个当前fiber和其work-in-progress，当前fiber实例的alternate属性指向其work-in-progress，work-in-progress的alternate属性指向当前稳定fiber；</li><li>当前fiber的替换版本是其work-in-progress，work-in-progress的交替版本是当前fiber；</li><li>当work-in-progress更新一次后，将同步至当前fiber，然后继续处理，同步直至任务完成；</li><li>work-in-progress指向处理过程中的fiber，而当前fiber总是维护处理完成的最新版本的fiber。</li></ol></blockquote><h5 id="创建Fiber实例"><a href="#创建Fiber实例" class="headerlink" title="创建Fiber实例"></a>创建Fiber实例</h5><p>创建fiber实例即返回一个带有上一小节描述的诸多属性的JavaScript对象，FiberNode即根据传入的参数构造返回一个初始化的对象：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const createFiber &#x3D; function(
  tag: TypeOfWork,
  pendingProps: mixed,
  key: null | string,
  mode: TypeOfMode,
): Fiber &#123;
  &#x2F;&#x2F; $FlowFixMe: the shapes are exact here but Flow doesn&#39;t like constructors
  return new FiberNode(tag, pendingProps, key, mode);
&#125;;</code></pre><p>创建alternate fiber以处理任务的实现如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 创建一个alternate fiber处理任务
export function createWorkInProgress(
  current: Fiber,
  pendingProps: any,
  expirationTime: ExpirationTime,
): Fiber &#123;
  let workInProgress &#x3D; current.alternate;
  if (workInProgress &#x3D;&#x3D;&#x3D; null) &#123;
    &#x2F;&#x2F; We use a double buffering pooling technique because we know that we&#39;ll
    &#x2F;&#x2F; only ever need at most two versions of a tree. We pool the &quot;other&quot; unused
    &#x2F;&#x2F; node that we&#39;re free to reuse. This is lazily created to avoid allocating
    &#x2F;&#x2F; extra objects for things that are never updated. It also allow us to
    &#x2F;&#x2F; reclaim the extra memory if needed.
    workInProgress &#x3D; createFiber(
      current.tag,
      pendingProps,
      current.key,
      current.mode,
    );
    workInProgress.type &#x3D; current.type;
    workInProgress.stateNode &#x3D; current.stateNode;

    if (__DEV__) &#123;
      &#x2F;&#x2F; DEV-only fields
      workInProgress._debugID &#x3D; current._debugID;
      workInProgress._debugSource &#x3D; current._debugSource;
      workInProgress._debugOwner &#x3D; current._debugOwner;
    &#125;

    workInProgress.alternate &#x3D; current;
    current.alternate &#x3D; workInProgress;
  &#125; else &#123;
    workInProgress.pendingProps &#x3D; pendingProps;

    &#x2F;&#x2F; We already have an alternate.
    &#x2F;&#x2F; Reset the effect tag.
    workInProgress.effectTag &#x3D; NoEffect;

    &#x2F;&#x2F; The effect list is no longer valid.
    workInProgress.nextEffect &#x3D; null;
    workInProgress.firstEffect &#x3D; null;
    workInProgress.lastEffect &#x3D; null;

    if (enableProfilerTimer) &#123;
      &#x2F;&#x2F; We intentionally reset, rather than copy, actualDuration &amp; actualStartTime.
      &#x2F;&#x2F; This prevents time from endlessly accumulating in new commits.
      &#x2F;&#x2F; This has the downside of resetting values for different priority renders,
      &#x2F;&#x2F; But works for yielding (the common case) and should support resuming.
      workInProgress.actualDuration &#x3D; 0;
      workInProgress.actualStartTime &#x3D; -1;
    &#125;
  &#125;

  &#x2F;&#x2F; Don&#39;t touching the subtree&#39;s expiration time, which has not changed.
  workInProgress.childExpirationTime &#x3D; current.childExpirationTime;
  if (pendingProps !&#x3D;&#x3D; current.pendingProps) &#123;
    &#x2F;&#x2F; This fiber has new props.
    workInProgress.expirationTime &#x3D; expirationTime;
  &#125; else &#123;
    &#x2F;&#x2F; This fiber&#39;s props have not changed.
    workInProgress.expirationTime &#x3D; current.expirationTime;
  &#125;

  workInProgress.child &#x3D; current.child;
  workInProgress.memoizedProps &#x3D; current.memoizedProps;
  workInProgress.memoizedState &#x3D; current.memoizedState;
  workInProgress.updateQueue &#x3D; current.updateQueue;
  workInProgress.firstContextDependency &#x3D; current.firstContextDependency;

  &#x2F;&#x2F; These will be overridden during the parent&#39;s reconciliation
  workInProgress.sibling &#x3D; current.sibling;
  workInProgress.index &#x3D; current.index;
  workInProgress.ref &#x3D; current.ref;

  if (enableProfilerTimer) &#123;
    workInProgress.selfBaseDuration &#x3D; current.selfBaseDuration;
    workInProgress.treeBaseDuration &#x3D; current.treeBaseDuration;
  &#125;

  return workInProgress;
&#125;</code></pre><h4 id="Fiber类型"><a href="#Fiber类型" class="headerlink" title="Fiber类型"></a>Fiber类型</h4><p>上一小节，Fiber对象中有个tag属性，标记fiber类型，而fiber实例是和组件对应的，所以其类型基本上对应于组件类型，在<code>packages/shared/ReactWorkTags.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export type TypeOfWork &#x3D; | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16;

export const FunctionalComponent &#x3D; 0; &#x2F;&#x2F; 函数式组件
export const FunctionalComponentLazy &#x3D; 1;
export const ClassComponent &#x3D; 2; &#x2F;&#x2F; Class类组件
export const ClassComponentLazy &#x3D; 3;
export const IndeterminateComponent &#x3D; 4; &#x2F;&#x2F; Before we know whether it is functional or class
export const HostRoot &#x3D; 5; &#x2F;&#x2F; 组件树根组件，可以嵌套
export const HostPortal &#x3D; 6; &#x2F;&#x2F; 子树。可以是一个入口点不同的渲染器。
export const HostComponent &#x3D; 7; &#x2F;&#x2F; 标准组件，如地div， span等
export const HostText &#x3D; 8; &#x2F;&#x2F; 文本
export const Fragment &#x3D; 9;  &#x2F;&#x2F; 片段
export const Mode &#x3D; 10;
export const ContextConsumer &#x3D; 11;
export const ContextProvider &#x3D; 12;
export const ForwardRef &#x3D; 13;
export const ForwardRefLazy &#x3D; 14;
export const Profiler &#x3D; 15;
export const PlaceholderComponent &#x3D; 16; &#x2F;&#x2F; placeholder（占位符）</code></pre><p>在调度执行任务的时候会根据不同类型fiber，即fiber.tag值进行不同处理。</p><h4 id="FiberRoot对象"><a href="#FiberRoot对象" class="headerlink" title="FiberRoot对象"></a>FiberRoot对象</h4><p>FiberRoot对象，主要用来管理组件树组件的更新进程，同时记录组件树挂载的DOM容器相关信息，在<code>packages/react-reconciler/src/ReactFiberRoot.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export type FiberRoot &#x3D; &#123;
  &#x2F;&#x2F; fiber节点的容器元素相关信息，通常会直接传入容器元素
  containerInfo: any,
  &#x2F;&#x2F; Used only by persistent updates.
  pendingChildren: any,
  &#x2F;&#x2F; 当前fiber树中激活状态（正在处理）的fiber节点，
  current: Fiber,

  &#x2F;&#x2F; The following priority levels are used to distinguish between 1)
  &#x2F;&#x2F; uncommitted work, 2) uncommitted work that is suspended, and 3) uncommitted
  &#x2F;&#x2F; work that may be unsuspended. We choose not to track each individual
  &#x2F;&#x2F; pending level, trading granularity for performance.
  &#x2F;&#x2F;
  &#x2F;&#x2F; The earliest and latest priority levels that are suspended from committing.
  earliestSuspendedTime: ExpirationTime,
  latestSuspendedTime: ExpirationTime,
  &#x2F;&#x2F; The earliest and latest priority levels that are not known to be suspended.
  earliestPendingTime: ExpirationTime,
  latestPendingTime: ExpirationTime,
  &#x2F;&#x2F; The latest priority level that was pinged by a resolved promise and can
  &#x2F;&#x2F; be retried.
  latestPingedTime: ExpirationTime,

  &#x2F;&#x2F; If an error is thrown, and there are no more updates in the queue, we try
  &#x2F;&#x2F; rendering from the root one more time, synchronously, before handling
  &#x2F;&#x2F; the error.
  didError: boolean,

  pendingCommitExpirationTime: ExpirationTime,
  &#x2F;&#x2F; 准备好提交的已处理完成的work-in-progress
  finishedWork: Fiber | null,
  &#x2F;&#x2F; Timeout handle returned by setTimeout. Used to cancel a pending timeout, if
  &#x2F;&#x2F; it&#39;s superseded by a new one.
  timeoutHandle: TimeoutHandle | NoTimeout,
  &#x2F;&#x2F; Top context object, used by renderSubtreeIntoContainer
  context: Object | null,
  pendingContext: Object | null,
  &#x2F;&#x2F; Determines if we should attempt to hydrate on the initial mount
  +hydrate: boolean,
  &#x2F;&#x2F; Remaining expiration time on this root.
  &#x2F;&#x2F; TODO: Lift this into the renderer
  nextExpirationTimeToWorkOn: ExpirationTime,
  expirationTime: ExpirationTime,
  &#x2F;&#x2F; List of top-level batches. This list indicates whether a commit should be
  &#x2F;&#x2F; deferred. Also contains completion callbacks.
  &#x2F;&#x2F; TODO: Lift this into the renderer
  firstBatch: Batch | null,
  &#x2F;&#x2F; 多组件树FirberRoot对象以单链表存储链接，指向下一个需要调度的FiberRoot
  nextScheduledRoot: FiberRoot | null,
&#125;;</code></pre><h5 id="创建FiberRoot实例"><a href="#创建FiberRoot实例" class="headerlink" title="创建FiberRoot实例"></a>创建FiberRoot实例</h5><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123;
  ClassComponent,
  HostRoot,
  Mode,
&#125; from &#39;shared&#x2F;ReactTypeOfWork&#39;;
&#x2F;&#x2F; 创建返回一个初始根组件对应的fiber实例
export function createHostRootFiber(isAsync: boolean): Fiber &#123;
  let mode &#x3D; isAsync ? AsyncMode | StrictMode : NoContext;

  if (enableProfilerTimer &amp;&amp; isDevToolsPresent) &#123;
    &#x2F;&#x2F; Always collect profile timings when DevTools are present.
    &#x2F;&#x2F; This enables DevTools to start capturing timing at any point–
    &#x2F;&#x2F; Without some nodes in the tree having empty base times.
    mode |&#x3D; ProfileMode;
  &#125;
  &#x2F;&#x2F; 创建fiber
  return createFiber(HostRoot, null, null, mode);
&#125;

export function createFiberRoot(
  containerInfo: any,
  isAsync: boolean,
  hydrate: boolean,
): FiberRoot &#123;
  &#x2F;&#x2F; 创建初始根组件对应的fiber实例
  const uninitializedFiber &#x3D; createHostRootFiber(isAsync);
  &#x2F;&#x2F; 组件树根组件的FiberRoot对象
  const root &#x3D; &#123;
    &#x2F;&#x2F; 根组件对应的fiber实例
    current: uninitializedFiber,
    containerInfo: containerInfo,
    pendingChildren: null,

    earliestPendingTime: NoWork,
    latestPendingTime: NoWork,
    earliestSuspendedTime: NoWork,
    latestSuspendedTime: NoWork,
    latestPingedTime: NoWork,

    didError: false,

    pendingCommitExpirationTime: NoWork,
    finishedWork: null,
    timeoutHandle: noTimeout,
    context: null,
    pendingContext: null,
    hydrate,
    nextExpirationTimeToWorkOn: NoWork,
    expirationTime: NoWork,
    firstBatch: null,
    nextScheduledRoot: null,
  &#125;;
  &#x2F;&#x2F; 组件树根组件fiber实例的stateNode指向FiberRoot对象
  uninitializedFiber.stateNode &#x3D; root;
  return root;
&#125;</code></pre><h4 id="ReactChildFiber"><a href="#ReactChildFiber" class="headerlink" title="ReactChildFiber"></a>ReactChildFiber</h4><p>在生成组件树的FiberRoot对象后，会为子组件生成各自的fiber实例，这一部分由<a href="">ReactChildFiber模块</a>实现，在<code>packages/react-reconciler/src/ReactChildFiber.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 调和（处理更新）子fibers
export const reconcileChildFibers &#x3D; ChildReconciler(true);
&#x2F;&#x2F; 挂载（初始化）子fibers
export const mountChildFibers &#x3D; ChildReconciler(false);</code></pre><p>而ChildReconciler方法所做的则是根据传入参数判断是调用初始化子组件fibers逻辑还是执行调和已有子组件fibers逻辑。</p><p>ChildReconciler方法，返回reconcileChildFibers方法：</p><ol><li>判断子级传递内容的数据类型，执行不同的处理，这也对应着我们写React组件时传递props.children时，其类型可以是对象或数组，字符串，是数字等；</li><li>然后具体根据子组件类型，调用不同的具体调和处理函数；</li><li>最后返回根据子组件创建或更新得到的fiber实例；</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">function reconcileChildFibers(
    returnFiber: Fiber,
    currentFirstChild: Fiber | null,
    newChild: any,
    expirationTime: ExpirationTime,
  ): Fiber | null &#123;
    &#x2F;&#x2F; This function is not recursive.
    &#x2F;&#x2F; If the top level item is an array, we treat it as a set of children,
    &#x2F;&#x2F; not as a fragment. Nested arrays on the other hand will be treated as
    &#x2F;&#x2F; fragment nodes. Recursion happens at the normal flow.

    &#x2F;&#x2F; Handle top level unkeyed fragments as if they were arrays.
    &#x2F;&#x2F; This leads to an ambiguity between &lt;&gt;&#123;[...]&#125;&lt;&#x2F;&gt; and &lt;&gt;...&lt;&#x2F;&gt;.
    &#x2F;&#x2F; We treat the ambiguous cases above the same.
    const isUnkeyedTopLevelFragment &#x3D;
      typeof newChild &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp;
      newChild !&#x3D;&#x3D; null &amp;&amp;
      newChild.type &#x3D;&#x3D;&#x3D; REACT_FRAGMENT_TYPE &amp;&amp;
      newChild.key &#x3D;&#x3D;&#x3D; null;
    if (isUnkeyedTopLevelFragment) &#123;
      newChild &#x3D; newChild.props.children;
    &#125;

    &#x2F;&#x2F; Handle object types
    const isObject &#x3D; typeof newChild &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; newChild !&#x3D;&#x3D; null;

    if (isObject) &#123;
      &#x2F;&#x2F; 子组件实例类型，以Symbol符号表示的
      switch (newChild.$$typeof) &#123;
        case REACT_ELEMENT_TYPE:
          return placeSingleChild(
            reconcileSingleElement(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
         &#x2F;&#x2F; React组件调用
        case REACT_PORTAL_TYPE:
          return placeSingleChild(
            reconcileSinglePortal(
              returnFiber,
              currentFirstChild,
              newChild,
              expirationTime,
            ),
          );
      &#125;
    &#125;

    if (typeof newChild &#x3D;&#x3D;&#x3D; &#39;string&#39; || typeof newChild &#x3D;&#x3D;&#x3D; &#39;number&#39;) &#123;
      return placeSingleChild(
        reconcileSingleTextNode(
          returnFiber,
          currentFirstChild,
          &#39;&#39; + newChild,
          expirationTime,
        ),
      );
    &#125;

    if (isArray(newChild)) &#123;
      return reconcileChildrenArray(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    &#125;

    if (getIteratorFn(newChild)) &#123;
      return reconcileChildrenIterator(
        returnFiber,
        currentFirstChild,
        newChild,
        expirationTime,
      );
    &#125;

    if (isObject) &#123;
      throwOnInvalidObjectType(returnFiber, newChild);
    &#125;

    if (__DEV__) &#123;
      if (typeof newChild &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;
        warnOnFunctionType();
      &#125;
    &#125;
    if (typeof newChild &#x3D;&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; !isUnkeyedTopLevelFragment) &#123;
      &#x2F;&#x2F; If the new child is undefined, and the return fiber is a composite
      &#x2F;&#x2F; component, throw an error. If Fiber return types are disabled,
      &#x2F;&#x2F; we already threw above.
      switch (returnFiber.tag) &#123;
        case ClassComponent:
        case ClassComponentLazy: &#123;
          if (__DEV__) &#123;
            const instance &#x3D; returnFiber.stateNode;
            if (instance.render._isMockFunction) &#123;
              &#x2F;&#x2F; We allow auto-mocks to proceed as if they&#39;re returning null.
              break;
            &#125;
          &#125;
        &#125;
        &#x2F;&#x2F; Intentionally fall through to the next case, which handles both
        &#x2F;&#x2F; functions and classes
        &#x2F;&#x2F; eslint-disable-next-lined no-fallthrough
        case FunctionalComponent: &#123;
          const Component &#x3D; returnFiber.type;
          invariant(
            false,
            &#39;%s(...): Nothing was returned from render. This usually means a &#39; +
              &#39;return statement is missing. Or, to render nothing, &#39; +
              &#39;return null.&#39;,
            Component.displayName || Component.name || &#39;Component&#39;,
          );
        &#125;
      &#125;
    &#125;

    &#x2F;&#x2F; Remaining cases are all treated as empty.
    return deleteRemainingChildren(returnFiber, currentFirstChild);
  &#125;

  return reconcileChildFibers;
&#125;</code></pre><h3 id="Fiber架构"><a href="#Fiber架构" class="headerlink" title="Fiber架构"></a>Fiber架构</h3><p>在学习Fiber的时候，我尝试去阅读源码，发现通过这种方式很难快速理解，学习Fiber，而先了解调和器是干什么的及调和器在React中的存在形式，然后再学习Fiber的结构及算法实现思路，明白从组件被定义到渲染至页面它需要做什么，这也是本篇文章的组织形式。</p><h4 id="优先级（ExpirationTime-VS-PriorityLevel）"><a href="#优先级（ExpirationTime-VS-PriorityLevel）" class="headerlink" title="优先级（ExpirationTime VS PriorityLevel）"></a>优先级（ExpirationTime VS PriorityLevel）</h4><p>我们已经知道Fiber可以切分任务并设置不同优先级，那么是如何实现划分优先级的呢，其表现形式什么呢？</p><h5 id="ExpirationTime"><a href="#ExpirationTime" class="headerlink" title="ExpirationTime"></a>ExpirationTime</h5><p>Fiber切分任务并调用requestIdleCallback和requestAnimationFrameAPI，保证渲染任务和其他任务，在不影响应用交互，不掉帧的前提下，稳定执行，而实现调度的方式正是给每一个fiber实例设置到期执行时间，不同时间即代表不同优先级，到期时间越短，则代表优先级越高，需要尽早执行。</p><blockquote><p>所谓的到期时间（ExpirationTime），是相对于调度器初始调用的起始时间而言的一个时间段；调度器初始调用后的某一段时间内，需要调度完成这项更新，这个时间段长度值就是到期时间值。</p></blockquote><p>Fiber提供<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberExpirationTime.js">ReactFiberExpirationTime模块</a>实现到期时间的定义，在<code>packages/react-reconciler/src/ReactFiberExpirationTime.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export const NoWork &#x3D; 0; &#x2F;&#x2F; 没有任务等待处理
export const Sync &#x3D; 1; &#x2F;&#x2F; 同步模式，立即处理任务
export const Never &#x3D; MAX_SIGNED_31_BIT_INT; &#x2F;&#x2F; 1073741823 Max 31: Math.pow(2, 30) - 1 

const UNIT_SIZE &#x3D; 10; &#x2F;&#x2F; 过期时间单元（ms）
const MAGIC_NUMBER_OFFSET &#x3D; 2; &#x2F;&#x2F; 到期时间偏移量

&#x2F;&#x2F; 以ExpirationTime特定单位（1单位&#x3D;10ms）表示的到期执行时间
export function msToExpirationTime(ms: number): ExpirationTime &#123;
  &#x2F;&#x2F; 总是增加一个偏移量，在ms&lt;10时与Nowork模式进行区别
  return ((ms &#x2F; UNIT_SIZE) | 0) + MAGIC_NUMBER_OFFSET;
&#125;

&#x2F;&#x2F; 以毫秒表示的到期执行时间
export function expirationTimeToMs(expirationTime: ExpirationTime): number &#123;
  return (expirationTime - MAGIC_NUMBER_OFFSET) * UNIT_SIZE;
&#125;

&#x2F;&#x2F; 向上取整（整数单位到期执行时间）
&#x2F;&#x2F; precision范围精度：弥补任务执行时间误差
function ceiling(num: number, precision: number): number &#123;
  return (((num &#x2F; precision) | 0) + 1) * precision;
&#125;

&#x2F;&#x2F; 计算处理误差时间在内的到期时间
function computeExpirationBucket(
  currentTime,
  expirationInMs,
  bucketSizeMs,
): ExpirationTime &#123;
  return (
    MAGIC_NUMBER_OFFSET +
    ceiling(
      currentTime - MAGIC_NUMBER_OFFSET + expirationInMs &#x2F; UNIT_SIZE,
      bucketSizeMs &#x2F; UNIT_SIZE,
    )
  );
&#125;

export const LOW_PRIORITY_EXPIRATION &#x3D; 5000;
export const LOW_PRIORITY_BATCH_SIZE &#x3D; 250;

export function computeAsyncExpiration(
  currentTime: ExpirationTime,
): ExpirationTime &#123;
  return computeExpirationBucket(
    currentTime,
    LOW_PRIORITY_EXPIRATION,
    LOW_PRIORITY_BATCH_SIZE,
  );
&#125;

&#x2F;&#x2F; We intentionally set a higher expiration time for interactive updates in
&#x2F;&#x2F; dev than in production.
&#x2F;&#x2F;
&#x2F;&#x2F; If the main thread is being blocked so long that you hit the expiration,
&#x2F;&#x2F; it&#39;s a problem that could be solved with better scheduling.
&#x2F;&#x2F;
&#x2F;&#x2F; People will be more likely to notice this and fix it with the long
&#x2F;&#x2F; expiration time in development.
&#x2F;&#x2F;
&#x2F;&#x2F; In production we opt for better UX at the risk of masking scheduling
&#x2F;&#x2F; problems, by expiring fast.
export const HIGH_PRIORITY_EXPIRATION &#x3D; __DEV__ ? 500 : 150;
export const HIGH_PRIORITY_BATCH_SIZE &#x3D; 100;

export function computeInteractiveExpiration(currentTime: ExpirationTime) &#123;
  return computeExpirationBucket(
    currentTime,
    HIGH_PRIORITY_EXPIRATION,
    HIGH_PRIORITY_BATCH_SIZE,
  );
&#125;
</code></pre><p>该模块提供的功能主要有：</p><ol><li>Sync：同步模式，在UI线程立即执行此类任务，如动画反馈等；</li><li>异步模式：</li><li>转换：到期时间特定单位和时间单位（ms）的相互转换；</li><li>计算：计算包含允许误差在内的到期时间；</li></ol><h5 id="PriorityLevel"><a href="#PriorityLevel" class="headerlink" title="PriorityLevel"></a>PriorityLevel</h5><p>其实在15.x版本中出现了对于任务的优先层级划分，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/react/blob/15.6-dev/src/renderers/shared/fiber/ReactPriorityLevel.js">ReactPriorityLevel模块</a>，在<code>/src/renderers/shared/fiber/ReactPriorityLevel.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export type PriorityLevel &#x3D; 0 | 1 | 2 | 3 | 4 | 5;

module.exports &#x3D; &#123;
  NoWork: 0, &#x2F;&#x2F; No work is pending.
  SynchronousPriority: 1, &#x2F;&#x2F; For controlled text inputs. Synchronous side-effects.
  AnimationPriority: 2, &#x2F;&#x2F; Needs to complete before the next frame.
  HighPriority: 3, &#x2F;&#x2F; Interaction that needs to complete pretty soon to feel responsive.
  LowPriority: 4, &#x2F;&#x2F; Data fetching, or result from updating stores.
  OffscreenPriority: 5, &#x2F;&#x2F; Won&#39;t be visible but do the work in case it becomes visible.
&#125;;</code></pre><p>相对于PriorityLevel的简单层级划分，在16.x版本中使用的则是ExpirationTime的到期时间方式表示任务的优先级，可以更好的对任务进行切分，调度。</p><h4 id="调度器（Scheduler）"><a href="#调度器（Scheduler）" class="headerlink" title="调度器（Scheduler）"></a>调度器（Scheduler）</h4><p>前面介绍调和器主要作用就是在组件状态变更时，调用组件树各组件的render方法，渲染，卸载组件，而Fiber使得应用可以更好的协调不同任务的执行，调和器内关于高效协调的实现，我们可以称它为调度器（Scheduler）。</p><blockquote><p>顾名思义，调度器即调度资源以执行指定任务，React应用中应用组件的更新与渲染，需要占用系统CPU资源，如果不能很好的进行资源平衡，合理调度，优化任务执行策略，那很容易造成CPU这一紧缺资源的消耗和浪费，容易造成页面卡顿，动画掉帧，组件更新异常等诸多问题，就像城市交通调度一样，如果不能有效调度，交通状况很可能将拥堵不堪。</p></blockquote><p>在React 15.x版本中，组件的状态变更将直接导致其子组件树的重新渲染，新版本Fiber算法将在调度器方面进行全面改进，主要的关注点是：</p><ol><li>合并多次更新：没有必要在组件的每一个状态变更时都立即触发更新任务，有些中间状态变更其实是对更新任务所耗费资源的浪费，就比如用户发现错误点击时快速操作导致组件某状态从A至B再至C，这中间的B状态变更其实对于用户而言并没有意义，那么我们可以直接合并状态变更，直接从A至C只触发一次更新；</li><li>任务优先级：不同类型的更新有不同优先级，例如用户操作引起的交互动画可能需要有更好的体验，其优先级应该比完成数据更新高；</li><li>推拉式调度：基于推送的调度方式更多的需要开发者编码间接决定如何调度任务，而拉取式调度更方便React框架层直接进行全局自主调度；</li></ol><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js">源码</a>在<code>packages/react-reconciler/src/ReactFiberScheduler.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">export &#123;
  requestCurrentTime,
  computeExpirationForFiber,
  captureCommitPhaseError,
  onUncaughtError,
  renderDidSuspend,
  renderDidError,
  retrySuspendedRoot,
  markLegacyErrorBoundaryAsFailed,
  isAlreadyFailedLegacyErrorBoundary,
  scheduleWork,
  requestWork,
  flushRoot,
  batchedUpdates,
  unbatchedUpdates,
  flushSync,
  flushControlled,
  deferredUpdates,
  syncUpdates,
  interactiveUpdates,
  flushInteractiveUpdates,
  computeUniqueAsyncExpiration,
&#125;;</code></pre><p>如上调度器主要输出API为实现调度任务，拉取更新，延迟更新等功能。</p><h5 id="调度器与优先级"><a href="#调度器与优先级" class="headerlink" title="调度器与优先级"></a>调度器与优先级</h5><p>调度器如何切分任务划分优先级的呢？在React调和算法中，任务由fiber实例描述，所以要划分任务优先级，等效于设置fiber的到期时间（expirationTime），调度器内提供了computeExpirationForFiber方法以计算某一个fiber的到期时间，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactFiberScheduler.js">源码</a>在<code>packages/react-reconciler/src/ReactFiberScheduler.js</code>中：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123;
  NoWork,
  Sync,
  Never,
  msToExpirationTime,
  expirationTimeToMs,
  computeAsyncExpiration,
  computeInteractiveExpiration,
&#125; from &#39;.&#x2F;ReactFiberExpirationTime&#39;;

function computeExpirationForFiber(currentTime: ExpirationTime, fiber: Fiber) &#123;
  let expirationTime;
  if (expirationContext !&#x3D;&#x3D; NoWork) &#123;
    &#x2F;&#x2F; An explicit expiration context was set;
    expirationTime &#x3D; expirationContext;
  &#125; else if (isWorking) &#123;
    if (isCommitting) &#123;
      &#x2F;&#x2F; 在提交阶段的更新任务 需要明确设置同步优先级（Sync Priority）
      expirationTime &#x3D; Sync;
    &#125; else &#123;
      &#x2F;&#x2F; 在渲染阶段发生的更新任务
      &#x2F;&#x2F; 需要设置为下一次渲染时间的到期时间优先级
      expirationTime &#x3D; nextRenderExpirationTime;
    &#125;
  &#125; else &#123;
    &#x2F;&#x2F; No explicit expiration context was set, and we&#39;re not currently
    &#x2F;&#x2F; performing work. Calculate a new expiration time.
    if (fiber.mode &amp; AsyncMode) &#123;
      if (isBatchingInteractiveUpdates) &#123;
        &#x2F;&#x2F; This is an interactive update
        expirationTime &#x3D; computeInteractiveExpiration(currentTime);
      &#125; else &#123;
        &#x2F;&#x2F; This is an async update
        expirationTime &#x3D; computeAsyncExpiration(currentTime);
      &#125;
      &#x2F;&#x2F; If we&#39;re in the middle of rendering a tree, do not update at the same
      &#x2F;&#x2F; expiration time that is already rendering.
      if (nextRoot !&#x3D;&#x3D; null &amp;&amp; expirationTime &#x3D;&#x3D;&#x3D; nextRenderExpirationTime) &#123;
        expirationTime +&#x3D; 1;
      &#125;
    &#125; else &#123;
      &#x2F;&#x2F; 同步更新，设置为同步标记
      expirationTime &#x3D; Sync;
    &#125;
  &#125;
  if (isBatchingInteractiveUpdates) &#123;
    &#x2F;&#x2F; This is an interactive update. Keep track of the lowest pending
    &#x2F;&#x2F; interactive expiration time. This allows us to synchronously flush
    &#x2F;&#x2F; all interactive updates when needed.
    if (
      lowestPendingInteractiveExpirationTime &#x3D;&#x3D;&#x3D; NoWork ||
      expirationTime &gt; lowestPendingInteractiveExpirationTime
    ) &#123;
      lowestPendingInteractiveExpirationTime &#x3D; expirationTime;
    &#125;
  &#125;
  return expirationTime;
&#125;</code></pre><ol><li>若当前处于任务提交阶段（更新提交至DOM渲染）时，设置当前fiber到期时间为Sync，即同步执行模式；</li><li>若处于DOM渲染阶段时，则需要延迟此fiber任务，将fiber到期时间设置为下一次DOM渲染到期时间；</li><li>若不在任务执行阶段，则需重新设置fiber到期时间：</li><li>若明确设置useSyncScheduling且fiber.internalContextTag值不等于AsyncUpdates，则表明是同步模式，设置为Sync；</li><li>否则，调用computeAsyncExpiration方法重新计算此fiber的到期时间；</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 重新计算当前时间（ExpirationTime单位表示）
function recalculateCurrentTime() &#123;  
  const ms &#x3D; now() - startTime;  
  &#x2F;&#x2F; ExpirationTime单位表示的当前时间  
  &#x2F;&#x2F; 时间段值为 now() - startTime（起始时间）  
  mostRecentCurrentTime &#x3D; msToExpirationTime(ms);  
  return mostRecentCurrentTime;
&#125; 

&#x2F;&#x2F; 计算异步任务的到期时间
function computeAsyncExpiration() &#123;  
  &#x2F;&#x2F; 计算得到ExpirationTime单位的当前时间  
  &#x2F;&#x2F; 聚合相似的更新在一起  
  &#x2F;&#x2F; 更新应该在 ~1000ms，最多1200ms内完成  
  const currentTime &#x3D; recalculateCurrentTime();  
  &#x2F;&#x2F; 对于每个fiber的期望到期时间的增值，最大值为1000ms 
  const expirationMs &#x3D; 1000;  
  &#x2F;&#x2F; 到期时间的可接受误差时间，200ms 
  const bucketSizeMs &#x3D; 200;  
  &#x2F;&#x2F; 返回包含误差时间在内的到期时间  
  return computeExpirationBucket(currentTime, expirationMs, bucketSizeMs);
&#125;
</code></pre><p>对于每一个fiber我们期望的到期时间参数是1000ms，另外由于任务执行时间误差，接受200ms误差，最后计算得到的到期时间默认返回值为ExpirationTime单位。</p><h5 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h5><p>上一节介绍了调度器主要提供computeExpirationForFiber等方法支持计算任务优先级（到期时间），接下来介绍调度器如何调度任务。</p><blockquote><p>React应用更新时，Fiber从当前处理节点，层层遍历至组件树根组件，然后开始处理更新，调用前面的requestIdleCallback等API执行更新处理。</p></blockquote><p>主要调度逻辑实现在scheduleWork：</p><ol><li>通过fiber.return属性，从当前fiber实例层层遍历至组件树根组件；</li><li>依次对每一个fiber实例进行到期时间判断，若大于传入的期望任务到期时间参数，则将其更新为传入的任务到期时间；</li><li>调用requestWork方法开始处理任务，并传入获取的组件树根组件FiberRoot对象和任务到期时间；</li></ol><pre class="line-numbers language-js" data-language="js"><code class="language-js"></code></pre><h3 id="渲染与调和"><a href="#渲染与调和" class="headerlink" title="渲染与调和"></a>渲染与调和</h3><p>在调和阶段，不涉及任何DOM处理，在处理完更新后，需要渲染模块将更新渲染至DOM，这也是React应用中虚拟DOM（Virtual DOM）的概念，即所有的更新计算都基于虚拟DOM，计算完后才将优化后的更新渲染至真实DOM。Fiber使用requestIdleCallbackAPI更高效的执行渲染更新的任务，实现任务的切分。</p><h2 id="本文不断更新中"><a href="#本文不断更新中" class="headerlink" title="本文不断更新中"></a>本文不断更新中</h2></div><div class="post-footer"><div></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/blog/2018/08/16292.html" class="pre-post btn btn-default" title="Vue 源码全方位剖析"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">Vue 源码全方位剖析</span> </a><a href="/blog/2018/08/61025.html" class="next-post btn btn-default" title="Mac OS系统使用指南"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">Mac OS系统使用指南</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><p>评论系统未开启，无法评论！</p></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2669241897" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></main><aside class="col-md-4 sidebar"><div class="widget"><h3 class="title">赞助广告</h3><ins class="adsbygoogle" style="display:block;width:100%;height:280px" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2014094445" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><p style="text-align:center">想要出现再此！</p></div><div class="widget"><h3 class="title">分类</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/category/Mac-OS/"><i class="fa" aria-hidden="true">Mac OS</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Nuxtjs/"><i class="fa" aria-hidden="true">Nuxtjs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Objective-C/"><i class="fa" aria-hidden="true">Objective-C</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/babel/"><i class="fa" aria-hidden="true">babel</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/css/"><i class="fa" aria-hidden="true">css</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/danger/"><i class="fa" aria-hidden="true">danger</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/data-structure/"><i class="fa" aria-hidden="true">data structure</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/design/"><i class="fa" aria-hidden="true">design</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es6/"><i class="fa" aria-hidden="true">es6</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es7/"><i class="fa" aria-hidden="true">es7</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/eslint/"><i class="fa" aria-hidden="true">eslint</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/flutter/"><i class="fa" aria-hidden="true">flutter</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/git/"><i class="fa" aria-hidden="true">git</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/github/"><i class="fa" aria-hidden="true">github</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/golang/"><i class="fa" aria-hidden="true">golang</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/http/"><i class="fa" aria-hidden="true">http</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/java/"><i class="fa" aria-hidden="true">java</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/javascript/"><i class="fa" aria-hidden="true">javascript</i></a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/jest/"><i class="fa" aria-hidden="true">jest</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/koa/"><i class="fa" aria-hidden="true">koa</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/lerna/"><i class="fa" aria-hidden="true">lerna</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/linux/"><i class="fa" aria-hidden="true">linux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/mysql/"><i class="fa" aria-hidden="true">mysql</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/netlify/"><i class="fa" aria-hidden="true">netlify</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nginx/"><i class="fa" aria-hidden="true">nginx</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nodejs/"><i class="fa" aria-hidden="true">nodejs</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/npm/"><i class="fa" aria-hidden="true">npm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/programm/"><i class="fa" aria-hidden="true">programm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/react/"><i class="fa" aria-hidden="true">react</i></a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux/"><i class="fa" aria-hidden="true">redux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux-thunk/"><i class="fa" aria-hidden="true">redux-thunk</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/regex/"><i class="fa" aria-hidden="true">regex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/rollup/"><i class="fa" aria-hidden="true">rollup</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/shell/"><i class="fa" aria-hidden="true">shell</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/sketch/"><i class="fa" aria-hidden="true">sketch</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/the-super-tiny-compiler/"><i class="fa" aria-hidden="true">the-super-tiny-compiler</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/threejs/"><i class="fa" aria-hidden="true">threejs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/typescript/"><i class="fa" aria-hidden="true">typescript</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vscode/"><i class="fa" aria-hidden="true">vscode</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue/"><i class="fa" aria-hidden="true">vue</i></a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue-router/"><i class="fa" aria-hidden="true">vue-router</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vuex/"><i class="fa" aria-hidden="true">vuex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/webpack/"><i class="fa" aria-hidden="true">webpack</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/wechat/"><i class="fa" aria-hidden="true">wechat</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link current" href="/blog/category/%E5%89%8D%E7%AB%AF/"><i class="fa" aria-hidden="true">前端</i></a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%90%8E%E7%AB%AF/"><i class="fa" aria-hidden="true">后端</i></a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"><i class="fa" aria-hidden="true">建站教程</i></a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="fa" aria-hidden="true">数据库</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%9D%82%E8%B0%88/"><i class="fa" aria-hidden="true">杂谈</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%A7%91%E6%8A%80%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A-%E9%98%AE%E4%B8%80%E5%B3%B0/"><i class="fa" aria-hidden="true">科技爱好者周刊(阮一峰)</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"><i class="fa" aria-hidden="true">编程之道</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><i class="fa" aria-hidden="true">软件工具</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><i class="fa" aria-hidden="true">软件设计</i></a><span class="category-list-count">16</span></li></ul></div><div class="widget"><h3 class="title">归档</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/03/"><i class="fa" aria-hidden="true">2020年03月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/01/"><i class="fa" aria-hidden="true">2020年01月</i></a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/12/"><i class="fa" aria-hidden="true">2019年12月</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/11/"><i class="fa" aria-hidden="true">2019年11月</i></a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/08/"><i class="fa" aria-hidden="true">2019年08月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/07/"><i class="fa" aria-hidden="true">2019年07月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/04/"><i class="fa" aria-hidden="true">2019年04月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/03/"><i class="fa" aria-hidden="true">2019年03月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/02/"><i class="fa" aria-hidden="true">2019年02月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/01/"><i class="fa" aria-hidden="true">2019年01月</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/12/"><i class="fa" aria-hidden="true">2018年12月</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/11/"><i class="fa" aria-hidden="true">2018年11月</i></a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/10/"><i class="fa" aria-hidden="true">2018年10月</i></a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/09/"><i class="fa" aria-hidden="true">2018年09月</i></a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/08/"><i class="fa" aria-hidden="true">2018年08月</i></a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/07/"><i class="fa" aria-hidden="true">2018年07月</i></a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/06/"><i class="fa" aria-hidden="true">2018年06月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/05/"><i class="fa" aria-hidden="true">2018年05月</i></a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/04/"><i class="fa" aria-hidden="true">2018年04月</i></a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/03/"><i class="fa" aria-hidden="true">2018年03月</i></a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><h3 class="title">标签云</h3><div class="content tag-cloud"><a href="/blog/tagged/Apache/" style="font-size:13.33px">Apache</a> <a href="/blog/tagged/CPU%E7%BC%93%E5%AD%98/" style="font-size:10px">CPU缓存</a> <a href="/blog/tagged/CSS/" style="font-size:10px">CSS</a> <a href="/blog/tagged/Cryptojs/" style="font-size:10px">Cryptojs</a> <a href="/blog/tagged/DevOps/" style="font-size:10px">DevOps</a> <a href="/blog/tagged/Equality-operator/" style="font-size:10px">Equality operator</a> <a href="/blog/tagged/Fenix/" style="font-size:10px">Fenix</a> <a href="/blog/tagged/Git/" style="font-size:10px">Git</a> <a href="/blog/tagged/GitLab-CI/" style="font-size:10px">GitLab CI</a> <a href="/blog/tagged/Google/" style="font-size:10px">Google</a> <a href="/blog/tagged/JAVA-HOME/" style="font-size:10px">JAVA_HOME</a> <a href="/blog/tagged/JPA/" style="font-size:10px">JPA</a> <a href="/blog/tagged/Java/" style="font-size:20px">Java</a> <a href="/blog/tagged/JavaScript/" style="font-size:14.44px">JavaScript</a> <a href="/blog/tagged/Jenkins/" style="font-size:10px">Jenkins</a> <a href="/blog/tagged/Linux/" style="font-size:13.33px">Linux</a> <a href="/blog/tagged/MVEL/" style="font-size:11.11px">MVEL</a> <a href="/blog/tagged/Markdown/" style="font-size:10px">Markdown</a> <a href="/blog/tagged/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/blog/tagged/React-Fire/" style="font-size:10px">React Fire</a> <a href="/blog/tagged/Semicolon/" style="font-size:10px">Semicolon</a> <a href="/blog/tagged/Spring/" style="font-size:11.11px">Spring</a> <a href="/blog/tagged/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/blog/tagged/Typora/" style="font-size:10px">Typora</a> <a href="/blog/tagged/UML/" style="font-size:11.11px">UML</a> <a href="/blog/tagged/Vue/" style="font-size:10px">Vue</a> <a href="/blog/tagged/ajax/" style="font-size:10px">ajax</a> <a href="/blog/tagged/analysis-package/" style="font-size:10px">analysis package</a> <a href="/blog/tagged/async/" style="font-size:10px">async</a> <a href="/blog/tagged/cheerio/" style="font-size:10px">cheerio</a> <a href="/blog/tagged/commit-message/" style="font-size:10px">commit message</a> <a href="/blog/tagged/communication/" style="font-size:10px">communication</a> <a href="/blog/tagged/component/" style="font-size:10px">component</a> <a href="/blog/tagged/currying/" style="font-size:10px">currying</a> <a href="/blog/tagged/decorator/" style="font-size:10px">decorator</a> <a href="/blog/tagged/fiber/" style="font-size:10px">fiber</a> <a href="/blog/tagged/fix-bug/" style="font-size:10px">fix bug</a> <a href="/blog/tagged/function/" style="font-size:10px">function</a> <a href="/blog/tagged/git-clone/" style="font-size:10px">git clone</a> <a href="/blog/tagged/golang/" style="font-size:10px">golang</a> <a href="/blog/tagged/hexo/" style="font-size:14.44px">hexo</a> <a href="/blog/tagged/hooks/" style="font-size:10px">hooks</a> <a href="/blog/tagged/http/" style="font-size:10px">http</a> <a href="/blog/tagged/justify/" style="font-size:10px">justify</a> <a href="/blog/tagged/let/" style="font-size:10px">let</a> <a href="/blog/tagged/login/" style="font-size:10px">login</a> <a href="/blog/tagged/module/" style="font-size:11.11px">module</a> <a href="/blog/tagged/nginx/" style="font-size:11.11px">nginx</a> <a href="/blog/tagged/note/" style="font-size:18.89px">note</a> <a href="/blog/tagged/npm/" style="font-size:11.11px">npm</a> <a href="/blog/tagged/npx/" style="font-size:10px">npx</a> <a href="/blog/tagged/open/" style="font-size:10px">open</a> <a href="/blog/tagged/package/" style="font-size:10px">package</a> <a href="/blog/tagged/package-json/" style="font-size:10px">package.json</a> <a href="/blog/tagged/path/" style="font-size:10px">path</a> <a href="/blog/tagged/pm2/" style="font-size:11.11px">pm2</a> <a href="/blog/tagged/promise/" style="font-size:10px">promise</a> <a href="/blog/tagged/refs/" style="font-size:10px">refs</a> <a href="/blog/tagged/rem/" style="font-size:10px">rem</a> <a href="/blog/tagged/render/" style="font-size:10px">render</a> <a href="/blog/tagged/require/" style="font-size:10px">require</a> <a href="/blog/tagged/rzero/" style="font-size:10px">rzero</a> <a href="/blog/tagged/selector/" style="font-size:10px">selector</a> <a href="/blog/tagged/service/" style="font-size:10px">service</a> <a href="/blog/tagged/setTimeout/" style="font-size:10px">setTimeout</a> <a href="/blog/tagged/source/" style="font-size:16.67px">source</a> <a href="/blog/tagged/ssh/" style="font-size:10px">ssh</a> <a href="/blog/tagged/ssr/" style="font-size:10px">ssr</a> <a href="/blog/tagged/timer/" style="font-size:10px">timer</a> <a href="/blog/tagged/tools/" style="font-size:10px">tools</a> <a href="/blog/tagged/tree-shaking/" style="font-size:10px">tree-shaking</a> <a href="/blog/tagged/typecho/" style="font-size:15.56px">typecho</a> <a href="/blog/tagged/typecho%E6%8F%92%E4%BB%B6/" style="font-size:15.56px">typecho插件</a> <a href="/blog/tagged/types/" style="font-size:10px">types</a> <a href="/blog/tagged/utils/" style="font-size:10px">utils</a> <a href="/blog/tagged/virtual-dom/" style="font-size:10px">virtual dom</a> <a href="/blog/tagged/vscode/" style="font-size:10px">vscode</a> <a href="/blog/tagged/wasm/" style="font-size:13.33px">wasm</a> <a href="/blog/tagged/webassembly/" style="font-size:13.33px">webassembly</a> <a href="/blog/tagged/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size:10px">位运算</a> <a href="/blog/tagged/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size:11.11px">单元测试</a> <a href="/blog/tagged/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" style="font-size:10px">性能测试</a> <a href="/blog/tagged/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/" style="font-size:10px">整洁代码</a> <a href="/blog/tagged/%E6%B5%8B%E8%AF%95/" style="font-size:10px">测试</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size:10px">设计原则</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:17.78px">设计模式</a> <a href="/blog/tagged/%E9%87%8D%E6%9E%84/" style="font-size:10px">重构</a> <a href="/blog/tagged/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" style="font-size:12.22px">面向对象编程</a></div></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi"></div></div><div class="col-sm-12"><span>Copyright &copy; 2021 - 2022 Liuxfe</span></div></div></div></div><script src="/js/app.js?rev=@@hash.js"></script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?bc24c40486ac78730f85549d164dac6f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-195431371-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-195431371-1")</script></body></html>