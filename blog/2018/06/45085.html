<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Liuxfe的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="keywords" content="note"><meta name="description" content="教程React v16北京时间2017
组件复用Mixin 混入模式最原始的一种复用方式应该就是 Mixin。通过将公用逻辑封装为一个 Mixin，通过注入的方式进行组件间的复用。「ps: 该方..."><title>react 开发汇总 | Liuxfe的博客</title><link rel="icon" href="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css"><link rel="stylesheet" href="/css/style.css?rev=@@hash.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9312750344484857" crossorigin="anonymous"></script></head><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Liuxfe"><img src="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>-------------</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="https://www.liuxfe.com">Liuxfe的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i> 首页</a></li><li role="presentation" class="text-center"><a href="/blog/"><i class="fa"></i> 博客</a></li><li role="presentation" class="text-center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://link.liuxfe.com/GlreA"><i class="fa"></i> 维基镜像</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="react 开发汇总">react 开发汇总</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="/blog/category/react/">react</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-none-link" href="/blog/tagged/note/" rel="tag">note</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2018/06/12</span></span></div><p class="fa fa-exclamation-triangle warning">本文于<strong> 1932</strong> 天之前发表，文中内容可能已经过时。</p></div><div class="post-body post-content"><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><h3 id="React-v16"><a href="#React-v16" class="headerlink" title="React v16"></a>React v16</h3><p>北京时间2017</p><h3 id="组件复用"><a href="#组件复用" class="headerlink" title="组件复用"></a>组件复用</h3><h4 id="Mixin-混入模式"><a href="#Mixin-混入模式" class="headerlink" title="Mixin 混入模式"></a>Mixin 混入模式</h4><p>最原始的一种复用方式应该就是 Mixin。通过将公用逻辑封装为一个 Mixin，通过注入的方式进行组件间的复用。「ps: 该方式不仅用于组件，也流行于各种 css 预处理器中」。</p><p>在 React 中，通过<code>React.createClass()</code>方式创建的组件可使用 Mixin 模式，而在 ES6 的伪类模式下，并不支持 Mixin 模式，官方推荐用组合或者高阶组件方式实现复用，废话不多说，使用方式如下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F;mixin
const mixinPart &#x3D; &#123;
  mixinFunc() &#123;
    console.log(&#39;this mixin!&#39;);
    return &#39;this mixin!&#39;;
  &#125;
&#125;;

const Contacts &#x3D; React.createClass(&#123;
  mixins: [mixinPart],
  render() &#123;
    return (
      &lt;div&gt;&#123;this.mixinFunc()&#125;&lt;&#x2F;div&gt;
    );
  &#125;
&#125;);
&#x2F;&#x2F; &#x3D;&gt; &#39;this mixin!&#39;;</code></pre><p>而在 Vue 中，使用逻辑类似：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F;mixin
const mixinPart &#x3D; &#123;
  created() &#123;
    console.log(&#39;this mixin!&#39;);
    return &#39;this mixin!&#39;;
  &#125;
&#125;;

const Component &#x3D; Vue.extend(&#123;
  mixins: [mixinPart]
&#125;);
const component &#x3D; new Component(); &#x2F;&#x2F; &#x3D;&gt; &quot;this mixin!&quot;</code></pre><p>Mixin 模式给予组件公共抽象与复用能力，但另一方面也具有大量的局限性。由于 Mixin 是侵入式的，因此修改了 Mixin 相当于修改了原组件。其次，在混入过程中，对于相同键值对象与函数的相互覆盖与合并，容易导致各种意外产生。因此使用过程中必须对 Mixin 内部实现有一定了解。强大的灵活性导致了在大型项目中 Mixin 的难维护。</p><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>高阶组件（High Order Component）这个概念最早是 React 社区提出，借鉴函数式中的高阶函数，提出通过传入一个组件，操作后返回一个新组件的方式进行复用。</p><p>在 React 中的使用非常便捷，官方博客中就有相关介绍：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const HOC &#x3D; (WrappedComponent) &#x3D;&gt; &#123;
  const HOC_Component &#x3D; (props) &#x3D;&gt; &#123;
    return (
      &lt;React.Fragment&gt;
        &lt;WrappedComponent &#123;...props&#125; name&#x3D;&quot;WrappedComponent&quot; &#x2F;&gt;
        &lt;div&gt;This comes from HOC Component&lt;&#x2F;div&gt;
      &lt;&#x2F;React.Fragment&gt;
    );
  &#125;;
  HOC_Component.displayName &#x3D; &#39;HOC_Component&#39;;
  return HOC_Component;
&#125;
const Component &#x3D; (props) &#x3D;&gt; &#123;
  return &lt;div&gt;This message comes from Component: &#123;props.name&#125;&lt;&#x2F;div&gt;;
&#125;
const Result &#x3D; HOC(Component);
ReactDOM.render(&lt;Result &#x2F;&gt;, document.getElementById(&#39;root&#39;));
&#x2F;&#x2F; &#x3D;&gt; This message comes from Component: WrappedComponent
&#x2F;&#x2F; &#x3D;&gt; This comes from HOC Component</code></pre><p>Vue 虽然没有官方示例，但与 React 进行类比，Vue 中的组件最终的展现形式是函数，但在过程中，实际上是一个个对象。因此，Vue 中的高阶组件，应当是传入一个对象，最后传出一个对应对象。我们可以简单实现个上例对应的 HOC 功能：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const HOC &#x3D; (WrappedComponent) &#x3D;&gt; &#123;
  const HOC_Component &#x3D; (props) &#x3D;&gt; &#123;
    return (
      &lt;React.Fragment&gt;
        &lt;WrappedComponent &#123;...props&#125; name&#x3D;&quot;WrappedComponent&quot; &#x2F;&gt;
        &lt;div&gt;This comes from HOC Component&lt;&#x2F;div&gt;
      &lt;&#x2F;React.Fragment&gt;
    );
  &#125;;
  HOC_Component.displayName &#x3D; &#39;HOC_Component&#39;;
  return HOC_Component;
&#125;
const Component &#x3D; (props) &#x3D;&gt; &#123;
  return &lt;div&gt;This message comes from Component: &#123;props.name&#125;&lt;&#x2F;div&gt;;
&#125;
const Result &#x3D; HOC(Component);
ReactDOM.render(&lt;Result &#x2F;&gt;, document.getElementById(&#39;root&#39;));
&#x2F;&#x2F; &#x3D;&gt; This message comes from Component: WrappedComponent
&#x2F;&#x2F; &#x3D;&gt; This comes from HOC Component</code></pre><p>Vue 虽然没有官方示例，但与 React 进行类比，Vue 中的组件最终的展现形式是函数，但在过程中，实际上是一个个对象。因此，Vue 中的高阶组件，应当是传入一个对象，最后传出一个对应对象。我们可以简单实现个上例对应的 HOC 功能：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const HOC &#x3D; (WrappedComponent) &#x3D;&gt; &#123;
    return &#123;
        components: &#123;
            &#39;wrapped-component&#39;: WrappedComponent
        &#125;,
        template: &#96;
          &lt;div&gt;
              &lt;wrapped-component name&#x3D;&quot;WrappedComponent&quot; v-bind&#x3D;&quot;$attrs&quot; &#x2F;&gt;
              &lt;div&gt;This comes from HOC Component&lt;&#x2F;div&gt;
            &lt;&#x2F;div&gt;
          &#96;
    &#125;;
&#125;
const Component &#x3D; &#123;
    props: [&#39;name&#39;],
    template: &#39;&lt;div&gt;This message comes from Component: &#123;&#123; name &#125;&#125;&lt;&#x2F;div&gt;&#39;
&#125;;

new Vue(HOC(Component)).$mount(&#39;#root&#39;)
&#x2F;&#x2F; &#x3D;&gt; This message comes from Component: WrappedComponent
&#x2F;&#x2F; &#x3D;&gt; This comes from HOC Component</code></pre><p>高阶组件用途十分广泛，主要可以分为<strong>属性代理</strong>和<strong>反向继承</strong>两种。<br>属性代理具体为高阶组件可以直接获取外部传入的参数，根据需求完成变更后重新传给被包含的组件。如上例中就在原始<code>props</code>基础上为<code>WrappedComponent</code>增加了一个<code>name</code>属性，同时在原始渲染基础上增添了一行信息渲染。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F; 最基本的反向继承
const HOC &#x3D; (WrappedComponent) &#x3D;&gt; &#123;
  return class extends WrappedComponent &#123;
    render() &#123;
      return super.render();
    &#125;
  &#125;
&#125;</code></pre><p>反向继承因为继承于 WrappedComponent，因而能够获取其 state, render 等各种组件数据，从而做到对组件的渲染和 state 状态等的干预。反向继承虽然在日常使用中遇到情况较少，但无疑是高阶组件中笔者认为的一个闪光点 ( 貌似其它方式中暂时没有可以替代的方案 )。例如，在 Vue 中有着 keep-alive 作为组件缓存，而在 React 中官方暂无类似功能，应用 data =&gt; view 的原则，一个常用的替代实现是进行状态保存，然后在需要的时候进行状态还原，在这种情况下，反向继承就是一个很好的工具。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const withStateCached &#x3D; (WrappedComponent) &#x3D;&gt; &#123;
  return class extends WrappedComponent &#123;
    static getDerivedStateFromProps(nextProps, state) &#123;
      &#x2F;&#x2F; 进行数据的存储等
    &#125;

    componentDidMount() &#123;
      &#x2F;&#x2F; 进行缓存数据的读取
    &#125;

    render() &#123;
      return super.render();
    &#125;
  &#125;
&#125;</code></pre><p>在笔者的实际项目中，更多的把高阶组件看作是一个组件工厂或者装饰者模式的应用，例如对一个基础表格元素进行多次的高阶组件的包装，添加分页、工具栏等功能，形成一个个更符合具体业务需求的新组件，达到组件复用的目的。当然，高阶组件也不是全能的，首先其对于业务耦合度较高，更适合封装一些日常业务中常用的组件。其次最重要的弊端是因为内部产生的的 Props 值固定，容易被外部传入值覆盖。如例子中，当外部也传入了一个 name 属性值时，就会根据组件的写法产生不同的覆盖方式而导致错误。</p><h4 id="渲染属性-函数子组件"><a href="#渲染属性-函数子组件" class="headerlink" title="渲染属性/函数子组件"></a>渲染属性/函数子组件</h4><p>为了解决高阶组件存在的问题，一种新的「Render Props」的方案被提出。该方案提供了一个叫做 render 的函数作为 Props 参数传入，在内部处理完毕后，将所需的组件信息，数据作为 render 的参数传出，从而实现更加灵活的复用逻辑。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const RenderProps &#x3D; (&#123; render, ...props &#125;) &#x3D;&gt; render(props, &#39;RenderPropComponent&#39;);
const Component &#x3D; () &#x3D;&gt; (
    &lt;RenderProps
        render&#x3D;&#123;(originProps, componentName) &#x3D;&gt; (&lt;div&gt;From &#123;componentName&#125;&lt;&#x2F;div&gt;)&#125;
    &#x2F;&gt;
);

ReactDOM.render(&lt;Component &#x2F;&gt;, document.getElementById(&#39;root&#39;));
&#x2F;&#x2F; &#x3D;&gt; From RenderPropComponent</code></pre><p>在该例中，我们通过 render 函数传入了原 Props 和一个新的 name 属性，在实际使用中，重新命名 name 为 componentName，由此避开了高阶组件的弊端。</p><p>由此理念，在 React 中，延伸出函数子组件的概念，将 children 作为函数使用，更加贯彻了一切皆为组件的概念。同时在 <a href="mailto:&#x52;&#101;&#97;&#x63;&#x74;&#x40;&#49;&#54;&#x2e;&#x33;" rel="external nofollow noreferrer">&#x52;&#101;&#97;&#x63;&#x74;&#x40;&#49;&#54;&#x2e;&#x33;</a> 版本中，FB 官方的 Context 新 API 的实现也采用了函数子组件的方式。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const RenderProps &#x3D; (&#123; children, ...props &#125;) &#x3D;&gt; children(props, name &#x3D; &#39;RenderPropComponent&#39;);
const Component &#x3D; () &#x3D;&gt; (&lt;RenderProps&gt;
    &#123;(originProps, componentName) &#x3D;&gt; (&lt;div&gt;From &#123;componentName&#125;&lt;&#x2F;div&gt;)&#125;
&lt;&#x2F;RenderProps&gt;);

ReactDOM.render(&lt;Component &#x2F;&gt;, document.getElementById(&#39;root&#39;));
&#x2F;&#x2F; &#x3D;&gt; From RenderPropComponent</code></pre><p>而在 <a href="mailto:&#x56;&#x75;&#101;&#64;&#50;&#x2e;&#53;" rel="external nofollow noreferrer">&#x56;&#x75;&#101;&#64;&#50;&#x2e;&#53;</a> 后的版本中，slot-scope 的概念也有点渲染属性的影子。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const RenderProps &#x3D; &#123;
    template: &#96;&lt;div&gt;&lt;slot v-bind&#x3D;&quot;&#123; name: &#39;RenderPropComponent&#39; &#125;&quot;&gt;&lt;&#x2F;slot&gt;&lt;&#x2F;div&gt;&#96;
&#125;;

const vm &#x3D; new Vue(&#123;
    el: &#39;#root&#39;,
    components: &#123; &#39;render-props&#39;: RenderProps &#125;,
    template: &#96;
      &lt;render-props&gt;
        &lt;template slot-scope&#x3D;&quot;&#123; name &#125;&quot;&gt;
          &lt;div&gt;From Component&lt;&#x2F;div&gt;
          From &#123;&#123; name &#125;&#125;
        &lt;&#x2F;template&gt;
      &lt;&#x2F;render-props&gt;
    &#96;
&#125;);
&#x2F;&#x2F; &#x3D;&gt; From Component
&#x2F;&#x2F; &#x3D;&gt; From RenderPropComponent</code></pre><h4 id="组件注入"><a href="#组件注入" class="headerlink" title="组件注入"></a>组件注入</h4><p>组件注入（Component Injection）的概念有些类似渲染属性，都是传递一个类似 render 的函数属性，区别在于组件注入将该函数作为 React 中的无状态组件使用，而非原始的函数。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const RenderProps &#x3D; (&#123; Render, ...props &#125;) &#x3D;&gt; &lt;Render &#123;...props&#125; name&#x3D;&#39;RenderPropComponent&#39; &#x2F;&gt;;
const Component &#x3D; () &#x3D;&gt; (&lt;RenderProps Render&#x3D;&#123;(&#123; name &#125;) &#x3D;&gt; (&lt;div&gt;From &#123;name&#125;&lt;&#x2F;div&gt;)&#125; &#x2F;&gt;);

ReactDOM.render(&lt;Component &#x2F;&gt;, document.getElementById(&#39;root&#39;));
&#x2F;&#x2F; &#x3D;&gt; From RenderPropComponent</code></pre><p>与渲染属性相比，组件注入能在 devTool 的组件树上直观的展现出内嵌的组件结构。但在另一方面，由于所有属性都被打包成了 props 传出，反而失去了渲染属性的多参数的灵活性。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="render-中使用箭头函数或绑定会导致子组件重新渲染"><a href="#render-中使用箭头函数或绑定会导致子组件重新渲染" class="headerlink" title="render 中使用箭头函数或绑定会导致子组件重新渲染"></a>render 中使用箭头函数或绑定会导致子组件重新渲染</h3><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">import React from &#39;react&#39;;
import &#123; render &#125; from &#39;react-dom&#39;;
import User from &#39;.&#x2F;User&#39;;

class App extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state &#x3D; &#123;
      users: [
        &#123; id: 1, name: &#39;Cory&#39; &#125;, 
        &#123; id: 2, name: &#39;Meg&#39; &#125;, 
        &#123; id: 3, name: &#39;Bob&#39; &#125;
      ]
    &#125;;
  &#125;
  
  deleteUser &#x3D; id &#x3D;&gt; &#123;
    this.setState(prevState &#x3D;&gt; &#123;
      return &#123; 
        users: prevState.users.filter( user &#x3D;&gt; user.id !&#x3D;&#x3D; id)
      &#125;
    &#125;)
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;h1&gt;Users&lt;&#x2F;h1&gt;
        &lt;ul&gt;
        &#123; 
          this.state.users.map( user &#x3D;&gt; &#123;
            return &lt;User 
              key&#x3D;&#123;user.id&#125; 
              name&#x3D;&#123;user.name&#125; 
              onDeleteClick&#x3D;&#123;() &#x3D;&gt; this.deleteUser(user.id)&#125; &#x2F;&gt;
          &#125;)
        &#125;
        &lt;&#x2F;ul&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;

export default App;

render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));

&#x2F;&#x2F; user.js
import React from &#39;react&#39;;

&#x2F;&#x2F; Note how the debugger below gets hit when *any* delete
&#x2F;&#x2F; button is clicked. Why? Because the parent component
&#x2F;&#x2F; uses an arrow function, which means this component
&#x2F;&#x2F;
class User extends React.PureComponent &#123;
  render() &#123;
    const &#123;name, onDeleteClick &#125; &#x3D; this.props
    console.log(&#96;$&#123;name&#125; just rendered&#96;);
    return (
      &lt;li&gt;             
        &lt;input 
          type&#x3D;&quot;button&quot; 
          value&#x3D;&quot;Delete&quot; 
          onClick&#x3D;&#123;onDeleteClick&#125; 
        &#x2F;&gt; 
        &#123;name&#125;
      &lt;&#x2F;li&gt;
    );
  &#125;
&#125;

export default User;</code></pre><p>以上例子中，在 render 函数中使用了一个箭头函数将一个值传递给了 deleteUser 函数，这就是问题的所在。</p><p>每次 render 调用时，控制台上都会打印日志。User 已经被声明为 PureComponent。所以 User 应该只在 props 或者 state 改变时才会重新 render。但是，当你点击 delete 按钮时，对于每一个 User 实例，都会调用 render。</p><p><strong>原因在于：</strong>父组件在 props 中传递了一个箭头函数。箭头函数在每次 render 时都会重新分配（和使用 bind 的方式相同）。所以，尽管我将 User 声明为 PureComponent，User 的父组件中的箭头函数导致 User 组件为所有的用户实例传递了一个新的函数。所以当点击任何删除按钮时，每个用户实例都会重新 render。</p><p><strong>结论：</strong><br>避免在 render 中使用箭头函数和绑定。否则会打破 shouldComponentUpdate 和 PureComponent 的性能优化。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">import React from &#39;react&#39;;
import &#123; render &#125; from &#39;react-dom&#39;;
import User from &#39;.&#x2F;User&#39;;

class App extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state &#x3D; &#123;
      users: [
        &#123; id: 1, name: &#39;Cory&#39; &#125;, 
        &#123; id: 2, name: &#39;Meg&#39; &#125;, 
        &#123; id: 3, name: &#39;Bob&#39;&#125;
      ],
    &#125;;
  &#125;

  deleteUser &#x3D; id &#x3D;&gt; &#123;
    this.setState(prevState &#x3D;&gt; &#123;
      return &#123; 
        users: prevState.users.filter(user &#x3D;&gt; user.id !&#x3D;&#x3D; id) 
      &#125;;
    &#125;);
  &#125;;

  renderUser &#x3D; user &#x3D;&gt; &#123;
    return &lt;User key&#x3D;&#123;user.id&#125; user&#x3D;&#123;user&#125; onClick&#x3D;&#123;this.deleteUser&#125; &#x2F;&gt;;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;h1&gt;Users&lt;&#x2F;h1&gt;
        &lt;ul&gt;
          &#123;this.state.users.map(this.renderUser)&#125;
        &lt;&#x2F;ul&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;

render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;));

import React from &quot;react&quot;;
import PropTypes from &quot;prop-types&quot;;

&#x2F;&#x2F; Note that the console.log below isn&#39;t called
&#x2F;&#x2F; when delete is clicked on a user.
&#x2F;&#x2F; That&#39;s because pureComponent&#39;s shallow
&#x2F;&#x2F; comparison works properly here because
&#x2F;&#x2F; the parent component isn&#39;t passing down
&#x2F;&#x2F; an arrow function (which would cause this
&#x2F;&#x2F; component to see a new function on each render)
class User extends React.PureComponent &#123;
  onDeleteClick &#x3D; () &#x3D;&gt; &#123;
    &#x2F;&#x2F; No bind needed since we can compose the relevant data for this item here
    this.props.onClick(this.props.user.id);
  &#125;;

  render() &#123;
    console.log(&#96;$&#123;name&#125; just rendered&#96;);
    return (
      &lt;li&gt;
        &lt;input 
          type&#x3D;&quot;button&quot; 
          value&#x3D;&quot;Delete&quot; 
          onClick&#x3D;&#123;this.onDeleteClick&#125; 
        &#x2F;&gt;
        &#123;this.props.user.name&#125;
      &lt;&#x2F;li&gt;
    );
  &#125;
&#125;

User.propTypes &#x3D; &#123;
  user: PropTypes.object.isRequired,
  onClick: PropTypes.func.isRequired
&#125;;

export default User;</code></pre><p>在 User.js 中，onDeleteClick 调用了在 props 中传递的 onClick 函数，并传递了相应的 user.id。</p><p>当你再次点击 delete 按钮时，其他的用户再也不会调用 render 了！</p><p><strong>总结</strong><br>为了最佳性能：<br>1、避免在 render 中使用箭头函数和绑定。<br>2、怎么做？提取子组件，或者直接传递数据给 HTML 元素。</p><h3 id="函数作为React组件的方法时-箭头函数和普通函数的区别是什么"><a href="#函数作为React组件的方法时-箭头函数和普通函数的区别是什么" class="headerlink" title="函数作为React组件的方法时, 箭头函数和普通函数的区别是什么"></a>函数作为React组件的方法时, 箭头函数和普通函数的区别是什么</h3><p><strong>问题：</strong></p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class App extends Component &#123;
  a() &#123;
    console.log(1)
  &#125;

  a &#x3D; () &#x3D;&gt; &#123;
    console.log(1)
  &#125;
&#125;</code></pre><p>里面的两个 a 的定义有什么区别？<br>第一个 a 不必说，是原型方法的定义，很显然第一个写法是非法的。宽松模式下对应 ES5 就是：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">App.prototype.a &#x3D; function() &#123;&#125;</code></pre><p>第二个是 Stage 2 Public Class Fields 里面的写法，babel 下需要用 Class properties transform Plugin 进行转义。相当于：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class App extends Component &#123;
  constructor (...args) &#123;
    super(...args)
    this.a &#x3D; () &#x3D;&gt; &#123;
        console.log(1)
    &#125;
  &#125;
&#125;</code></pre><p>为什么需要第二种写法？</p><p>在 React 里面，要将类的原型方法通过 props 传给子组件，传统写法需要 bind(this)，否则方法执行时 this 会找不到：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&lt;button onClick&#x3D;&#123;this.handleClick.bind(this)&#125;&gt;&lt;&#x2F;button&gt;
&#x2F;&#x2F; 或
&lt;button onClick&#x3D;&#123;(e) &#x3D;&gt; this.handleClick(e)&#125;&gt;&lt;&#x2F;button&gt;</code></pre><p>这种写法难看不说，还会对 React 组件的 shouldComponentUpdate 优化造成影响。</p><p>这是因为 React 提供了 shouldComponentUpdate 让开发者能够控制避免不必要的 render，还提供了在 shouldComponentUpdate 自动进行 Shallow Compare 的 React.PureComponent, 继承自 PureComponent 的组件只要 props 和 state 中的值不变，组件就不会重新 render。</p><p>然而如果用了 bind this，每次父组件渲染，传给子组件的 props.onClick 都会变，PureComponent 的 Shallow Compare 基本上就失效了，除非你手动实现 shouldComponentUpdate.</p><p>使用 Public Class Fields 的这种写法，就解决了这个问题。另外还有其他若干种办法，比如先定义原型方法，然后在 constructor 里面 bind 一遍；或者使用 decorator 进行 bind 等：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class A &#123;
  constructor() &#123;
    this.a &#x3D; this.a.bind(this)
  &#125;

  a() &#123;&#125;

  &#x2F;&#x2F; or
  @bindthis
  b() &#123;&#125;
&#125;</code></pre><h2 id="优秀写法"><a href="#优秀写法" class="headerlink" title="优秀写法"></a>优秀写法</h2><h3 id="子组件事件父组件定义"><a href="#子组件事件父组件定义" class="headerlink" title="子组件事件父组件定义"></a>子组件事件父组件定义</h3><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">class Parent extends Component &#123;
  constructor(props) &#123;
    super(props);
    this.state &#x3D; &#123; &#125;
  &#125;
  getData &#x3D; () &#x3D;&gt; &#123; &#x2F;&#x2F; 子类的方法在父类直接使用
    &#x2F;&#x2F; 子类的方法在父类直接使用
  &#125;
  render() &#123;
    return (
      &lt;div className&#x3D;&#39;parent-container&#39;&gt;
        &lt;Child onClick&#x3D;&#123;this.getData&#125; &#x2F;&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;

class Child extends Component &#123;
  render() &#123;
    const that &#x3D; this;
    const &#123; ...others &#125; &#x3D; that.props;
    return (
      &lt;div className&#x3D;&#39;child-container&#39; &#123;...others&#125;&gt;
        &lt;div className&#x3D;&#39;short-icon&#39;&gt;&lt;&#x2F;div&gt;
      &lt;&#x2F;div&gt;
    )
  &#125;
&#125;</code></pre></div><div class="post-footer"><div></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/blog/2018/06/58864.html" class="pre-post btn btn-default" title="react-redux 源码全方位剖析"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">react-redux 源码全方位剖析</span> </a><a href="/blog/2018/06/58626.html" class="next-post btn btn-default" title="MySQl 开发笔记"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">MySQl 开发笔记</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><p>评论系统未开启，无法评论！</p></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2669241897" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></main><aside class="col-md-4 sidebar"><div class="widget"><h3 class="title">赞助广告</h3><ins class="adsbygoogle" style="display:block;width:100%;height:280px" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2014094445" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><p style="text-align:center">想要出现再此！</p></div><div class="widget"><h3 class="title">分类</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/category/Mac-OS/"><i class="fa" aria-hidden="true">Mac OS</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Nuxtjs/"><i class="fa" aria-hidden="true">Nuxtjs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Objective-C/"><i class="fa" aria-hidden="true">Objective-C</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/babel/"><i class="fa" aria-hidden="true">babel</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/css/"><i class="fa" aria-hidden="true">css</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/danger/"><i class="fa" aria-hidden="true">danger</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/data-structure/"><i class="fa" aria-hidden="true">data structure</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/design/"><i class="fa" aria-hidden="true">design</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es6/"><i class="fa" aria-hidden="true">es6</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es7/"><i class="fa" aria-hidden="true">es7</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/eslint/"><i class="fa" aria-hidden="true">eslint</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/flutter/"><i class="fa" aria-hidden="true">flutter</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/git/"><i class="fa" aria-hidden="true">git</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/github/"><i class="fa" aria-hidden="true">github</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/golang/"><i class="fa" aria-hidden="true">golang</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/http/"><i class="fa" aria-hidden="true">http</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/java/"><i class="fa" aria-hidden="true">java</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/javascript/"><i class="fa" aria-hidden="true">javascript</i></a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/jest/"><i class="fa" aria-hidden="true">jest</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/koa/"><i class="fa" aria-hidden="true">koa</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/lerna/"><i class="fa" aria-hidden="true">lerna</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/linux/"><i class="fa" aria-hidden="true">linux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/mysql/"><i class="fa" aria-hidden="true">mysql</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/netlify/"><i class="fa" aria-hidden="true">netlify</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nginx/"><i class="fa" aria-hidden="true">nginx</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nodejs/"><i class="fa" aria-hidden="true">nodejs</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/npm/"><i class="fa" aria-hidden="true">npm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/programm/"><i class="fa" aria-hidden="true">programm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/react/"><i class="fa" aria-hidden="true">react</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux/"><i class="fa" aria-hidden="true">redux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux-thunk/"><i class="fa" aria-hidden="true">redux-thunk</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/regex/"><i class="fa" aria-hidden="true">regex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/rollup/"><i class="fa" aria-hidden="true">rollup</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/shell/"><i class="fa" aria-hidden="true">shell</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/sketch/"><i class="fa" aria-hidden="true">sketch</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/the-super-tiny-compiler/"><i class="fa" aria-hidden="true">the-super-tiny-compiler</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/threejs/"><i class="fa" aria-hidden="true">threejs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/typescript/"><i class="fa" aria-hidden="true">typescript</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vscode/"><i class="fa" aria-hidden="true">vscode</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue/"><i class="fa" aria-hidden="true">vue</i></a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue-router/"><i class="fa" aria-hidden="true">vue-router</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vuex/"><i class="fa" aria-hidden="true">vuex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/webpack/"><i class="fa" aria-hidden="true">webpack</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/wechat/"><i class="fa" aria-hidden="true">wechat</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link current" href="/blog/category/%E5%89%8D%E7%AB%AF/"><i class="fa" aria-hidden="true">前端</i></a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%90%8E%E7%AB%AF/"><i class="fa" aria-hidden="true">后端</i></a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"><i class="fa" aria-hidden="true">建站教程</i></a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="fa" aria-hidden="true">数据库</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%9D%82%E8%B0%88/"><i class="fa" aria-hidden="true">杂谈</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%A7%91%E6%8A%80%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A-%E9%98%AE%E4%B8%80%E5%B3%B0/"><i class="fa" aria-hidden="true">科技爱好者周刊(阮一峰)</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"><i class="fa" aria-hidden="true">编程之道</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><i class="fa" aria-hidden="true">软件工具</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><i class="fa" aria-hidden="true">软件设计</i></a><span class="category-list-count">16</span></li></ul></div><div class="widget"><h3 class="title">归档</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/03/"><i class="fa" aria-hidden="true">2020年03月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/01/"><i class="fa" aria-hidden="true">2020年01月</i></a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/12/"><i class="fa" aria-hidden="true">2019年12月</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/11/"><i class="fa" aria-hidden="true">2019年11月</i></a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/08/"><i class="fa" aria-hidden="true">2019年08月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/07/"><i class="fa" aria-hidden="true">2019年07月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/04/"><i class="fa" aria-hidden="true">2019年04月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/03/"><i class="fa" aria-hidden="true">2019年03月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/02/"><i class="fa" aria-hidden="true">2019年02月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/01/"><i class="fa" aria-hidden="true">2019年01月</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/12/"><i class="fa" aria-hidden="true">2018年12月</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/11/"><i class="fa" aria-hidden="true">2018年11月</i></a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/10/"><i class="fa" aria-hidden="true">2018年10月</i></a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/09/"><i class="fa" aria-hidden="true">2018年09月</i></a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/08/"><i class="fa" aria-hidden="true">2018年08月</i></a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/07/"><i class="fa" aria-hidden="true">2018年07月</i></a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/06/"><i class="fa" aria-hidden="true">2018年06月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/05/"><i class="fa" aria-hidden="true">2018年05月</i></a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/04/"><i class="fa" aria-hidden="true">2018年04月</i></a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/03/"><i class="fa" aria-hidden="true">2018年03月</i></a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><h3 class="title">标签云</h3><div class="content tag-cloud"><a href="/blog/tagged/Apache/" style="font-size:13.33px">Apache</a> <a href="/blog/tagged/CPU%E7%BC%93%E5%AD%98/" style="font-size:10px">CPU缓存</a> <a href="/blog/tagged/CSS/" style="font-size:10px">CSS</a> <a href="/blog/tagged/Cryptojs/" style="font-size:10px">Cryptojs</a> <a href="/blog/tagged/DevOps/" style="font-size:10px">DevOps</a> <a href="/blog/tagged/Equality-operator/" style="font-size:10px">Equality operator</a> <a href="/blog/tagged/Fenix/" style="font-size:10px">Fenix</a> <a href="/blog/tagged/Git/" style="font-size:10px">Git</a> <a href="/blog/tagged/GitLab-CI/" style="font-size:10px">GitLab CI</a> <a href="/blog/tagged/Google/" style="font-size:10px">Google</a> <a href="/blog/tagged/JAVA-HOME/" style="font-size:10px">JAVA_HOME</a> <a href="/blog/tagged/JPA/" style="font-size:10px">JPA</a> <a href="/blog/tagged/Java/" style="font-size:20px">Java</a> <a href="/blog/tagged/JavaScript/" style="font-size:13.33px">JavaScript</a> <a href="/blog/tagged/Jenkins/" style="font-size:10px">Jenkins</a> <a href="/blog/tagged/Linux/" style="font-size:13.33px">Linux</a> <a href="/blog/tagged/MVEL/" style="font-size:11.11px">MVEL</a> <a href="/blog/tagged/Markdown/" style="font-size:10px">Markdown</a> <a href="/blog/tagged/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/blog/tagged/React-Fire/" style="font-size:10px">React Fire</a> <a href="/blog/tagged/Semicolon/" style="font-size:10px">Semicolon</a> <a href="/blog/tagged/Spring/" style="font-size:11.11px">Spring</a> <a href="/blog/tagged/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/blog/tagged/Typora/" style="font-size:10px">Typora</a> <a href="/blog/tagged/UML/" style="font-size:11.11px">UML</a> <a href="/blog/tagged/Vue/" style="font-size:10px">Vue</a> <a href="/blog/tagged/ajax/" style="font-size:10px">ajax</a> <a href="/blog/tagged/analysis-package/" style="font-size:10px">analysis package</a> <a href="/blog/tagged/async/" style="font-size:10px">async</a> <a href="/blog/tagged/cheerio/" style="font-size:10px">cheerio</a> <a href="/blog/tagged/commit-message/" style="font-size:10px">commit message</a> <a href="/blog/tagged/communication/" style="font-size:10px">communication</a> <a href="/blog/tagged/component/" style="font-size:10px">component</a> <a href="/blog/tagged/currying/" style="font-size:10px">currying</a> <a href="/blog/tagged/decorator/" style="font-size:10px">decorator</a> <a href="/blog/tagged/fiber/" style="font-size:10px">fiber</a> <a href="/blog/tagged/fix-bug/" style="font-size:10px">fix bug</a> <a href="/blog/tagged/function/" style="font-size:10px">function</a> <a href="/blog/tagged/git-clone/" style="font-size:10px">git clone</a> <a href="/blog/tagged/golang/" style="font-size:10px">golang</a> <a href="/blog/tagged/hexo/" style="font-size:14.44px">hexo</a> <a href="/blog/tagged/hooks/" style="font-size:10px">hooks</a> <a href="/blog/tagged/http/" style="font-size:10px">http</a> <a href="/blog/tagged/justify/" style="font-size:10px">justify</a> <a href="/blog/tagged/let/" style="font-size:10px">let</a> <a href="/blog/tagged/login/" style="font-size:10px">login</a> <a href="/blog/tagged/module/" style="font-size:11.11px">module</a> <a href="/blog/tagged/nginx/" style="font-size:11.11px">nginx</a> <a href="/blog/tagged/note/" style="font-size:18.89px">note</a> <a href="/blog/tagged/npm/" style="font-size:11.11px">npm</a> <a href="/blog/tagged/npx/" style="font-size:10px">npx</a> <a href="/blog/tagged/open/" style="font-size:10px">open</a> <a href="/blog/tagged/package/" style="font-size:10px">package</a> <a href="/blog/tagged/package-json/" style="font-size:10px">package.json</a> <a href="/blog/tagged/path/" style="font-size:10px">path</a> <a href="/blog/tagged/pm2/" style="font-size:11.11px">pm2</a> <a href="/blog/tagged/promise/" style="font-size:10px">promise</a> <a href="/blog/tagged/refs/" style="font-size:10px">refs</a> <a href="/blog/tagged/rem/" style="font-size:10px">rem</a> <a href="/blog/tagged/render/" style="font-size:10px">render</a> <a href="/blog/tagged/require/" style="font-size:10px">require</a> <a href="/blog/tagged/rzero/" style="font-size:10px">rzero</a> <a href="/blog/tagged/selector/" style="font-size:10px">selector</a> <a href="/blog/tagged/service/" style="font-size:10px">service</a> <a href="/blog/tagged/setTimeout/" style="font-size:10px">setTimeout</a> <a href="/blog/tagged/source/" style="font-size:16.67px">source</a> <a href="/blog/tagged/ssh/" style="font-size:10px">ssh</a> <a href="/blog/tagged/ssr/" style="font-size:10px">ssr</a> <a href="/blog/tagged/timer/" style="font-size:10px">timer</a> <a href="/blog/tagged/tools/" style="font-size:10px">tools</a> <a href="/blog/tagged/tree-shaking/" style="font-size:10px">tree-shaking</a> <a href="/blog/tagged/typecho/" style="font-size:15.56px">typecho</a> <a href="/blog/tagged/typecho%E6%8F%92%E4%BB%B6/" style="font-size:15.56px">typecho插件</a> <a href="/blog/tagged/types/" style="font-size:10px">types</a> <a href="/blog/tagged/utils/" style="font-size:10px">utils</a> <a href="/blog/tagged/virtual-dom/" style="font-size:10px">virtual dom</a> <a href="/blog/tagged/vscode/" style="font-size:10px">vscode</a> <a href="/blog/tagged/wasm/" style="font-size:13.33px">wasm</a> <a href="/blog/tagged/webassembly/" style="font-size:13.33px">webassembly</a> <a href="/blog/tagged/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size:10px">位运算</a> <a href="/blog/tagged/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size:11.11px">单元测试</a> <a href="/blog/tagged/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" style="font-size:10px">性能测试</a> <a href="/blog/tagged/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/" style="font-size:10px">整洁代码</a> <a href="/blog/tagged/%E6%B5%8B%E8%AF%95/" style="font-size:10px">测试</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size:10px">设计原则</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:17.78px">设计模式</a> <a href="/blog/tagged/%E9%87%8D%E6%9E%84/" style="font-size:10px">重构</a> <a href="/blog/tagged/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" style="font-size:12.22px">面向对象编程</a></div></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi"></div></div><div class="col-sm-12"><span>Copyright &copy; 2021 - 2023 Liuxfe</span></div></div></div></div><script src="/js/app.js?rev=@@hash.js"></script><script>!function(e,t,c,n,r,a){e.ym=e.ym||function(){(e.ym.a=e.ym.a||[]).push(arguments)},e.ym.l=+new Date;for(var m=0;m<document.scripts.length;m++)if(document.scripts[m].src===n)return;r=t.createElement(c),a=t.getElementsByTagName(c)[0],r.async=1,r.src=n,a.parentNode.insertBefore(r,a)}(window,document,"script","https://mc.yandex.ru/metrika/tag.js"),ym(93104114,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script></body></html>