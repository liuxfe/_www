<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Liuxfe的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="keywords" content="hooks"><meta name="description" content="前言不得不说 React 等优秀框架的出现为前端开发带来了极大的便利，但是在React v16.7提出Hooks之前我们依旧不得不面对一些很恶心的问题：
组件逻辑复用麻烦且很有可能造成嵌套黑洞（..."><title>React Hooks — 新一代 React API | Liuxfe的博客</title><link rel="icon" href="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css"><link rel="stylesheet" href="/css/style.css?rev=@@hash.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9312750344484857" crossorigin="anonymous"></script></head><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Liuxfe"><img src="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>-------------</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="https://www.liuxfe.com">Liuxfe的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i> 首页</a></li><li role="presentation" class="text-center"><a href="/blog/"><i class="fa"></i> 博客</a></li><li role="presentation" class="text-center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://link.liuxfe.com/GlreA"><i class="fa"></i> 维基镜像</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="React Hooks — 新一代 React API">React Hooks — 新一代 React API</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="/blog/category/react/">react</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-none-link" href="/blog/tagged/hooks/" rel="tag">hooks</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2018/11/14</span></span></div><p class="fa fa-exclamation-triangle warning">本文于<strong> 1610</strong> 天之前发表，文中内容可能已经过时。</p></div><div class="post-body post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不得不说 React 等优秀框架的出现为前端开发带来了极大的便利，但是在<code>React v16.7</code>提出<code>Hooks</code>之前我们依旧不得不面对一些很恶心的问题：</p><h3 id="组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper-Hell）"><a href="#组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper-Hell）" class="headerlink" title="组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper Hell）"></a>组件逻辑复用麻烦且很有可能造成嵌套黑洞（Wrapper Hell）</h3><p>我们都知道react的核心思想是：将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来，但如果我们在大型项目中用react，我们便会发现项目中很多react组件冗长且难以复用，尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。在 hooks 之前官方推荐的解决方式：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://reactjs.org/docs/render-props.html">渲染属性（Render Props）</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://reactjs.org/docs/higher-order-components.html">高阶组件（Higher-Order Components）</a>，我们现在简单看一下这两种模式：</p><h4 id="渲染属性（Render-Props）"><a href="#渲染属性（Render-Props）" class="headerlink" title="渲染属性（Render Props）"></a>渲染属性（Render Props）</h4><p><code>渲染属性（Render Props）</code>是一个组件间共享代码逻辑的小技巧, 通过props传递函数来实现。组件中有一个叫做<code>render</code>的<code>prop</code>, 值是一个返回React元素的函数, 在组件内部调用这个函数渲染组件。语言描述不够直观, 我们来看一个例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class Cat extends React.Component &#123;
  render() &#123;
    const mouse &#x3D; this.props.mouse;
    return (
      &lt;img src&#x3D;&quot;&#x2F;cat.jpg&quot; style&#x3D;&#123;&#123; position: &#39;absolute&#39;, left: mouse.x, top: mouse.y &#125;&#125; &#x2F;&gt;
    );
  &#125;
&#125;

class Mouse extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.handleMouseMove &#x3D; this.handleMouseMove.bind(this);
    this.state &#x3D; &#123; x: 0, y: 0 &#125;;
  &#125;

  handleMouseMove(event) &#123;
    this.setState(&#123;
      x: event.clientX,
      y: event.clientY
    &#125;);
  &#125;

  render() &#123;
    return (
      &lt;div style&#x3D;&#123;&#123; height: &#39;100%&#39; &#125;&#125; onMouseMove&#x3D;&#123;this.handleMouseMove&#125;&gt;

        &#123;&#x2F;*
          使用传入函数的逻辑动态渲染
          而不是硬编码地渲染固定内容
        *&#x2F;&#125;
        &#123;this.props.render(this.state)&#125;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;

class MouseTracker extends React.Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &lt;h1&gt;Move the mouse around!&lt;&#x2F;h1&gt;
        &lt;Mouse render&#x3D;&#123;mouse &#x3D;&gt; (
          &lt;Cat mouse&#x3D;&#123;mouse&#125; &#x2F;&gt;
        )&#125;&#x2F;&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre><p>可以看到我们的<code>Mouse</code>组件包含了所有跟状态相关的代码，而<code>Cat</code>组件则只是一个单纯的展示型组件，这样一来我们可以随处复用<code>Mouse</code>组件了。</p><p>虽然这个技巧或者说模式(Pattern)叫<code>Render Props</code>, 但不是说非用一个叫render的props来传递渲染函数, 习惯上我们更常写成下面这种：</p><pre class="line-numbers language-jsx" data-language="jsx"><code class="language-jsx">&lt;Mouse&gt;
  &#123;mouse &#x3D;&gt; (
    &lt;p&gt;The mouse position is &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;&#x2F;p&gt;
  )&#125;
&lt;&#x2F;Mouse&gt;</code></pre><h4 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h4><p>简单说高阶组件就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser函数就是一个高阶组件，它返回了一个新的组件，这个组件具有了它提供的获取用户信息的功能。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">const withUser &#x3D; WrappedComponent &#x3D;&gt; &#123;
  const user &#x3D; sessionStorage.getItem(&quot;user&quot;);
  return props &#x3D;&gt; &lt;WrappedComponent user&#x3D;&#123;user&#125; &#123;...props&#125; &#x2F;&gt;;
&#125;;

const UserPage &#x3D; props &#x3D;&gt; (
  &lt;div class&#x3D;&quot;user-container&quot;&gt;
    &lt;p&gt;My name is &#123;props.user&#125;!&lt;&#x2F;p&gt;
  &lt;&#x2F;div&gt;
);

export default withUser(UserPage);</code></pre><p>以上这两种模式看上去都挺不错的，有许多库(比如React Router, React Motion)都有使用这些模式。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看我们的组件层级嵌套是不是很夸张吧。如果我们采用 hooks 方式，把各种想要的功能写成一个一个可复用的自定义hook，当我们的组件想用什么功能时，直接在组件里调用这个hook即可，这样就简洁了许多，也没有多余的层级嵌套。</p><h3 id="组件生命周期混乱"><a href="#组件生命周期混乱" class="headerlink" title="组件生命周期混乱"></a>组件生命周期混乱</h3><p>由于React生命周期的存在，我们常常将一些逻辑强相关的代码分散地放置在组件的不同位置，造成我们的组件中出现了许多零散的、重复的代码，比如我们在 componentDidMount 中绑定事件、添加定时器，然后在 componentWillUnmount 中移除他们；又或者频繁地在 componentDidUpdate 中比较变化前和变化后的state来决定是否执行某些逻辑。</p><h3 id="无状态组件（Function）和有状态组件（Class）选择问题"><a href="#无状态组件（Function）和有状态组件（Class）选择问题" class="headerlink" title="无状态组件（Function）和有状态组件（Class）选择问题"></a>无状态组件（Function）和有状态组件（Class）选择问题</h3><p>回想我们在刚开始学习React的时候常常会疑惑该使用Functional Component(那个时候我们叫Stateless Component)还是有状态组件（Class Component），虽然两者得到的结果大致相同，但是书写方式却迥然不同。有些组件可能最开始的时候使用Functional，后来发现需要加入生命周期和state的支持又不得不大费周折地改成Class。这样不清不楚的定位对许多初学者来说，无疑造成了很大的困扰。更有些开发者便无脑的都使用 Class Component。</p><h3 id="Class-Component-的-this-指向问题"><a href="#Class-Component-的-this-指向问题" class="headerlink" title="Class Component 的 this 指向问题"></a>Class Component 的 this 指向问题</h3><p>我们用class创建react组件时，还有一件很麻烦的事情，就是this的指向问题。为了保证this的指向正确，我们要经常写这样的代码：<code>this.handleClick = this.handleClick.bind(this)</code>，或者是这样的代码：<code>&lt;button onClick=&#123;() =&gt; this.handleClick(e)&#125;&gt;</code>。一旦我们不小心忘了绑定this，各种bug就随之而来，很麻烦。</p><h3 id="Class-Component-无法-prepack-优化"><a href="#Class-Component-无法-prepack-优化" class="headerlink" title="Class Component 无法 prepack 优化"></a>Class Component 无法 prepack 优化</h3><p>在 class 里，类的属性即便内部没用到，对外部还是可访问的，所以类的属性在Uglify的时候是不会被编译的，同时如果一个类的方法没有被使用，编译器也无法将它识别出来并精简掉。</p><p>在这样的背景下，Hooks便横空出世了！</p><h2 id="什么是-Hooks"><a href="#什么是-Hooks" class="headerlink" title="什么是 Hooks"></a>什么是 Hooks</h2><p><code>Hooks</code>是 React 提供的一系列新的方法（习惯上以useXXX命名）。这些方法将state、context和Class组件中的生命周期，统统抽象成了函数，使得我们在Functional组件中也能使用它们，甚至我们还可以将它们彼此进行组合，从而将特定的逻辑进一步进行抽象和封装，进一步作为npm包的形式进行发布！</p><p>接下来我们一起认识一下新增的几个方法：</p><ul><li>State Hook: 为组件提供访问state的能力</li><li>Effect Hook: 监听state的变动，并在合适的时候调用</li><li>Custom Hooks: 用户自定义的钩子，是以上两者的组合。方便用户对操作state的逻辑进行封装</li><li>Other Hooks: 主要包括访问Context的钩子和管理复杂state的钩子</li></ul><h3 id="State-Hook-React-useState"><a href="#State-Hook-React-useState" class="headerlink" title="State Hook: React.useState"></a>State Hook: React.useState</h3><p><strong>useState: (any<t>) =&gt; [state:<t>, (newState) =&gt; null]</t></t></strong><br>useState 方法比较简单，基本就是一个简化版的 setState 。每次调用会生成一个新的state，并将状态与组件绑定。来看一个简单的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useState &#125; from &#39;react&#39;;

function Example() &#123;
  &#x2F;&#x2F; Declare a new state variable, which we&#39;ll call &quot;count&quot;
  const [count, setCount] &#x3D; useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;
      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;&#x2F;button&gt;
    &lt;&#x2F;div&gt;
  );
&#125;</code></pre><p>我们再来看一下使用class component后的版本：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class Example extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state &#x3D; &#123;
      count: 0
    &#125;;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;&#x2F;p&gt;
        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;
          Click me
        &lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre><p>可以看出，使用hooks后，代码简单了许多。我们分解来看到底state hooks做了什么：</p><h4 id="声明状态变量"><a href="#声明状态变量" class="headerlink" title="声明状态变量"></a>声明状态变量</h4><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useState &#125; from &#39;react&#39;;

function Example() &#123;
  const [count, setCount] &#x3D; useState(0);</code></pre><p>useState是react自带的一个hook函数，它的作用就是用来声明状态变量。useState这个函数接收的参数是我们的状态初始值（initial state），它返回了一个数组，这个数组的第<code>[0]</code>项是当前的状态值，第<code>[1]</code>项是可以改变状态值的函数，所以其实useState做的事情就是：声明了一个状态变量count，把它的初始值设为0，同时提供了一个可以更改count的函数setCount。上面这种表达形式，是借用了<a target="_blank" rel="noopener external nofollow noreferrer" href="http://es6.ruanyifeng.com/#docs/destructuring#%E6%95%B0%E7%BB%84%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">es6的数组解构（array destructuring）</a>，让我们的代码看起来更简洁。实际上数组解构是一件开销很大的事情，用下面这种写法，或者改用对象解构，性能会有很大的提升。如果不用数组解构的话，也可以写成下面这样：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">let _useState &#x3D; useState(0);
let count &#x3D; _useState[0];
let setCount &#x3D; _useState[1];</code></pre><h4 id="使用状态值"><a href="#使用状态值" class="headerlink" title="使用状态值"></a>使用状态值</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;</code></pre><p>是不是超简单？因为我们的状态count就是一个单纯的变量而已，我们再也不需要写成<code>&#123;this.state.count&#125;</code>这样了。</p><h4 id="修改状态"><a href="#修改状态" class="headerlink" title="修改状态"></a>修改状态</h4><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;
  Click me
&lt;&#x2F;button&gt;</code></pre><p>当用户点击按钮时，我们调用setCount函数，这个函数接收的参数是修改过的新状态值。接下来的事情就交给react了，react将会重新渲染我们的Example组件，并且使用的是更新后的新状态，即count=1。这里我们要停下来思考一下，Example本质上也是一个普通的函数，为什么它可以记住之前的状态？</p><h4 id="React-帮忙记住之前的状态"><a href="#React-帮忙记住之前的状态" class="headerlink" title="React 帮忙记住之前的状态"></a>React 帮忙记住之前的状态</h4><p>通常来说我们在一个函数中声明的变量，当函数运行完成后，这个变量也就销毁了（这里我们先不考虑闭包等情况），比如考虑下面的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function add(n) &#123;
    const result &#x3D; 0;
    return result + 1;
&#125;

add(1); &#x2F;&#x2F;1
add(1); &#x2F;&#x2F;1</code></pre><p>不管我们反复调用add函数多少次，结果都是1。因为每一次我们调用add时，result变量都是从初始值0开始的。那为什么上面的Example函数每次执行的时候，都是拿的上一次执行完的状态值作为初始值？答案是：是react帮我们记住的。至于react是用什么机制记住的，我们可以再思考一下。</p><h4 id="React-记住状态的关键点"><a href="#React-记住状态的关键点" class="headerlink" title="React 记住状态的关键点"></a>React 记住状态的关键点</h4><p>首先，useState是可以多次调用的，所以我们完全可以这样写：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function ExampleWithManyStates() &#123;
  const [age, setAge] &#x3D; useState(42);
  const [fruit, setFruit] &#x3D; useState(&#39;banana&#39;);
  const [todos, setTodos] &#x3D; useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);</code></pre><p>其次，useState接收的初始值没有规定一定要是string/number/boolean这种简单数据类型，它完全可以接收对象或者数组作为参数。唯一需要注意的点是，之前我们的this.setState做的是合并状态后返回一个新状态，而useState是直接替换老状态后返回新状态。最后，react也给我们提供了一个useReducer的hook，如果我们更喜欢redux式的状态管理方案的话。</p><p>从ExampleWithManyStates函数我们可以看到，useState无论调用多少次，相互之间是独立的。这一点至关重要。为什么这么说呢？</p><p>其实我们看hook的“形态”，有点类似之前被官方否定掉的Mixins这种方案，都是提供一种“插拔式的功能注入”的能力。而mixins之所以被否定，是因为Mixins机制是让多个Mixins共享一个对象的数据空间，这样就很难确保不同Mixins依赖的状态不发生冲突。</p><p>而现在我们的hook，一方面它是直接用在function当中，而不是class；另一方面每一个hook都是相互独立的，不同组件调用同一个hook也能保证各自状态的独立性，这就是两者的本质区别。</p><h4 id="react是根据useState出现的顺序记住状态"><a href="#react是根据useState出现的顺序记住状态" class="headerlink" title="react是根据useState出现的顺序记住状态"></a>react是根据useState出现的顺序记住状态</h4><p>还是看上面给出的ExampleWithManyStates例子，我们调用了三次useState，每次我们传的参数只是一个值（如42，‘banana’），我们根本没有告诉react这些值对应的key是哪个，那react是怎么保证这三个useState找到它对应的state呢？</p><p>答案是，react是根据useState出现的顺序来定的。我们具体来看一下：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F;第一次渲染
useState(42);  &#x2F;&#x2F;将age初始化为42
useState(&#39;banana&#39;);  &#x2F;&#x2F;将fruit初始化为banana
useState([&#123; text: &#39;Learn Hooks&#39; &#125;]); &#x2F;&#x2F;...

&#x2F;&#x2F;第二次渲染
useState(42);  &#x2F;&#x2F;读取状态变量age的值（这时候传的参数42直接被忽略）
useState(&#39;banana&#39;);  &#x2F;&#x2F;读取状态变量fruit的值（这时候传的参数banana直接被忽略）
useState([&#123; text: &#39;Learn Hooks&#39; &#125;]); &#x2F;&#x2F;...</code></pre><p>假如我们改一下代码：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">let showFruit &#x3D; true;
function ExampleWithManyStates() &#123;
  const [age, setAge] &#x3D; useState(42);
  
  if(showFruit) &#123;
    const [fruit, setFruit] &#x3D; useState(&#39;banana&#39;);
    showFruit &#x3D; false;
  &#125;
 
  const [todos, setTodos] &#x3D; useState([&#123; text: &#39;Learn Hooks&#39; &#125;]);</code></pre><p>这样一来，</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">&#x2F;&#x2F;第一次渲染
useState(42);  &#x2F;&#x2F;将age初始化为42
useState(&#39;banana&#39;);  &#x2F;&#x2F;将fruit初始化为banana
useState([&#123; text: &#39;Learn Hooks&#39; &#125;]); &#x2F;&#x2F;...

&#x2F;&#x2F;第二次渲染
useState(42);  &#x2F;&#x2F;读取状态变量age的值（这时候传的参数42直接被忽略）
&#x2F;&#x2F; useState(&#39;banana&#39;);  
useState([&#123; text: &#39;Learn Hooks&#39; &#125;]); &#x2F;&#x2F;读取到的却是状态变量fruit的值，导致报错</code></pre><p>鉴于此，react规定我们必须把hooks写在函数的最外层，不能写在ifelse等条件语句当中，来确保hooks的执行顺序一致。</p><h3 id="Effect-Hook-React-useEffect"><a href="#Effect-Hook-React-useEffect" class="headerlink" title="Effect Hook: React.useEffect"></a>Effect Hook: React.useEffect</h3><p><strong>useEffect: (() =&gt; {do sth…; return () =&gt; null}, []) =&gt; null</strong><br>因为通过useEffect，我们可以完成对Class Component所有关键生命周期的访问。 我们详细来看一下：</p><p>首先 useEffect 方法接收两个参数：</p><ul><li>第一个参数是一个函数<br>这个函数会在每次组件重新update后被调用（我们也可以理解为每次render之后会调用一遍这个方法）。只使用这个方法的作用和 componentDidUpdate 差不多，比如要实现输入和document.title的双向绑定：<pre class="line-numbers language-js" data-language="js"><code class="language-js">import React, &#123; useState, useEffect &#125; from &#39;react&#39;

export default function Example() &#123;
  const [value, setValue] &#x3D; useState(&#39;&#39;)
  useEffect(() &#x3D;&gt; &#123;
    document.title &#x3D; value
  &#125;)

  return &lt;input value&#x3D;&#123;value&#125; onChange&#x3D;&#123;e &#x3D;&gt; &#123;setValue(e.target.value)&#125;&#125; &#x2F;&gt;
&#125;</code></pre></li><li>这个函数的返回值也是一个函数<br>回想一下，在使用class组件时， componentDidMount 其实是一类特殊的 componentDidUpdate —— 前者只会在第一次update时调用。所以在functional组件中，我们也可以使用useEffect来模拟 componentDidUpdate，只要区分函数的调用时机就可以。</li></ul><p>不过在useEffect里不是这样做的。useEffect的做法更简单粗暴一些：在state更新时调用，在下一次render之前清理。useEffect方法接收一个函数作为返回值，返回的函数会在下一次render之前被调用。 (总觉得这样会不会太粗暴了一点，因为每次重新render都会绑定一次事件。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import React, &#123; useState, useEffect &#125; from &#39;react&#39;

export default function Example() &#123;
  const handleClick &#x3D; () &#x3D;&gt; &#123;
      &#x2F;&#x2F; do something
  &#125;
  useEffect(() &#x3D;&gt; &#123;
    document.querySelector(&#39;#example).addEventListener(&#39;click&#39;, handleClick)
    return () &#x3D;&gt; &#123;
      document.querySelector(&#39;#example).removeEventListener(&#39;click&#39;, handleClick)  
    &#125;
  &#125;)
  return &lt;div id&#x3D;&quot;example&quot;&gt;Lorem&lt;&#x2F;div&gt;
&#125;</code></pre><ul><li>第三个知识点是这个函数的第二个参数是一个数组<br>这个数组里的值可以等同于我们在写 componentDidUpdate 里的条件判断。只有当数组中包含的值变化的时候才会触发当前的useEffect。</li></ul><p>我们在上一节的例子中增加一个新功能：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useState, useEffect &#125; from &#39;react&#39;;

function Example() &#123;
  const [count, setCount] &#x3D; useState(0);

  &#x2F;&#x2F; 类似于componentDidMount 和 componentDidUpdate:
  useEffect(() &#x3D;&gt; &#123;
    &#x2F;&#x2F; 更新文档的标题
    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;
  &#125;);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked &#123;count&#125; times&lt;&#x2F;p&gt;
      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;
        Click me
      &lt;&#x2F;button&gt;
    &lt;&#x2F;div&gt;
  );
&#125;</code></pre><p>我们对比看一下，如果没有hooks，我们会怎么写？</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">class Example extends React.Component &#123;
  constructor(props) &#123;
    super(props);
    this.state &#x3D; &#123;
      count: 0
    &#125;;
  &#125;

  componentDidMount() &#123;
    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;
  &#125;

  componentDidUpdate() &#123;
    document.title &#x3D; &#96;You clicked $&#123;this.state.count&#125; times&#96;;
  &#125;

  render() &#123;
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;&#x2F;p&gt;
        &lt;button onClick&#x3D;&#123;() &#x3D;&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;
          Click me
        &lt;&#x2F;button&gt;
      &lt;&#x2F;div&gt;
    );
  &#125;
&#125;</code></pre><p>我们写的有状态组件，通常会产生很多的副作用（side effect），比如发起ajax请求获取数据，添加一些监听的注册和取消注册，手动修改dom等等。我们之前都把这些副作用的函数写在生命周期函数钩子里，比如componentDidMount，componentDidUpdate和componentWillUnmount。而现在的useEffect就相当与这些声明周期函数钩子的集合体。它以一抵三。</p><p>同时，由于前文所说hooks可以反复多次使用，相互独立。所以我们合理的做法是，给每一个副作用一个单独的useEffect钩子。这样一来，这些副作用不再一股脑堆在生命周期钩子里，代码变得更加清晰。</p><h4 id="useEffect做了什么？"><a href="#useEffect做了什么？" class="headerlink" title="useEffect做了什么？"></a>useEffect做了什么？</h4><p>我们再梳理一遍下面代码的逻辑：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function Example() &#123;
  const [count, setCount] &#x3D; useState(0);

  useEffect(() &#x3D;&gt; &#123;
    document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;
  &#125;);</code></pre><p>首先，我们声明了一个状态变量count，将它的初始值设为0。然后我们告诉react，我们的这个组件有一个副作用。我们给useEffecthook传了一个匿名函数，这个匿名函数就是我们的副作用。在这个例子里，我们的副作用是调用browser API来修改文档标题。当react要渲染我们的组件时，它会先记住我们用到的副作用。等react更新了DOM之后，它再依次执行我们定义的副作用函数。</p><p>这里要注意几点：</p><p>第一，react首次渲染和之后的每次渲染都会调用一遍传给useEffect的函数。而之前我们要用两个声明周期函数来分别表示首次渲染（componentDidMount）和之后的更新导致的重新渲染（componentDidUpdate）。</p><p>第二，useEffect中定义的副作用函数的执行不会阻碍浏览器更新视图，也就是说这些函数是异步执行的，而之前的componentDidMount或componentDidUpdate中的代码则是同步执行的。这种安排对大多数副作用说都是合理的，但有的情况除外，比如我们有时候需要先根据DOM计算出某个元素的尺寸再重新渲染，这时候我们希望这次重新渲染是同步发生的，也就是说它会在浏览器真的去绘制这个页面前发生。</p><h4 id="useEffect怎么解绑一些副作用"><a href="#useEffect怎么解绑一些副作用" class="headerlink" title="useEffect怎么解绑一些副作用"></a>useEffect怎么解绑一些副作用</h4><p>这种场景很常见，当我们在componentDidMount里添加了一个注册，我们得马上在componentWillUnmount中，也就是组件被注销之前清除掉我们添加的注册，否则内存泄漏的问题就出现了。</p><p>怎么清除呢？让我们传给useEffect的副作用函数返回一个新的函数即可。这个新的函数将会在组件下一次重新渲染之后执行。这种模式在一些pubsub模式的实现中很常见。看下面的例子：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useState, useEffect &#125; from &#39;react&#39;;

function FriendStatus(props) &#123;
  const [isOnline, setIsOnline] &#x3D; useState(null);

  function handleStatusChange(status) &#123;
    setIsOnline(status.isOnline);
  &#125;

  useEffect(() &#x3D;&gt; &#123;
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    &#x2F;&#x2F; 一定注意下这个顺序：告诉react在下次重新渲染组件之后，同时是下次调用ChatAPI.subscribeToFriendStatus之前执行cleanup
    return function cleanup() &#123;
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    &#125;;
  &#125;);

  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;
    return &#39;Loading...&#39;;
  &#125;
  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;
&#125;</code></pre><p>这里有一个点需要重视！这种解绑的模式跟componentWillUnmount不一样。componentWillUnmount只会在组件被销毁前执行一次而已，而useEffect里的函数，每次组件渲染后都会执行一遍，包括副作用函数返回的这个清理函数也会重新执行一遍。所以我们一起来看一下下面这个问题。</p><h4 id="为什么要让副作用函数每次组件更新都执行一遍？"><a href="#为什么要让副作用函数每次组件更新都执行一遍？" class="headerlink" title="为什么要让副作用函数每次组件更新都执行一遍？"></a>为什么要让副作用函数每次组件更新都执行一遍？</h4><p>我们先看以前的模式：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">componentDidMount() &#123;
  ChatAPI.subscribeToFriendStatus(
    this.props.friend.id,
    this.handleStatusChange
  );
&#125;

componentWillUnmount() &#123;
  ChatAPI.unsubscribeFromFriendStatus(
    this.props.friend.id,
    this.handleStatusChange
  );
&#125;</code></pre><p>很清除，我们在componentDidMount注册，再在componentWillUnmount清除注册。但假如这时候props.friend.id变了怎么办？我们不得不再添加一个componentDidUpdate来处理这种情况：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">...
  componentDidUpdate(prevProps) &#123;
    &#x2F;&#x2F; 先把上一个friend.id解绑
    ChatAPI.unsubscribeFromFriendStatus(
      prevProps.friend.id,
      this.handleStatusChange
    );
    &#x2F;&#x2F; 再重新注册新但friend.id
    ChatAPI.subscribeToFriendStatus(
      this.props.friend.id,
      this.handleStatusChange
    );
  &#125;
...</code></pre><p>看到了吗？很繁琐，而我们但useEffect则没这个问题，因为它在每次组件更新后都会重新执行一遍。所以代码的执行顺序是这样的：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">1.页面首次渲染
2.替friend.id&#x3D;1的朋友注册

3.突然friend.id变成了2
4.页面重新渲染
5.清除friend.id&#x3D;1的绑定
6.替friend.id&#x3D;2的朋友注册
...</code></pre><h4 id="怎么跳过一些不必要的副作用函数"><a href="#怎么跳过一些不必要的副作用函数" class="headerlink" title="怎么跳过一些不必要的副作用函数"></a>怎么跳过一些不必要的副作用函数</h4><p>按照上一节的思路，每次重新渲染都要执行一遍这些副作用函数，显然是不经济的。怎么跳过一些不必要的计算呢？我们只需要给useEffect传第二个参数即可。用第二个参数来告诉react只有当这个参数的值发生改变时，才执行我们传的副作用函数（第一个参数）。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">useEffect(() &#x3D;&gt; &#123;
  document.title &#x3D; &#96;You clicked $&#123;count&#125; times&#96;;
&#125;, [count]); &#x2F;&#x2F; 只有当count的值发生变化时，才会重新执行&#96;document.title&#96;这一句</code></pre><p>当我们第二个参数传一个空数组[]时，其实就相当于只在首次渲染的时候执行。也就是componentDidMount加componentWillUnmount的模式。不过这种用法可能带来bug，少用。</p><h3 id="还有哪些自带的Effect-Hooks"><a href="#还有哪些自带的Effect-Hooks" class="headerlink" title="还有哪些自带的Effect Hooks?"></a>还有哪些自带的Effect Hooks?</h3><p>除了上文重点介绍的useState和useEffect，react还给我们提供来很多有用的hooks：<br>useContext<br>useReducer<br>useCallback<br>useMemo<br>useRef<br>useImperativeMethods<br>useMutationEffect<br>useLayoutEffect</p><h3 id="怎么写自定义的Effect-Hooks"><a href="#怎么写自定义的Effect-Hooks" class="headerlink" title="怎么写自定义的Effect Hooks?"></a>怎么写自定义的Effect Hooks?</h3><p>为什么要自己去写一个Effect Hooks? 这样我们才能把可以复用的逻辑抽离出来，变成一个个可以随意插拔的“插销”，哪个组件要用来，我就插进哪个组件里，so easy！看一个完整的例子，你就明白了。</p><p>比如我们可以把上面写的FriendStatus组件中判断朋友是否在线的功能抽出来，新建一个useFriendStatus的hook专门用来判断某个id是否在线。</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">import &#123; useState, useEffect &#125; from &#39;react&#39;;

function useFriendStatus(friendID) &#123;
  const [isOnline, setIsOnline] &#x3D; useState(null);

  function handleStatusChange(status) &#123;
    setIsOnline(status.isOnline);
  &#125;

  useEffect(() &#x3D;&gt; &#123;
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () &#x3D;&gt; &#123;
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    &#125;;
  &#125;);

  return isOnline;
&#125;</code></pre><p>这时候FriendStatus组件就可以简写为：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function FriendStatus(props) &#123;
  const isOnline &#x3D; useFriendStatus(props.friend.id);

  if (isOnline &#x3D;&#x3D;&#x3D; null) &#123;
    return &#39;Loading...&#39;;
  &#125;
  return isOnline ? &#39;Online&#39; : &#39;Offline&#39;;
&#125;</code></pre><p>简直Perfect！假如这个时候我们又有一个朋友列表也需要显示是否在线的信息：</p><pre class="line-numbers language-js" data-language="js"><code class="language-js">function FriendListItem(props) &#123;
  const isOnline &#x3D; useFriendStatus(props.friend.id);

  return (
    &lt;li style&#x3D;&#123;&#123; color: isOnline ? &#39;green&#39; : &#39;black&#39; &#125;&#125;&gt;
      &#123;props.friend.name&#125;
    &lt;&#x2F;li&gt;
  );
&#125;</code></pre><p>简直Fabulous！</p></div><div class="post-footer"><div></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/blog/2018/11/55206.html" class="pre-post btn btn-default" title="单元测试指南"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">单元测试指南</span> </a><a href="/blog/2018/11/27877.html" class="next-post btn btn-default" title="Java8新特性及使用(二)"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">Java8新特性及使用(二)</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><p>评论系统未开启，无法评论！</p></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2669241897" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></main><aside class="col-md-4 sidebar"><div class="widget"><h3 class="title">赞助广告</h3><ins class="adsbygoogle" style="display:block;width:100%;height:280px" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2014094445" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><p style="text-align:center">想要出现再此！</p></div><div class="widget"><h3 class="title">分类</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/category/Mac-OS/"><i class="fa" aria-hidden="true">Mac OS</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Nuxtjs/"><i class="fa" aria-hidden="true">Nuxtjs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Objective-C/"><i class="fa" aria-hidden="true">Objective-C</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/babel/"><i class="fa" aria-hidden="true">babel</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/css/"><i class="fa" aria-hidden="true">css</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/danger/"><i class="fa" aria-hidden="true">danger</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/data-structure/"><i class="fa" aria-hidden="true">data structure</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/design/"><i class="fa" aria-hidden="true">design</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es6/"><i class="fa" aria-hidden="true">es6</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es7/"><i class="fa" aria-hidden="true">es7</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/eslint/"><i class="fa" aria-hidden="true">eslint</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/flutter/"><i class="fa" aria-hidden="true">flutter</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/git/"><i class="fa" aria-hidden="true">git</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/github/"><i class="fa" aria-hidden="true">github</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/golang/"><i class="fa" aria-hidden="true">golang</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/http/"><i class="fa" aria-hidden="true">http</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/java/"><i class="fa" aria-hidden="true">java</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/javascript/"><i class="fa" aria-hidden="true">javascript</i></a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/jest/"><i class="fa" aria-hidden="true">jest</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/koa/"><i class="fa" aria-hidden="true">koa</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/lerna/"><i class="fa" aria-hidden="true">lerna</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/linux/"><i class="fa" aria-hidden="true">linux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/mysql/"><i class="fa" aria-hidden="true">mysql</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/netlify/"><i class="fa" aria-hidden="true">netlify</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nginx/"><i class="fa" aria-hidden="true">nginx</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nodejs/"><i class="fa" aria-hidden="true">nodejs</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/npm/"><i class="fa" aria-hidden="true">npm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/programm/"><i class="fa" aria-hidden="true">programm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/react/"><i class="fa" aria-hidden="true">react</i></a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux/"><i class="fa" aria-hidden="true">redux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux-thunk/"><i class="fa" aria-hidden="true">redux-thunk</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/regex/"><i class="fa" aria-hidden="true">regex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/rollup/"><i class="fa" aria-hidden="true">rollup</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/shell/"><i class="fa" aria-hidden="true">shell</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/sketch/"><i class="fa" aria-hidden="true">sketch</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/the-super-tiny-compiler/"><i class="fa" aria-hidden="true">the-super-tiny-compiler</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/threejs/"><i class="fa" aria-hidden="true">threejs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/typescript/"><i class="fa" aria-hidden="true">typescript</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vscode/"><i class="fa" aria-hidden="true">vscode</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue/"><i class="fa" aria-hidden="true">vue</i></a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue-router/"><i class="fa" aria-hidden="true">vue-router</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vuex/"><i class="fa" aria-hidden="true">vuex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/webpack/"><i class="fa" aria-hidden="true">webpack</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/wechat/"><i class="fa" aria-hidden="true">wechat</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link current" href="/blog/category/%E5%89%8D%E7%AB%AF/"><i class="fa" aria-hidden="true">前端</i></a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%90%8E%E7%AB%AF/"><i class="fa" aria-hidden="true">后端</i></a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"><i class="fa" aria-hidden="true">建站教程</i></a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="fa" aria-hidden="true">数据库</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%9D%82%E8%B0%88/"><i class="fa" aria-hidden="true">杂谈</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%A7%91%E6%8A%80%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A-%E9%98%AE%E4%B8%80%E5%B3%B0/"><i class="fa" aria-hidden="true">科技爱好者周刊(阮一峰)</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"><i class="fa" aria-hidden="true">编程之道</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><i class="fa" aria-hidden="true">软件工具</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><i class="fa" aria-hidden="true">软件设计</i></a><span class="category-list-count">16</span></li></ul></div><div class="widget"><h3 class="title">归档</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/03/"><i class="fa" aria-hidden="true">2020年03月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/01/"><i class="fa" aria-hidden="true">2020年01月</i></a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/12/"><i class="fa" aria-hidden="true">2019年12月</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/11/"><i class="fa" aria-hidden="true">2019年11月</i></a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/08/"><i class="fa" aria-hidden="true">2019年08月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/07/"><i class="fa" aria-hidden="true">2019年07月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/04/"><i class="fa" aria-hidden="true">2019年04月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/03/"><i class="fa" aria-hidden="true">2019年03月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/02/"><i class="fa" aria-hidden="true">2019年02月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/01/"><i class="fa" aria-hidden="true">2019年01月</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/12/"><i class="fa" aria-hidden="true">2018年12月</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/11/"><i class="fa" aria-hidden="true">2018年11月</i></a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/10/"><i class="fa" aria-hidden="true">2018年10月</i></a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/09/"><i class="fa" aria-hidden="true">2018年09月</i></a><span class="archive-list-count">21</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/08/"><i class="fa" aria-hidden="true">2018年08月</i></a><span class="archive-list-count">17</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/07/"><i class="fa" aria-hidden="true">2018年07月</i></a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/06/"><i class="fa" aria-hidden="true">2018年06月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/05/"><i class="fa" aria-hidden="true">2018年05月</i></a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/04/"><i class="fa" aria-hidden="true">2018年04月</i></a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/03/"><i class="fa" aria-hidden="true">2018年03月</i></a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><h3 class="title">标签云</h3><div class="content tag-cloud"><a href="/blog/tagged/Apache/" style="font-size:13.33px">Apache</a> <a href="/blog/tagged/CPU%E7%BC%93%E5%AD%98/" style="font-size:10px">CPU缓存</a> <a href="/blog/tagged/CSS/" style="font-size:10px">CSS</a> <a href="/blog/tagged/Cryptojs/" style="font-size:10px">Cryptojs</a> <a href="/blog/tagged/DevOps/" style="font-size:10px">DevOps</a> <a href="/blog/tagged/Equality-operator/" style="font-size:10px">Equality operator</a> <a href="/blog/tagged/Fenix/" style="font-size:10px">Fenix</a> <a href="/blog/tagged/Git/" style="font-size:10px">Git</a> <a href="/blog/tagged/GitLab-CI/" style="font-size:10px">GitLab CI</a> <a href="/blog/tagged/Google/" style="font-size:10px">Google</a> <a href="/blog/tagged/JAVA-HOME/" style="font-size:10px">JAVA_HOME</a> <a href="/blog/tagged/JPA/" style="font-size:10px">JPA</a> <a href="/blog/tagged/Java/" style="font-size:20px">Java</a> <a href="/blog/tagged/JavaScript/" style="font-size:14.44px">JavaScript</a> <a href="/blog/tagged/Jenkins/" style="font-size:10px">Jenkins</a> <a href="/blog/tagged/Linux/" style="font-size:13.33px">Linux</a> <a href="/blog/tagged/MVEL/" style="font-size:11.11px">MVEL</a> <a href="/blog/tagged/Markdown/" style="font-size:10px">Markdown</a> <a href="/blog/tagged/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/blog/tagged/React-Fire/" style="font-size:10px">React Fire</a> <a href="/blog/tagged/Semicolon/" style="font-size:10px">Semicolon</a> <a href="/blog/tagged/Spring/" style="font-size:11.11px">Spring</a> <a href="/blog/tagged/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/blog/tagged/Typora/" style="font-size:10px">Typora</a> <a href="/blog/tagged/UML/" style="font-size:11.11px">UML</a> <a href="/blog/tagged/Vue/" style="font-size:10px">Vue</a> <a href="/blog/tagged/ajax/" style="font-size:10px">ajax</a> <a href="/blog/tagged/analysis-package/" style="font-size:10px">analysis package</a> <a href="/blog/tagged/async/" style="font-size:10px">async</a> <a href="/blog/tagged/cheerio/" style="font-size:10px">cheerio</a> <a href="/blog/tagged/commit-message/" style="font-size:10px">commit message</a> <a href="/blog/tagged/communication/" style="font-size:10px">communication</a> <a href="/blog/tagged/component/" style="font-size:10px">component</a> <a href="/blog/tagged/currying/" style="font-size:10px">currying</a> <a href="/blog/tagged/decorator/" style="font-size:10px">decorator</a> <a href="/blog/tagged/fiber/" style="font-size:10px">fiber</a> <a href="/blog/tagged/fix-bug/" style="font-size:10px">fix bug</a> <a href="/blog/tagged/function/" style="font-size:10px">function</a> <a href="/blog/tagged/git-clone/" style="font-size:10px">git clone</a> <a href="/blog/tagged/golang/" style="font-size:10px">golang</a> <a href="/blog/tagged/hexo/" style="font-size:14.44px">hexo</a> <a href="/blog/tagged/hooks/" style="font-size:10px">hooks</a> <a href="/blog/tagged/http/" style="font-size:10px">http</a> <a href="/blog/tagged/justify/" style="font-size:10px">justify</a> <a href="/blog/tagged/let/" style="font-size:10px">let</a> <a href="/blog/tagged/login/" style="font-size:10px">login</a> <a href="/blog/tagged/module/" style="font-size:11.11px">module</a> <a href="/blog/tagged/nginx/" style="font-size:11.11px">nginx</a> <a href="/blog/tagged/note/" style="font-size:18.89px">note</a> <a href="/blog/tagged/npm/" style="font-size:11.11px">npm</a> <a href="/blog/tagged/npx/" style="font-size:10px">npx</a> <a href="/blog/tagged/open/" style="font-size:10px">open</a> <a href="/blog/tagged/package/" style="font-size:10px">package</a> <a href="/blog/tagged/package-json/" style="font-size:10px">package.json</a> <a href="/blog/tagged/path/" style="font-size:10px">path</a> <a href="/blog/tagged/pm2/" style="font-size:11.11px">pm2</a> <a href="/blog/tagged/promise/" style="font-size:10px">promise</a> <a href="/blog/tagged/refs/" style="font-size:10px">refs</a> <a href="/blog/tagged/rem/" style="font-size:10px">rem</a> <a href="/blog/tagged/render/" style="font-size:10px">render</a> <a href="/blog/tagged/require/" style="font-size:10px">require</a> <a href="/blog/tagged/rzero/" style="font-size:10px">rzero</a> <a href="/blog/tagged/selector/" style="font-size:10px">selector</a> <a href="/blog/tagged/service/" style="font-size:10px">service</a> <a href="/blog/tagged/setTimeout/" style="font-size:10px">setTimeout</a> <a href="/blog/tagged/source/" style="font-size:16.67px">source</a> <a href="/blog/tagged/ssh/" style="font-size:10px">ssh</a> <a href="/blog/tagged/ssr/" style="font-size:10px">ssr</a> <a href="/blog/tagged/timer/" style="font-size:10px">timer</a> <a href="/blog/tagged/tools/" style="font-size:10px">tools</a> <a href="/blog/tagged/tree-shaking/" style="font-size:10px">tree-shaking</a> <a href="/blog/tagged/typecho/" style="font-size:15.56px">typecho</a> <a href="/blog/tagged/typecho%E6%8F%92%E4%BB%B6/" style="font-size:15.56px">typecho插件</a> <a href="/blog/tagged/types/" style="font-size:10px">types</a> <a href="/blog/tagged/utils/" style="font-size:10px">utils</a> <a href="/blog/tagged/virtual-dom/" style="font-size:10px">virtual dom</a> <a href="/blog/tagged/vscode/" style="font-size:10px">vscode</a> <a href="/blog/tagged/wasm/" style="font-size:13.33px">wasm</a> <a href="/blog/tagged/webassembly/" style="font-size:13.33px">webassembly</a> <a href="/blog/tagged/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size:10px">位运算</a> <a href="/blog/tagged/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size:11.11px">单元测试</a> <a href="/blog/tagged/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" style="font-size:10px">性能测试</a> <a href="/blog/tagged/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/" style="font-size:10px">整洁代码</a> <a href="/blog/tagged/%E6%B5%8B%E8%AF%95/" style="font-size:10px">测试</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size:10px">设计原则</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:17.78px">设计模式</a> <a href="/blog/tagged/%E9%87%8D%E6%9E%84/" style="font-size:10px">重构</a> <a href="/blog/tagged/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" style="font-size:12.22px">面向对象编程</a></div></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi"></div></div><div class="col-sm-12"><span>Copyright &copy; 2021 - 2023 Liuxfe</span></div></div></div></div><script src="/js/app.js?rev=@@hash.js"></script><script>!function(e,t,c,n,r,a){e.ym=e.ym||function(){(e.ym.a=e.ym.a||[]).push(arguments)},e.ym.l=+new Date;for(var m=0;m<document.scripts.length;m++)if(document.scripts[m].src===n)return;r=t.createElement(c),a=t.getElementsByTagName(c)[0],r.async=1,r.src=n,a.parentNode.insertBefore(r,a)}(window,document,"script","https://mc.yandex.ru/metrika/tag.js"),ym(93104114,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script></body></html>