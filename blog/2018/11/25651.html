<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="Liuxfe的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="keywords" content="Java"><meta name="description" content="新特性列表以下是Java6中的引入的部分新特性，相比Java5的新特性就少了很多了。关于Java6更详细的介绍可参考这里。

Web Services Metadata
Scripting
Co..."><title>Java6新特性及使用 | Liuxfe的博客</title><link rel="icon" href="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7.css"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0.css"><link rel="stylesheet" href="/css/style.css?rev=@@hash.css"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9312750344484857" crossorigin="anonymous"></script></head><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(https://hexo-theme-snippet-1251680922.cos.ap-beijing.myqcloud.com/img/banner.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="Liuxfe"><img src="https://cdn.jsdelivr.net/gh/liuxfe/assets/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>-------------</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="https://www.liuxfe.com">Liuxfe的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i> 首页</a></li><li role="presentation" class="text-center"><a href="/blog/"><i class="fa"></i> 博客</a></li><li role="presentation" class="text-center"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://link.liuxfe.com/GlreA"><i class="fa"></i> 维基镜像</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="Java6新特性及使用">Java6新特性及使用</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="/blog/category/%E5%90%8E%E7%AB%AF/">后端</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-none-link" href="/blog/tagged/Java/" rel="tag">Java</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2018/11/11</span></span></div><p class="fa fa-exclamation-triangle warning">本文于<strong> 1780</strong> 天之前发表，文中内容可能已经过时。</p></div><div class="post-body post-content"><h2 id="新特性列表"><a href="#新特性列表" class="headerlink" title="新特性列表"></a>新特性列表</h2><p>以下是Java6中的引入的部分新特性，相比Java5的新特性就少了很多了。关于Java6更详细的介绍可参考<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.oracle.com/technetwork/java/javase/features-141434.html">这里</a>。</p><ul><li>Web Services Metadata</li><li>Scripting</li><li>Compiler API</li><li>Light-weight HTTP server</li><li>Common annotations(JSR 250)</li><li>StAX</li><li>JAXB2</li><li>Console</li><li>Java DB(Derby)</li><li>JDBC 4.0</li><li>值得关注的<ul><li>集合框架增强</li></ul></li><li>其它<ul><li>GUI增强</li></ul></li></ul><h2 id="一、Web-Services-Metadata"><a href="#一、Web-Services-Metadata" class="headerlink" title="一、Web Services Metadata"></a>一、Web Services Metadata</h2><p><code>WebService</code>是一种独立于特定语言、特定平台，基于网络的、分布式的模块化组件。是一个能够使用<code>xml</code>消息通过网络来访问的接口，这个接口描述了一组可访问的操作。在Java6中，在想要发布为<code>WebService</code>的类上加上<code>@WebService</code>的注解，这个类的方法就变为<code>WebService</code>方法了，再通过<code>Endpoint.publish()</code>方法发布这个服务。到此，一个最简单的<code>WebService</code>搞定。运行<code>main</code>方法，在浏览器里输入<code>http://localhost:8080/com.blinkfox.test.Hello?wsdl</code>，即可查看你WebService的WSDL信息。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.jws.WebService;
import javax.xml.ws.Endpoint;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

&#x2F;**
 * Hello.
 * @author blinkfox on 2017-11-28.
 *&#x2F;
@WebService
public class Hello &#123;

    private static final Logger log &#x3D; LoggerFactory.getLogger(Hello.class);

    &#x2F;**
     * sayHello.
     * @param name 名称
     * @return 结果
     *&#x2F;
    public String sayHello(String name) &#123;
        return &quot;Hello &quot;.concat(name);
    &#125;

    &#x2F;**
     * @param args
     *&#x2F;
    public static void main(String[] args) &#123;
        Endpoint.publish(&quot;http:&#x2F;&#x2F;localhost:8080&#x2F;com.blinkfox.test.Hello&quot;, new Hello());
        log.info(&quot;调用成功!&quot;);
    &#125;

&#125;</code></pre><p>Java 自从JDK5中添加了元数据功能(注解)之后,SUN几乎重构了整个J2EE体系，由于变化很大，干脆将名字也重构为Java EE，Java EE(当前版本为5.0)将元数据纳入很多规范当中，这其中就包括<code>Web Services</code>的相关规范，这显然比以前的JAX-RPC编程模型简单(当然, Axis的编程模型也很简单)。这里要谈的Web服务元数据(JSR 181)只是Java Web 服务规范中的一个,它跟Common Annotations, JAXB2, StAX, SAAJ和JAX-WS等共同构成Java EE 5的Web Services技术堆栈。</p><p>下面介绍<code>JSR-181</code>里面各个元数据的相关参数及用途。</p><table><thead><tr><th>Annotation</th><th>Retention</th><th>Target</th><th>Description</th></tr></thead><tbody><tr><td>WebService</td><td>Runtime</td><td>Type</td><td>标注要暴露为Web Services的类或接口</td></tr><tr><td>WebParam</td><td>Runtime</td><td>Parameter</td><td>自定义服务方法参数到WSDL的映射</td></tr><tr><td>WebResult</td><td>Runtime</td><td>Method</td><td>自定义服务方法返回值到WSDL的映射</td></tr><tr><td>WebMethod</td><td>Runtime</td><td>Method</td><td>自定义单个服务方法到WSDL的映射</td></tr><tr><td>Oneway</td><td>Runtime</td><td>Method</td><td>必须与@WebMethod连用,表明被标注方法只有输入没有输出,这就要求被标注方法不能有返回值,也不能声明checked exception</td></tr><tr><td>HandlerChain</td><td>Runtime</td><td>Type,Method,Field</td><td>将Web服务与外部Handler chain关联起来</td></tr><tr><td>SOAPBinding</td><td>Runtime</td><td>Type,Method</td><td>自定义<code>SOAPBinding</code></td></tr></tbody></table><h2 id="二、Scripting"><a href="#二、Scripting" class="headerlink" title="二、Scripting"></a>二、Scripting</h2><p>Java6增加了对动态语言的支持，原理上是将脚本语言编译成字节码，这样脚本语言也能享用Java平台的诸多优势，包括可移植性，安全等。另外由于现在是编译成字节码后再执行，所以比原来边解释边执行效率要高很多。可以很好的利用脚本语言的动态特性，主要支持的有<code>JavaSrcipt</code>、<code>Ruby</code>、<code>Python</code>等。</p><p>以下使用<code>JavaScript</code>的脚本，代码示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.script.Invocable;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

&#x2F;**
 * JsTest.
 * @author blinkfox
 * @version 1.0
 *
 *&#x2F;
public class JsTest &#123;

    private static final Logger log &#x3D; LoggerFactory.getLogger(Hello.class);

    &#x2F;**
     * main方法.
     * @param args 数组参数
     * @throws ScriptException 脚本异常
     * @throws NoSuchMethodException 无方法异常
     *&#x2F;
    public static void main(String[] args) throws ScriptException, NoSuchMethodException &#123;
        ScriptEngineManager enjineManager &#x3D; new ScriptEngineManager();
        ScriptEngine engine &#x3D; enjineManager.getEngineByName(&quot;JavaScript&quot;);

        String script&#x3D;&quot;function hello(name)&#123;return &#39;Hello &#39; + name&#125;&quot;;
        engine.eval(script);
        Invocable inv&#x3D;(Invocable) engine;
        String result &#x3D; (String) inv.invokeFunction(&quot;hello&quot;, &quot;blinkfox&quot;);
        log.info(&quot;脚本执行结果:&#123;&#125;&quot;, result);
    &#125;

&#125;</code></pre><h2 id="三、Compiler-API"><a href="#三、Compiler-API" class="headerlink" title="三、Compiler API"></a>三、Compiler API</h2><p>在Java6中提供了一套<code>Compiler API</code>，定义在<code>JSR199</code>中, 提供在运行期动态编译java代码为字节码的功能。一套API就好比是在java程序中模拟javac程序，将Java源文件编译为class文件；其提供的默认实现也正是在文件系统上进行查找、编译工作的。<code>Compiler API</code>结合反射功能就可以实现动态的产生Java代码并编译执行这些代码，有点动态语言的特征。</p><p>基本使用示例如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class JavaCompilerAPICompiler &#123;

    public void compile(Path src, Path output) throws IOException &#123;
        JavaCompiler compiler &#x3D; ToolProvider.getSystemJavaCompiler();
        try (StandardJavaFileManager fileManager &#x3D; compiler.getStandardFileManager(null, null, null)) &#123;
            Iterable&lt;? extends JavaFileObject&gt; compilationUnits &#x3D; fileManager.getJavaFileObjects(src.toFile());
            Iterable&lt;String&gt; options &#x3D; Arrays.asList(&quot;-d&quot;, output.toString());
            JavaCompiler.CompilationTask task &#x3D; compiler.getTask(null, fileManager, null, options, null, compilationUnits);
            boolean result &#x3D; task.call();
        &#125;
    &#125;

&#125;</code></pre><h2 id="四、轻量级HTTP-server"><a href="#四、轻量级HTTP-server" class="headerlink" title="四、轻量级HTTP server"></a>四、轻量级HTTP server</h2><p>JDK6提供了一个轻量级的<code>Http Server API</code>，据此我们可以构建自己的嵌入式Http Server，它支持<code>Http</code>和<code>Https</code>协议,提供了HTTP1.1的部分实现，没有被实现的那部分可以通过扩展已有的Http Server API来实现，程序员必须自己实现<code>HttpHandler</code>接口，HttpServer会调用<code>HttpHandler</code>实现类的回调方法来处理客户端请求，在这里，我们把一个Http请求和它的响应称为一个交换,包装成<code>HttpExchange</code>类,HttpServer负责将<code>HttpExchange</code>传给<code>HttpHandler</code>实现类的回调方法。</p><p>以下是通过JDK6新特性能够实现的HttpServer的示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.sun.net.httpserver.HttpExchange;
import com.sun.net.httpserver.HttpHandler;
import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.spi.HttpServerProvider;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;

&#x2F;**
 * 自定义的http服务器.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class MyHttpServer &#123;

    &#x2F;**
     * 启动服务，监听来自客户端的请求.
     *
     * @throws IOException IO异常
     *&#x2F;
    private static void httpserverService() throws IOException &#123;
        HttpServerProvider provider &#x3D; HttpServerProvider.provider();
        HttpServer httpserver &#x3D; provider.createHttpServer(new InetSocketAddress(8888), 200); &#x2F;&#x2F; 监听端口8888,能同时接受100个请求
        httpserver.createContext(&quot;&#x2F;mytest&quot;, new MyHttpHandler());
        httpserver.setExecutor(null);
        httpserver.start();
        System.out.println(&quot;server started&quot;);
    &#125;

    &#x2F;**
     * Http请求处理类.
     *&#x2F;
    private static class MyHttpHandler implements HttpHandler &#123;

        public void handle(HttpExchange httpExchange) throws IOException &#123;
            String responseMsg &#x3D; &quot;ok&quot;; &#x2F;&#x2F;响应信息
            InputStream in &#x3D; httpExchange.getRequestBody(); &#x2F;&#x2F;获得输入流
            BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(in));
            String temp &#x3D; null;
            while((temp &#x3D; reader.readLine()) !&#x3D; null) &#123;
                System.out.println(&quot;client request:&quot; + temp);
            &#125;
            httpExchange.sendResponseHeaders(200, responseMsg.length()); &#x2F;&#x2F;设置响应头属性及响应信息的长度
            OutputStream out &#x3D; httpExchange.getResponseBody();  &#x2F;&#x2F;获得输出流
            out.write(responseMsg.getBytes());
            out.flush();
            httpExchange.close();
        &#125;

    &#125;

    public static void main(String[] args) throws IOException &#123;
        httpserverService();
    &#125;

&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

&#x2F;**
 * Http服务器测试类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class HttpTest &#123;

    public static void main(String[] args) &#123;
        ExecutorService exec &#x3D; Executors.newCachedThreadPool();
        &#x2F;&#x2F; 测试并发对MyHttpServer的影响
        for (int i &#x3D; 0; i &lt; 20; i++) &#123;
            Runnable run &#x3D; new Runnable() &#123;
                public void run() &#123;
                    try &#123;
                        startWork();
                    &#125; catch (IOException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;;
            exec.execute(run);
        &#125;
        exec.shutdown();&#x2F;&#x2F; 关闭线程池
    &#125;

    public static void startWork() throws IOException &#123;
        URL url &#x3D; new URL(&quot;http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;mytest&quot;);
        HttpURLConnection urlConn &#x3D; (HttpURLConnection) url.openConnection();
        urlConn.setDoOutput(true);
        urlConn.setDoInput(true);
        urlConn.setRequestMethod(&quot;POST&quot;);
        &#x2F;&#x2F; 测试内容包
        String teststr &#x3D; &quot;this is a test message&quot;;
        OutputStream out &#x3D; urlConn.getOutputStream();
        out.write(teststr.getBytes());
        out.flush();
        while (urlConn.getContentLength() !&#x3D; -1) &#123;
            if (urlConn.getResponseCode() &#x3D;&#x3D; 200) &#123;
                InputStream in &#x3D; urlConn.getInputStream();
                BufferedReader reader &#x3D; new BufferedReader(new InputStreamReader(in));
                String temp &#x3D; &quot;&quot;;
                while ((temp &#x3D; reader.readLine()) !&#x3D; null) &#123;
                    System.err.println(&quot;server response:&quot; + temp);&#x2F;&#x2F; 打印收到的信息
                &#125;
                reader.close();
                in.close();
                urlConn.disconnect();
            &#125;
        &#125;
    &#125;

&#125;</code></pre><h2 id="五、Common-annotations"><a href="#五、Common-annotations" class="headerlink" title="五、Common annotations"></a>五、Common annotations</h2><p><code>Common annotations</code>原本是Java EE 5.0(JSR 244)规范的一部分，现在SUN把它的一部分放到了Java SE 6.0中.随着Annotation元数据功能(JSR 175)加入到Java SE 5.0里面，很多Java 技术(比如EJB,Web Services)都会用Annotation部分代替XML文件来配置运行参数（或者说是支持声明式编程,如EJB的声明式事务）, 如果这些技术为通用目的都单独定义了自己的Annotations,显然有点重复建设, 所以,为其他相关的Java技术定义一套公共的Annotation是有价值的，可以避免重复建设的同时，也保证Java SE和Java EE 各种技术的一致性。</p><p>下面列举出<code>Common Annotations 1.0</code>里面的10个<code>Annotations</code>：</p><table><thead><tr><th align="left"><strong>Annotation</strong></th><th align="center"><strong>Retention</strong></th><th align="left"><strong>Target</strong></th><th align="left"><strong>Description</strong></th></tr></thead><tbody><tr><td align="left">Generated</td><td align="center">Source</td><td align="left">ANNOTATION_TYPE, CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE</td><td align="left">用于标注生成的源代码</td></tr><tr><td align="left">Resource</td><td align="center">Runtime</td><td align="left">TYPE, METHOD, FIELD</td><td align="left">用于标注所依赖的资源,容器据此注入外部资源依赖，有基于字段的注入和基于setter方法的注入两种方式</td></tr><tr><td align="left">Resources</td><td align="center">Runtime</td><td align="left">TYPE</td><td align="left">同时标注多个外部依赖，容器会把所有这些外部依赖注入</td></tr><tr><td align="left">PostConstruct</td><td align="center">Runtime</td><td align="left">METHOD</td><td align="left">标注当容器注入所有依赖之后运行的方法，用来进行依赖注入后的初始化工作，只有一个方法可以标注为PostConstruct</td></tr><tr><td align="left">PreDestroy</td><td align="center">Runtime</td><td align="left">METHOD</td><td align="left">当对象实例将要被从容器当中删掉之前，要执行的回调方法要标注为PreDestroy</td></tr><tr><td align="left">RunAs</td><td align="center">Runtime</td><td align="left">TYPE</td><td align="left">用于标注用什么安全角色来执行被标注类的方法，这个安全角色必须和Container 的Security角色一致的</td></tr><tr><td align="left">RolesAllowed</td><td align="center">Runtime</td><td align="left">TYPE, METHOD</td><td align="left">用于标注允许执行被标注类或方法的安全角色，这个安全角色必须和Container 的Security角色一致的</td></tr><tr><td align="left">PermitAll</td><td align="center">Runtime</td><td align="left">TYPE, METHOD</td><td align="left">允许所有角色执行被标注的类或方法</td></tr><tr><td align="left">DenyAll</td><td align="center">Runtime</td><td align="left">TYPE, METHOD</td><td align="left">不允许任何角色执行被标注的类或方法，表明该类或方法不能在Java EE容器里面运行</td></tr><tr><td align="left">DeclareRoles</td><td align="center">Runtime</td><td align="left">TYPE</td><td align="left">用来定义可以被应用程序检验的安全角色，通常用isUserInRole来检验安全角色</td></tr></tbody></table><h2 id="六、StAX"><a href="#六、StAX" class="headerlink" title="六、StAX"></a>六、StAX</h2><p>StAX(JSR 173)是JDK6中新增的除了DOM和SAX之外的又一种处理XML文档的API。</p><p><code>StAX</code>是<code>The Streaming API for XML</code>的缩写，一种利用拉模式解析(pull-parsing)XML文档的API。StAX通过提供一种基于事件迭代器(Iterator)的API让程序员去控制xml文档解析过程,程序遍历这个事件迭代器去处理每一个解析事件，解析事件可以看做是程序拉出来的，也就是程序促使解析器产生一个解析事件然后处理该事件，之后又促使解析器产生下一个解析事件，如此循环直到碰到文档结束符；SAX也是基于事件处理xml文档，但却是用推模式解析，解析器解析完整个xml文档后，才产生解析事件，然后推给程序去处理这些事件；DOM采用的方式是将整个xml文档映射到一颗内存树，这样就可以很容易地得到父节点和子结点以及兄弟节点的数据，但如果文档很大，将会严重影响性能。</p><p>下面是这几种XML解析API的特性比较：</p><table><thead><tr><th>Feature</th><th>StAX</th><th>SAX</th><th>DOM</th><th>TrAX</th></tr></thead><tbody><tr><td>API Type</td><td>Pull, streaming</td><td>Push, streaming</td><td>In memory tree</td><td>XSLT Rule</td></tr><tr><td>Ease of Use</td><td>High</td><td>Medium</td><td>High</td><td>Medium</td></tr><tr><td>XPath Capability</td><td>No</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>CPU and Memory Efficiency</td><td>Good</td><td>Good</td><td>Varies</td><td>Varies</td></tr><tr><td>Forward Only</td><td>Yes</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>Read XML</td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>Write XML</td><td>Yes</td><td>No</td><td>Yes</td><td>Yes</td></tr><tr><td>Create, Read, Update, Delete</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr></tbody></table><p>下面代码演示了如何通过StAX读取xml文档和生成xml文档：</p><p>需要读取的xml文件：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;
&lt;catalogs&gt;
    &lt;catalog id&#x3D;&quot;001&quot;&gt;Book&lt;&#x2F;catalog&gt;
    &lt;catalog id&#x3D;&quot;002&quot;&gt;Video&lt;&#x2F;catalog&gt;
&lt;&#x2F;catalogs&gt;</code></pre><p>读和写XML文件的Java代码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import javax.xml.namespace.QName;
import javax.xml.stream.*;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

&#x2F;**
 * Stax测试类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class StaxTester &#123;

    &#x2F;**
     * 根据StAX读取XML文件.
     *
     * @throws XMLStreamException XML流异常
     * @throws FileNotFoundException 文件未找到异常
     *&#x2F;
    private static void readXxmlByStax() throws XMLStreamException, FileNotFoundException &#123;
        XMLInputFactory xmlif &#x3D; XMLInputFactory.newInstance();
        XMLEventReader xmler &#x3D; xmlif.createXMLEventReader(new FileInputStream(&quot;G:\\test\\test.xml&quot;));
        XMLEvent event;
        StringBuilder sb &#x3D; new StringBuilder();
        while (xmler.hasNext()) &#123;
            event &#x3D; xmler.nextEvent();
            if (event.isStartElement()) &#123; &#x2F;&#x2F;如果解析的是起始标记
                StartElement element &#x3D; event.asStartElement();
                sb.append(&quot;&lt;&quot;);
                sb.append(element.getName());
                if(element.getName().getLocalPart().equals(&quot;catalog&quot;)) &#123;
                    sb.append(&quot; id&#x3D;&#x2F;&quot;);
                    sb.append(element.getAttributeByName(new QName(&quot;id&quot;)).getValue());
                    sb.append(&quot;&#x2F;&quot;);
                &#125;
                sb.append(&quot;&gt;&quot;);
            &#125; else if (event.isCharacters()) &#123; &#x2F;&#x2F;如果解析的是文本内容
                sb.append(event.asCharacters().getData());
            &#125; else if(event.isEndElement()) &#123; &#x2F;&#x2F;如果解析的是结束标记
                sb.append(&quot;&lt;&#x2F;&quot;);
                sb.append(event.asEndElement().getName());
                sb.append(&quot;&gt;&quot;);
            &#125;
        &#125;
        System.out.println(sb);
    &#125;

    &#x2F;**
     * 根据StAX写入XML文件.
     *
     * @throws XMLStreamException XML流异常
     * @throws FileNotFoundException 文件未找到异常
     *&#x2F;
    private static void writeXmlByStax() throws XMLStreamException, FileNotFoundException &#123;
        XMLOutputFactory xmlof &#x3D; XMLOutputFactory.newInstance();
        XMLStreamWriter xmlw &#x3D; xmlof.createXMLStreamWriter(new FileOutputStream(&quot;G:\\test\\output.xml&quot;));
        &#x2F;&#x2F; 写入默认的 XML 声明到xml文档
        xmlw.writeStartDocument();
        xmlw.writeCharacters(&quot;\n&quot;);
        &#x2F;&#x2F; 写入注释到xml文档
        xmlw.writeComment(&quot;testing comment&quot;);
        xmlw.writeCharacters(&quot;\n&quot;);
        &#x2F;&#x2F; 写入一个catalogs根元素
        xmlw.writeStartElement(&quot;catalogs&quot;);
        xmlw.writeNamespace(&quot;myNS&quot;, &quot;http:&#x2F;&#x2F;blinkfox.com&quot;);
        xmlw.writeAttribute(&quot;owner&quot;,&quot;Chinajash&quot;);
        xmlw.writeCharacters(&quot;\n&quot;);
        &#x2F;&#x2F; 写入子元素catalog
        xmlw.writeCharacters(&quot;    &quot;);
        xmlw.writeStartElement(&quot;http:&#x2F;&#x2F;blinkfox.com&quot;, &quot;catalog&quot;);
        xmlw.writeAttribute(&quot;id&quot;,&quot;007&quot;);
        xmlw.writeCharacters(&quot;Apparel&quot;);
        &#x2F;&#x2F; 写入catalog元素的结束标签
        xmlw.writeEndElement();
        &#x2F;&#x2F; 写入catalogs元素的结束标签
        xmlw.writeCharacters(&quot;\n&quot;);
        xmlw.writeEndElement();
        &#x2F;&#x2F; 结束 XML 文档
        xmlw.writeEndDocument();
        xmlw.close();
        System.out.println(&quot;生成xml文件成功!&quot;);
    &#125;

    &#x2F;**
     * main方法.
     *
     * @param args 数组参数
     * @throws XMLStreamException XML流异常
     * @throws FileNotFoundException 文件未找到异常
     *&#x2F;
    public static void main(String[] args) throws XMLStreamException, FileNotFoundException &#123;
        readXxmlByStax();
        writeXmlByStax();
    &#125;

&#125;</code></pre><p>运行上面程序后，控制台输出如下:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&lt;catalogs&gt;
    &lt;catalog id&#x3D;&#x2F;001&#x2F;&gt;Book&lt;&#x2F;catalog&gt;
    &lt;catalog id&#x3D;&#x2F;002&#x2F;&gt;Video&lt;&#x2F;catalog&gt;
&lt;&#x2F;catalogs&gt;
生成xml文件成功!</code></pre><p>产生的<code>output.xml</code>文件如下:</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; ?&gt;
&lt;!--testing comment--&gt;
&lt;catalogs xmlns:myNS&#x3D;&quot;http:&#x2F;&#x2F;blinkfox.com&quot; owner&#x3D;&quot;Chinajash&quot;&gt;
    &lt;myNS:catalog id&#x3D;&quot;007&quot;&gt;Apparel&lt;&#x2F;myNS:catalog&gt;
&lt;&#x2F;catalogs&gt;</code></pre><h2 id="七、JAXB2"><a href="#七、JAXB2" class="headerlink" title="七、JAXB2"></a>七、JAXB2</h2><p><code>JAXB</code>是<code>Java Architecture for XML Binding</code>的缩写，可以将一个Java对象转变成为XML格式，反之亦然。我们把对象与关系数据库之间的映射称为ORM, 其实也可以把对象与XML之间的映射称为<code>OXM</code>(Object XML Mapping). 原来JAXB是Java EE的一部分，在JDK6中，SUN将其放到了Java SE中，这也是SUN的一贯做法。JDK6中自带的这个JAXB版本是2.0, 比起1.0(JSR 31)来，JAXB2(JSR 222)用JDK5的新特性<code>Annotation</code>来标识要作绑定的类和属性等，这就极大简化了开发的工作量。实际上，在Java EE 5.0中，EJB和Web Services也通过Annotation来简化开发工作。另外,JAXB2在底层是用StAX(JSR 173)来处理XML文档。 下面用代码演示在JDK6中如何来用<code>JAXB2</code>：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;**
 * Gender性别枚举类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public enum Gender &#123;

    MALE(true),

    FEMALE (false);

    private boolean code;

    &#x2F;**
     * 构造方法.
     * @param code 性别值
     *&#x2F;
    Gender(boolean code) &#123;
        this.code &#x3D; code;
    &#125;

&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;

&#x2F;**
 * Address地址类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class Address &#123;

    @XmlAttribute
    String country;

    @XmlElement
    String state;

    @XmlElement
    String city;

    @XmlElement
    String street;

    &#x2F;** 由于没有添加@XmlElement,所以该元素不会出现在输出的xml中. *&#x2F;
    String zipcode;

    &#x2F;**
     * 默认的空构造方法.
     *&#x2F;
    public Address() &#123;
        super();
    &#125;

    public Address(String country, String state, String city, String street, String zipcode) &#123;
        this.country &#x3D; country;
        this.state &#x3D; state;
        this.city &#x3D; city;
        this.street &#x3D; street;
        this.zipcode &#x3D; zipcode;
    &#125;

    &#x2F;**
     * country的getter方法.
     *
     * @return country
     *&#x2F;
    public String getCountry() &#123;
        return country;
    &#125;

&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Calendar;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;

&#x2F;**
 * Person类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
@XmlRootElement
public class Person &#123;

    &#x2F;** birthday将作为person的子元素. *&#x2F;
    @XmlElement
    Calendar birthDay;

    &#x2F;** name将作为person的的一个属性. *&#x2F;
    @XmlAttribute
    String name;

    &#x2F;** address将作为person的子元素. *&#x2F;
    @XmlElement
    Address address;

    &#x2F;** gender将作为person的子元素. *&#x2F;
    @XmlElement
    Gender gender;

    &#x2F;** job将作为person的子元素. *&#x2F;
    @XmlElement
    String job;

    &#x2F;**
     * 默认的空构造方法.
     *&#x2F;
    public Person() &#123;
        super();
    &#125;

    public Person(Calendar birthDay, String name, Address address, Gender gender, String job) &#123;
        this.birthDay &#x3D; birthDay;
        this.name &#x3D; name;
        this.address &#x3D; address;
        this.gender &#x3D; gender;
        this.job &#x3D; job;
    &#125;

    &#x2F;**
     * address的getter方法.
     * @return address
     *&#x2F;
    public Address getAddress() &#123;
        return address;
    &#125;

&#125;</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.FileReader;
import java.io.FileWriter;
import java.util.Calendar;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;

import org.apache.commons.io.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

&#x2F;**
 * JAXB2测试类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class JAXB2Test &#123;

    private static final Logger log &#x3D; LoggerFactory.getLogger(JAXB2Test.class);

    public static void main(String[] args) &#123;
        Address address &#x3D; new Address(&quot;中国&quot;, &quot;北京&quot;, &quot;北京&quot;, &quot;上地&quot;, &quot;100080&quot;);
        Person p &#x3D; new Person(Calendar.getInstance(),&quot;JAXB2&quot;, address, Gender.MALE, &quot;软件工程师&quot;);

        FileReader reader &#x3D; null;
        FileWriter writer &#x3D; null;
        try &#123;
            &#x2F;&#x2F; 生成xml文件.
            JAXBContext context &#x3D; JAXBContext.newInstance(Person.class);
            writer &#x3D; new FileWriter(&quot;G:&#x2F;test&#x2F;person.xml&quot;);
            Marshaller m &#x3D; context.createMarshaller();
            m.marshal(p, writer);
            log.info(&quot;生成person.xml文件成功!&quot;);

            &#x2F;&#x2F; 读取xml文件.
            reader &#x3D; new FileReader(&quot;G:&#x2F;test&#x2F;person.xml&quot;);
            Unmarshaller um &#x3D; context.createUnmarshaller();
            Person p2 &#x3D; (Person) um.unmarshal(reader);
            log.info(&quot;Country:&#123;&#125;&quot;, p2.getAddress().getCountry());
        &#125; catch (Exception e) &#123;
            log.error(&quot;生成和读取XML文件出错！&quot;, e);
        &#125; finally &#123;
            IOUtils.closeQuietly(writer);
            IOUtils.closeQuietly(reader);
        &#125;
    &#125;

&#125;</code></pre><p>运行该程序，我们会得到一个<code>person.xml</code>的文件，内容如下：</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; standalone&#x3D;&quot;yes&quot;?&gt;
&lt;person name&#x3D;&quot;JAXB2&quot;&gt;
    &lt;birthDay&gt;2017-12-04T17:16:19.226+08:00&lt;&#x2F;birthDay&gt;
    &lt;address country&#x3D;&quot;中国&quot;&gt;
        &lt;state&gt;北京&lt;&#x2F;state&gt;
        &lt;city&gt;北京&lt;&#x2F;city&gt;
        &lt;street&gt;上地&lt;&#x2F;street&gt;
    &lt;&#x2F;address&gt;
    &lt;gender&gt;MALE&lt;&#x2F;gender&gt;
    &lt;job&gt;软件工程师&lt;&#x2F;job&gt;
&lt;&#x2F;person&gt;</code></pre><h2 id="八、Console"><a href="#八、Console" class="headerlink" title="八、Console"></a>八、Console</h2><p>JDK6中提供了<code>java.io.Console</code>类专用来访问基于字符的控制台设备。你的程序如果要与Windows下的cmd或者Linux下的Terminal交互,就可以用Console类代劳. 但我们不总是能得到可用的Console, 一个JVM是否有可用的Console依赖于底层平台和JVM如何被调用。如果JVM是在交互式命令行(比如Windows的cmd)中启动的,并且输入输出没有重定向到另外的地方，那么就可以得到一个可用的Console实例。下面代码演示了Console类的用法:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.Console;

&#x2F;**
 * Jdk6之Console测试类.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class ConsoleTest &#123;

    public static void main(String[] args) &#123;
        &#x2F;&#x2F; 获得Console实例，并判断console是否可用
        Console console &#x3D; System.console();
        if (console !&#x3D; null) &#123;
            &#x2F;&#x2F; 读取整行字符和密码，密码输入时不会显示
            String user &#x3D; new String(console.readLine(&quot;请输入用户名:&quot;));
            String pwd &#x3D; new String(console.readPassword(&quot;再输入密码:&quot;));
            console.printf(&quot;用户名是:&quot; + user + &quot;\n&quot;);
            console.printf(&quot;密码是:&quot; + pwd + &quot;\n&quot;);
        &#125; else &#123;
            System.out.println(&quot;Console不可用!&quot;);
        &#125;
    &#125;

&#125;</code></pre><p>编译该代码，并在命令行中输入：<code>java ConsoleTest</code>，然后即可运行，运行示例如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">请输入用户名:张三
再输入密码:
打印出的用户名是:张三
打印出的密码是:123456</code></pre><blockquote><p><strong>注</strong>: 在这里可以看到输入密码时,控制台时不显示这些密码字符的,但是程序可以得到输入的密码字符串,这与Linux下面输入密码的情况是一样的。</p></blockquote><h2 id="九、Java-DB-Derby"><a href="#九、Java-DB-Derby" class="headerlink" title="九、Java DB(Derby)"></a>九、Java DB(Derby)</h2><p>从JDK6开始，JDK目录中新增了一个名为<code>db</code>的目录。这便是 Java 6 的新成员：Java DB。这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目<code>Derby</code>。它只有 2MB 大小，对比动辄上 G 的数据库来说可谓袖珍。但这并不妨碍 Derby 功能齐备，支持几乎大部分的数据库应用所需要的特性。JDK6.0里面带的这个Derby的版本是10.2.1.7,支持存储过程和触发器；有两种运行模式，一种是作为嵌入式数据库，另一种是作为网络数据库。前者的数据库服务器和客户端都在同一个JVM里面运行，后者允许数据库服务器端和客户端不在同一个JVM里面，而且允许这两者在不同的物理机器上。值得注意的是JDK6里面的这个Derby支持JDK6的新特性<code>JDBC 4.0</code>规范(JSR 221)。</p><p>下面分两种情况演示一下如何用代码操作Derby数据库，一种是嵌入式数据库，一种是网络数据库。</p><h3 id="1-嵌入式数据库"><a href="#1-嵌入式数据库" class="headerlink" title="1. 嵌入式数据库"></a>1. 嵌入式数据库</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import com.blinkfox.learn.jdbc.JdbcDaoHelper;

import java.sql.*;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

&#x2F;**
 * Derby内嵌数据库测试示例.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class EmbeddedDerbyTest &#123;

    private static final Logger log &#x3D; LoggerFactory.getLogger(EmbeddedDerbyTest.class);

    &#x2F;** Derby驱动,在derby.jar里面. *&#x2F;
    private static final String DRIVER &#x3D; &quot;org.apache.derby.jdbc.EmbeddedDriver&quot;;

    &#x2F;** 连接Derby的url，create&#x3D;true表示当数据库不存在时就创建它. *&#x2F;
    private static final String URL &#x3D; &quot;jdbc:derby:EmbeddedDB;create&#x3D;true&quot;;

    &#x2F;**
     * main方法.
     *
     * @param args 数组参数
     *&#x2F;
    public static void main(String[] args) &#123;
        Connection conn &#x3D; null;
        Statement st &#x3D; null;
        ResultSet rs &#x3D; null;
        try &#123;
            Class.forName(DRIVER);
            conn &#x3D; DriverManager.getConnection(URL);&#x2F;&#x2F;启动嵌入式数据库
            st &#x3D; conn.createStatement();
            st.execute(&quot;create table foo (FOOID INT NOT NULL, FOONAME VARCHAR(30) NOT NULL)&quot;); &#x2F;&#x2F;创建foo表
            st.executeUpdate(&quot;insert into foo(FOOID,FOONAME) values (1, &#39;blinkfox&#39;)&quot;); &#x2F;&#x2F;插入一条数据
            rs &#x3D; st.executeQuery(&quot;select * from foo&quot;);&#x2F;&#x2F;读取刚插入的数据
            while (rs.next()) &#123;
                int id &#x3D; rs.getInt(1);
                String name &#x3D; rs.getString(2);
                log.info(&quot;查询结果：id &#x3D; &#123;&#125;; name &#x3D; &#123;&#125;&quot;, id, name);
            &#125;
        &#125; catch (Exception e) &#123;
            log.error(&quot;使用Derby数据库出错!&quot;, e);
        &#125; finally &#123;
            JdbcDaoHelper.close(rs);
            JdbcDaoHelper.close(st);
            JdbcDaoHelper.close(conn);
        &#125;
    &#125;

&#125;</code></pre><p>运行上面程序后，会在当前目录生成名为<code>EmbeddedDB</code>的文件夹，既是<code>EmbeddedDB</code>数据库的数据文件存放的地方，控制台将输出：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">查询结果：id &#x3D; 1; name &#x3D; blinkfox</code></pre><h3 id="2-网络数据库"><a href="#2-网络数据库" class="headerlink" title="2. 网络数据库"></a>2. 网络数据库</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.PrintWriter;
import java.sql.DriverManager;

import org.apache.derby.drda.NetworkServerControl;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

&#x2F;**
 * Derby网络数据库测试示例.
 *
 * @author blinkfox on 2017-12-04.
 *&#x2F;
public class NetworkServerDerbyTest &#123;

    private static final Logger log &#x3D; LoggerFactory.getLogger(NetworkServerDerbyTest.class);

    &#x2F;** Derby驱动,在derbyclient.jar里面. *&#x2F;
    private static final String DRIVER &#x3D; &quot;org.apache.derby.jdbc.ClientDriver&quot;;

    &#x2F;** 连接Derby的url. *&#x2F;
    private static final String URL &#x3D; &quot;jdbc:derby:&#x2F;&#x2F;localhost:1527&#x2F;NetworkDB;create&#x3D;true&quot;;

    &#x2F;**
     * main方法.
     * &lt;p&gt;创建Derby网络服务器,默认端口是1527,也可以通过运行&lt;Derby_Home&gt;&#x2F;frameworks&#x2F;NetworkServer&#x2F;bin&#x2F;startNetworkServer.bat
     来创建并启动Derby网络服务器,如果是Unix,用startNetworkServer.ksh&lt;&#x2F;p&gt;
     *
     * @param args 数组参数
     *&#x2F;
    public static void main(String[] args) &#123;
        NetworkServerControl derbyServer &#x3D; null;
        try &#123;
            &#x2F;&#x2F;NetworkServerControl类在derbynet.jar里面
            derbyServer &#x3D; new NetworkServerControl();
            PrintWriter pw &#x3D; new PrintWriter(System.out); &#x2F;&#x2F;用系统输出作为Derby数据库的输出
            derbyServer.start(pw); &#x2F;&#x2F;启动Derby服务器
            Class.forName(DRIVER);
            DriverManager.getConnection(URL);
        &#125; catch (Exception e) &#123;
            log.error(&quot;操作Derby网络数据库异常!&quot;, e);
        &#125; finally &#123;
            if (derbyServer !&#x3D; null) &#123;
                try &#123;
                    derbyServer.shutdown();
                &#125; catch (Exception e) &#123;
                    log.error(&quot;关闭Derby网络数据库异常!&quot;, e);
                &#125;
            &#125;
        &#125;
    &#125;

&#125;</code></pre><p>运行上面程序后,会在当前目录生成名为<code>NetworkDB</code>的文件夹。关于<code>Derby</code>的详细情况,请参考<a target="_blank" rel="noopener external nofollow noreferrer" href="http://db.apache.org/derby">http://db.apache.org/derby</a>。</p><h2 id="十、JDBC-4-0"><a href="#十、JDBC-4-0" class="headerlink" title="十、JDBC 4.0"></a>十、JDBC 4.0</h2><p>在 Java SE 6 所提供的诸多新特性和改进中，值得一提的是为 Java 程序提供数据库访问机制的 JDBC 版本升级到了 4.0, 这个以 JSR-221 为代号的版本，提供了更加便利的代码编写机制及柔性，并且支持更多的数据类型。JDBC4.0 主要有以下改进和新特性。</p><ul><li>自动加载<code>java.sql.Driver</code>，而不需要再调用<code>class.forName</code>；</li><li>添加了<code>java.sql.RowId</code>数据类型用来可以访问<code>sql rowid</code>；</li><li>添加了<code>National Character Set</code>的支持；</li><li>增强了<code>BLOB</code>和<code>CLOB</code>的支持功能；</li><li><code>SQL/XML</code>和<code>XML</code>支持；</li><li><code>Wrapper Pattern</code>；</li><li><code>SQLException</code>增强；</li><li><code>Connection</code>和<code>Statement</code>接口增强；</li><li><code>New Scalar Funtions</code>；</li><li><code>JDBC API changes</code>。</li></ul><h2 id="十一、值得关注的"><a href="#十一、值得关注的" class="headerlink" title="十一、值得关注的"></a>十一、值得关注的</h2><h3 id="1-集合框架增强"><a href="#1-集合框架增强" class="headerlink" title="1. 集合框架增强"></a>1. 集合框架增强</h3><p>Jdk6中的集合框架的API更改数量要少于JDK5，更多地关注了规范的准确性和清晰度。即使在编写旧版本的程序时，我们也建议使用Java SE 6规范。<br>API更改的主要主题是更好的双向收集访问。</p><p>新增了以下几个接口：</p><ul><li><code>Deque</code>: 双端队列接口，继承了Queue接口，队列两头都可以实现入队和出队。</li><li><code>BlockingDeque</code>: 双端阻塞队列接口，继承了BlockingQueue、Deque接口。</li><li><code>NavigableSet</code>: 可导航Set接口，继承自SortedSet接口。</li><li><code>NavigableMap</code>: 可导航Map接口，继承自SortedMap接口。</li><li><code>ConcurrentNavigableMap</code>: 支持并发的可导航Map，继承自<code>ConcurrentMap</code>接口和<code>NavigableMap</code>接口。</li></ul><p>新增了以下几个实现类：</p><ul><li><code>ArrayDeque</code>: 底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java已不推荐使用Stack，而是推荐使用更高效的<code>ArrayDeque</code>来实现栈的功能，非线程安全。</li><li><code>ConcurrentSkipListSet</code>: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeSet功能相似，线程安全。</li><li><code>ConcurrentSkipListMap</code>: 底层使用跳跃列表来实现，适用于高并发的场景，内部使用了ConcurrentNavigableMap，同TreeMap功能相似，是一个并发的、可排序的Map，线程安全。因此它可以在多线程环境中弥补ConcurrentHashMap不支持排序的问题。</li><li><code>LinkedBlockingDeque</code>: 底层采用了双向链表实现的双端阻塞并发队列，无限扩展且可选容量。该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>AbstractMap.SimpleEntry</code>: <code>Map.Entry</code>的简单可变实现。</li><li><code>AbstractMap.SimpleImmutableEntry</code>: <code>Map.Entry</code>的简单不可变实现。</li></ul><p>以下的类已经被改进来用来实现新的接口：</p><ul><li><code>LinkedList</code>: 改进以实现Deque接口。</li><li><code>TreeSet</code>: 改进以实现NavigableSet接口。</li><li><code>TreeMap</code>: 改进以实现NavigableMap接口。</li></ul><p>新增了两个新的方法到<code>Collections</code>的工具类中：</p><ul><li><code>newSetFromMap(Map)</code>: 从通用的Map实现中创建一个通用的Set实现。Java集合中有<code>IdentityHashMap</code>，但是没有<code>IdentityHashSet</code>类，我们可以通过这样的方式来实现：</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Set&lt;Object&gt; identityHashSet &#x3D; Collections.newSetFromMap(new IdentityHashMap&lt;Object, Boolean&gt;());</code></pre><ul><li><code>asLifoQueue(Deque)</code>: 通过传入<code>Deque</code>得到一个后进先出(LIFO)的队列。</li></ul><p>现在<code>Arrays</code>工具类，具有<code>copyOf</code>和<code>copyOfRange</code>方法，可以有效地调整，截断或复制所有类型的数组的子数组。</p><p>以前是这样实现的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] newArray &#x3D; new int[newLength];
System.arraycopy(oldArray, 0, newArray, 0, oldArray.length);</code></pre><p>现在可以这样实现：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">int[] newArray &#x3D; Arrays.copyOf(a, newLength);</code></pre><hr><p>参考文档：</p><p>-<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.oracle.com/technetwork/java/javase/features-141434.html">JavaSE6 Features and Enhancements</a><br>-<a target="_blank" rel="noopener external nofollow noreferrer" href="https://segmentfault.com/a/1190000004417536">Java6的新特性</a><br>-<a target="_blank" rel="noopener external nofollow noreferrer" href="http://my.csdn.net/Chinajash">chinajash</a></p></div><div class="post-footer"><div></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="/blog/2018/11/38926.html" class="pre-post btn btn-default" title="Java7新特性及使用"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">Java7新特性及使用</span> </a><a href="/blog/2018/11/8311.html" class="next-post btn btn-default" title="Java5新特性及使用"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">Java5新特性及使用</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><p>评论系统未开启，无法评论！</p></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2669241897" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></main><aside class="col-md-4 sidebar"><div class="widget"><h3 class="title">赞助广告</h3><ins class="adsbygoogle" style="display:block;width:100%;height:280px" data-ad-client="ca-pub-9312750344484857" data-ad-slot="2014094445" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script><p style="text-align:center">想要出现再此！</p></div><div class="widget"><h3 class="title">分类</h3><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/blog/category/Mac-OS/"><i class="fa" aria-hidden="true">Mac OS</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Nuxtjs/"><i class="fa" aria-hidden="true">Nuxtjs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/Objective-C/"><i class="fa" aria-hidden="true">Objective-C</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/babel/"><i class="fa" aria-hidden="true">babel</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/css/"><i class="fa" aria-hidden="true">css</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/danger/"><i class="fa" aria-hidden="true">danger</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/data-structure/"><i class="fa" aria-hidden="true">data structure</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/design/"><i class="fa" aria-hidden="true">design</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es6/"><i class="fa" aria-hidden="true">es6</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/es7/"><i class="fa" aria-hidden="true">es7</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/eslint/"><i class="fa" aria-hidden="true">eslint</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/flutter/"><i class="fa" aria-hidden="true">flutter</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/git/"><i class="fa" aria-hidden="true">git</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/github/"><i class="fa" aria-hidden="true">github</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/golang/"><i class="fa" aria-hidden="true">golang</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/http/"><i class="fa" aria-hidden="true">http</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/java/"><i class="fa" aria-hidden="true">java</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/javascript/"><i class="fa" aria-hidden="true">javascript</i></a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/jest/"><i class="fa" aria-hidden="true">jest</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/koa/"><i class="fa" aria-hidden="true">koa</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/lerna/"><i class="fa" aria-hidden="true">lerna</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/linux/"><i class="fa" aria-hidden="true">linux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/mysql/"><i class="fa" aria-hidden="true">mysql</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/netlify/"><i class="fa" aria-hidden="true">netlify</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nginx/"><i class="fa" aria-hidden="true">nginx</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/nodejs/"><i class="fa" aria-hidden="true">nodejs</i></a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/npm/"><i class="fa" aria-hidden="true">npm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/programm/"><i class="fa" aria-hidden="true">programm</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/react/"><i class="fa" aria-hidden="true">react</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux/"><i class="fa" aria-hidden="true">redux</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/redux-thunk/"><i class="fa" aria-hidden="true">redux-thunk</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/regex/"><i class="fa" aria-hidden="true">regex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/rollup/"><i class="fa" aria-hidden="true">rollup</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/shell/"><i class="fa" aria-hidden="true">shell</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/sketch/"><i class="fa" aria-hidden="true">sketch</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/the-super-tiny-compiler/"><i class="fa" aria-hidden="true">the-super-tiny-compiler</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/threejs/"><i class="fa" aria-hidden="true">threejs</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/typescript/"><i class="fa" aria-hidden="true">typescript</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vscode/"><i class="fa" aria-hidden="true">vscode</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue/"><i class="fa" aria-hidden="true">vue</i></a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vue-router/"><i class="fa" aria-hidden="true">vue-router</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/vuex/"><i class="fa" aria-hidden="true">vuex</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/webpack/"><i class="fa" aria-hidden="true">webpack</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/wechat/"><i class="fa" aria-hidden="true">wechat</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link current" href="/blog/category/%E5%89%8D%E7%AB%AF/"><i class="fa" aria-hidden="true">前端</i></a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%90%8E%E7%AB%AF/"><i class="fa" aria-hidden="true">后端</i></a><span class="category-list-count">25</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E5%BB%BA%E7%AB%99%E6%95%99%E7%A8%8B/"><i class="fa" aria-hidden="true">建站教程</i></a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="fa" aria-hidden="true">数据库</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E6%9D%82%E8%B0%88/"><i class="fa" aria-hidden="true">杂谈</i></a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%A7%91%E6%8A%80%E7%88%B1%E5%A5%BD%E8%80%85%E5%91%A8%E5%88%8A-%E9%98%AE%E4%B8%80%E5%B3%B0/"><i class="fa" aria-hidden="true">科技爱好者周刊(阮一峰)</i></a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E7%BC%96%E7%A8%8B%E4%B9%8B%E9%81%93/"><i class="fa" aria-hidden="true">编程之道</i></a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E5%85%B7/"><i class="fa" aria-hidden="true">软件工具</i></a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/blog/category/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"><i class="fa" aria-hidden="true">软件设计</i></a><span class="category-list-count">16</span></li></ul></div><div class="widget"><h3 class="title">归档</h3><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/03/"><i class="fa" aria-hidden="true">2020年03月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2020/01/"><i class="fa" aria-hidden="true">2020年01月</i></a><span class="archive-list-count">13</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/12/"><i class="fa" aria-hidden="true">2019年12月</i></a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/11/"><i class="fa" aria-hidden="true">2019年11月</i></a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/08/"><i class="fa" aria-hidden="true">2019年08月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/07/"><i class="fa" aria-hidden="true">2019年07月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/04/"><i class="fa" aria-hidden="true">2019年04月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/03/"><i class="fa" aria-hidden="true">2019年03月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/02/"><i class="fa" aria-hidden="true">2019年02月</i></a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2019/01/"><i class="fa" aria-hidden="true">2019年01月</i></a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/12/"><i class="fa" aria-hidden="true">2018年12月</i></a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/11/"><i class="fa" aria-hidden="true">2018年11月</i></a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/10/"><i class="fa" aria-hidden="true">2018年10月</i></a><span class="archive-list-count">28</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/09/"><i class="fa" aria-hidden="true">2018年09月</i></a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/08/"><i class="fa" aria-hidden="true">2018年08月</i></a><span class="archive-list-count">16</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/07/"><i class="fa" aria-hidden="true">2018年07月</i></a><span class="archive-list-count">14</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/06/"><i class="fa" aria-hidden="true">2018年06月</i></a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/05/"><i class="fa" aria-hidden="true">2018年05月</i></a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/04/"><i class="fa" aria-hidden="true">2018年04月</i></a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/2018/03/"><i class="fa" aria-hidden="true">2018年03月</i></a><span class="archive-list-count">1</span></li></ul></div><div class="widget"><h3 class="title">标签云</h3><div class="content tag-cloud"><a href="/blog/tagged/Apache/" style="font-size:13.33px">Apache</a> <a href="/blog/tagged/CPU%E7%BC%93%E5%AD%98/" style="font-size:10px">CPU缓存</a> <a href="/blog/tagged/CSS/" style="font-size:10px">CSS</a> <a href="/blog/tagged/Cryptojs/" style="font-size:10px">Cryptojs</a> <a href="/blog/tagged/DevOps/" style="font-size:10px">DevOps</a> <a href="/blog/tagged/Equality-operator/" style="font-size:10px">Equality operator</a> <a href="/blog/tagged/Fenix/" style="font-size:10px">Fenix</a> <a href="/blog/tagged/Git/" style="font-size:10px">Git</a> <a href="/blog/tagged/GitLab-CI/" style="font-size:10px">GitLab CI</a> <a href="/blog/tagged/Google/" style="font-size:10px">Google</a> <a href="/blog/tagged/JAVA-HOME/" style="font-size:10px">JAVA_HOME</a> <a href="/blog/tagged/JPA/" style="font-size:10px">JPA</a> <a href="/blog/tagged/Java/" style="font-size:20px">Java</a> <a href="/blog/tagged/JavaScript/" style="font-size:13.33px">JavaScript</a> <a href="/blog/tagged/Jenkins/" style="font-size:10px">Jenkins</a> <a href="/blog/tagged/Linux/" style="font-size:13.33px">Linux</a> <a href="/blog/tagged/MVEL/" style="font-size:11.11px">MVEL</a> <a href="/blog/tagged/Markdown/" style="font-size:10px">Markdown</a> <a href="/blog/tagged/PostgreSQL/" style="font-size:10px">PostgreSQL</a> <a href="/blog/tagged/React-Fire/" style="font-size:10px">React Fire</a> <a href="/blog/tagged/Semicolon/" style="font-size:10px">Semicolon</a> <a href="/blog/tagged/Spring/" style="font-size:11.11px">Spring</a> <a href="/blog/tagged/SpringBoot/" style="font-size:10px">SpringBoot</a> <a href="/blog/tagged/Typora/" style="font-size:10px">Typora</a> <a href="/blog/tagged/UML/" style="font-size:11.11px">UML</a> <a href="/blog/tagged/Vue/" style="font-size:10px">Vue</a> <a href="/blog/tagged/ajax/" style="font-size:10px">ajax</a> <a href="/blog/tagged/analysis-package/" style="font-size:10px">analysis package</a> <a href="/blog/tagged/async/" style="font-size:10px">async</a> <a href="/blog/tagged/cheerio/" style="font-size:10px">cheerio</a> <a href="/blog/tagged/commit-message/" style="font-size:10px">commit message</a> <a href="/blog/tagged/communication/" style="font-size:10px">communication</a> <a href="/blog/tagged/component/" style="font-size:10px">component</a> <a href="/blog/tagged/currying/" style="font-size:10px">currying</a> <a href="/blog/tagged/decorator/" style="font-size:10px">decorator</a> <a href="/blog/tagged/fiber/" style="font-size:10px">fiber</a> <a href="/blog/tagged/fix-bug/" style="font-size:10px">fix bug</a> <a href="/blog/tagged/function/" style="font-size:10px">function</a> <a href="/blog/tagged/git-clone/" style="font-size:10px">git clone</a> <a href="/blog/tagged/golang/" style="font-size:10px">golang</a> <a href="/blog/tagged/hexo/" style="font-size:14.44px">hexo</a> <a href="/blog/tagged/hooks/" style="font-size:10px">hooks</a> <a href="/blog/tagged/http/" style="font-size:10px">http</a> <a href="/blog/tagged/justify/" style="font-size:10px">justify</a> <a href="/blog/tagged/let/" style="font-size:10px">let</a> <a href="/blog/tagged/login/" style="font-size:10px">login</a> <a href="/blog/tagged/module/" style="font-size:11.11px">module</a> <a href="/blog/tagged/nginx/" style="font-size:11.11px">nginx</a> <a href="/blog/tagged/note/" style="font-size:18.89px">note</a> <a href="/blog/tagged/npm/" style="font-size:11.11px">npm</a> <a href="/blog/tagged/npx/" style="font-size:10px">npx</a> <a href="/blog/tagged/open/" style="font-size:10px">open</a> <a href="/blog/tagged/package/" style="font-size:10px">package</a> <a href="/blog/tagged/package-json/" style="font-size:10px">package.json</a> <a href="/blog/tagged/path/" style="font-size:10px">path</a> <a href="/blog/tagged/pm2/" style="font-size:11.11px">pm2</a> <a href="/blog/tagged/promise/" style="font-size:10px">promise</a> <a href="/blog/tagged/refs/" style="font-size:10px">refs</a> <a href="/blog/tagged/rem/" style="font-size:10px">rem</a> <a href="/blog/tagged/render/" style="font-size:10px">render</a> <a href="/blog/tagged/require/" style="font-size:10px">require</a> <a href="/blog/tagged/rzero/" style="font-size:10px">rzero</a> <a href="/blog/tagged/selector/" style="font-size:10px">selector</a> <a href="/blog/tagged/service/" style="font-size:10px">service</a> <a href="/blog/tagged/setTimeout/" style="font-size:10px">setTimeout</a> <a href="/blog/tagged/source/" style="font-size:16.67px">source</a> <a href="/blog/tagged/ssh/" style="font-size:10px">ssh</a> <a href="/blog/tagged/ssr/" style="font-size:10px">ssr</a> <a href="/blog/tagged/timer/" style="font-size:10px">timer</a> <a href="/blog/tagged/tools/" style="font-size:10px">tools</a> <a href="/blog/tagged/tree-shaking/" style="font-size:10px">tree-shaking</a> <a href="/blog/tagged/typecho/" style="font-size:15.56px">typecho</a> <a href="/blog/tagged/typecho%E6%8F%92%E4%BB%B6/" style="font-size:15.56px">typecho插件</a> <a href="/blog/tagged/types/" style="font-size:10px">types</a> <a href="/blog/tagged/utils/" style="font-size:10px">utils</a> <a href="/blog/tagged/virtual-dom/" style="font-size:10px">virtual dom</a> <a href="/blog/tagged/vscode/" style="font-size:10px">vscode</a> <a href="/blog/tagged/wasm/" style="font-size:13.33px">wasm</a> <a href="/blog/tagged/webassembly/" style="font-size:13.33px">webassembly</a> <a href="/blog/tagged/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size:10px">位运算</a> <a href="/blog/tagged/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/" style="font-size:11.11px">单元测试</a> <a href="/blog/tagged/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" style="font-size:10px">性能测试</a> <a href="/blog/tagged/%E6%95%B4%E6%B4%81%E4%BB%A3%E7%A0%81/" style="font-size:10px">整洁代码</a> <a href="/blog/tagged/%E6%B5%8B%E8%AF%95/" style="font-size:10px">测试</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" style="font-size:10px">设计原则</a> <a href="/blog/tagged/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size:17.78px">设计模式</a> <a href="/blog/tagged/%E9%87%8D%E6%9E%84/" style="font-size:10px">重构</a> <a href="/blog/tagged/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" style="font-size:12.22px">面向对象编程</a></div></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi"></div></div><div class="col-sm-12"><span>Copyright &copy; 2021 - 2023 Liuxfe</span></div></div></div></div><script src="/js/app.js?rev=@@hash.js"></script><script>!function(e,t,c,n,r,a){e.ym=e.ym||function(){(e.ym.a=e.ym.a||[]).push(arguments)},e.ym.l=+new Date;for(var m=0;m<document.scripts.length;m++)if(document.scripts[m].src===n)return;r=t.createElement(c),a=t.getElementsByTagName(c)[0],r.async=1,r.src=n,a.parentNode.insertBefore(r,a)}(window,document,"script","https://mc.yandex.ru/metrika/tag.js"),ym(93104114,"init",{clickmap:!0,trackLinks:!0,accurateTrackBounce:!0})</script></body></html>